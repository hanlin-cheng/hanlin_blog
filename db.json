{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/img/avatar1.jpg","path":"img/avatar1.jpg","modified":0,"renderable":0},{"_id":"source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":0},{"_id":"source/img/beautifulmountain.png","path":"img/beautifulmountain.png","modified":0,"renderable":0},{"_id":"source/img/earth_sunrise_from_space-wallpaper-2560x1440.jpg","path":"img/earth_sunrise_from_space-wallpaper-2560x1440.jpg","modified":0,"renderable":0},{"_id":"source/img/material-1.png","path":"img/material-1.png","modified":0,"renderable":0},{"_id":"source/img/landscape_54-wallpaper-1920x1080.jpg","path":"img/landscape_54-wallpaper-1920x1080.jpg","modified":0,"renderable":0},{"_id":"source/img/material-2.png","path":"img/material-2.png","modified":0,"renderable":0},{"_id":"source/img/material-4.png","path":"img/material-4.png","modified":0,"renderable":0},{"_id":"source/img/material-5.png","path":"img/material-5.png","modified":0,"renderable":0},{"_id":"source/img/material-10.png","path":"img/material-10.png","modified":0,"renderable":0},{"_id":"source/img/material-3.png","path":"img/material-3.png","modified":0,"renderable":0},{"_id":"source/img/material-7.png","path":"img/material-7.png","modified":0,"renderable":0},{"_id":"source/img/material-6.png","path":"img/material-6.png","modified":0,"renderable":0},{"_id":"source/img/material-8.png","path":"img/material-8.png","modified":0,"renderable":0},{"_id":"source/img/material-9.png","path":"img/material-9.png","modified":0,"renderable":0},{"_id":"source/img/mountains_night_sky-wallpaper-2560x1440.jpg","path":"img/mountains_night_sky-wallpaper-2560x1440.jpg","modified":0,"renderable":0},{"_id":"source/media/3d9e381b93fe4df790357680b15d4635.png","path":"media/3d9e381b93fe4df790357680b15d4635.png","modified":0,"renderable":0},{"_id":"source/media/7186eb58ef60fc61dc55f573da016c01.png","path":"media/7186eb58ef60fc61dc55f573da016c01.png","modified":0,"renderable":0},{"_id":"source/media/1dc08fc545592a16bdd4e69456f7603f.png","path":"media/1dc08fc545592a16bdd4e69456f7603f.png","modified":0,"renderable":0},{"_id":"source/media/4c410326f68b9c901ae092e6d1bee594.png","path":"media/4c410326f68b9c901ae092e6d1bee594.png","modified":0,"renderable":0},{"_id":"source/media/82e528c1d8aeb1e85113f6a7d826cdfd.png","path":"media/82e528c1d8aeb1e85113f6a7d826cdfd.png","modified":0,"renderable":0},{"_id":"source/media/69f20a18f8f1c1c329109e71c3456afc.png","path":"media/69f20a18f8f1c1c329109e71c3456afc.png","modified":0,"renderable":0},{"_id":"source/media/84e9d962295b753134094e778499e2a0.png","path":"media/84e9d962295b753134094e778499e2a0.png","modified":0,"renderable":0},{"_id":"source/media/GetImage(1).png","path":"media/GetImage(1).png","modified":0,"renderable":0},{"_id":"source/media/90765ad142ae9c04739fde85d776f281.png","path":"media/90765ad142ae9c04739fde85d776f281.png","modified":0,"renderable":0},{"_id":"source/media/GetImage.png","path":"media/GetImage.png","modified":0,"renderable":0},{"_id":"source/media/a5f23af609c2c0cc2c6cfe51f1ca22f0.png","path":"media/a5f23af609c2c0cc2c6cfe51f1ca22f0.png","modified":0,"renderable":0},{"_id":"source/media/899e5f1f4f1d4a5651454501e4b6a19c.png","path":"media/899e5f1f4f1d4a5651454501e4b6a19c.png","modified":0,"renderable":0},{"_id":"source/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS01NjYzNTk5ZTg0MzNmNWI4LnBuZw.png","path":"media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS01NjYzNTk5ZTg0MzNmNWI4LnBuZw.png","modified":0,"renderable":0},{"_id":"source/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0wM2ViZDRkZjlkZTVkNTU1LnBuZw.png","path":"media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0wM2ViZDRkZjlkZTVkNTU1LnBuZw.png","modified":0,"renderable":0},{"_id":"source/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGI3ZTczMjExYjRjODliLnBuZw.png","path":"media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGI3ZTczMjExYjRjODliLnBuZw.png","modified":0,"renderable":0},{"_id":"source/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGJhY2Q4N2Y0NDlkYmI4LnBuZw.png","path":"media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGJhY2Q4N2Y0NDlkYmI4LnBuZw.png","modified":0,"renderable":0},{"_id":"source/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS04Nzc5YmMwOWE1M2ViNDBjLnBuZw.png","path":"media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS04Nzc5YmMwOWE1M2ViNDBjLnBuZw.png","modified":0,"renderable":0},{"_id":"source/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iZjE3MjU0NTIwOWI4N2UxLnBuZw.png","path":"media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iZjE3MjU0NTIwOWI4N2UxLnBuZw.png","modified":0,"renderable":0},{"_id":"source/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iNDg4YzYyMDk0NTE2ZTBjLnBuZw.png","path":"media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iNDg4YzYyMDk0NTE2ZTBjLnBuZw.png","modified":0,"renderable":0},{"_id":"source/media/b80e022befbbb1f86356f354c265237d.png","path":"media/b80e022befbbb1f86356f354c265237d.png","modified":0,"renderable":0},{"_id":"source/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1hOWIzZmMyZWQxNmY2MWU1LnBuZw","path":"media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1hOWIzZmMyZWQxNmY2MWU1LnBuZw","modified":0,"renderable":0},{"_id":"source/media/b5d733fac8312c1270eb8bc87d58c555.png","path":"media/b5d733fac8312c1270eb8bc87d58c555.png","modified":0,"renderable":0},{"_id":"source/media/c48e58454fc351e9fe69d2891a001cae.png","path":"media/c48e58454fc351e9fe69d2891a001cae.png","modified":0,"renderable":0},{"_id":"source/media/c++const修饰的局部变量分配到符号表上.png","path":"media/c++const修饰的局部变量分配到符号表上.png","modified":0,"renderable":0},{"_id":"source/media/f700387f242b93abd4799aae4384a23a.png","path":"media/f700387f242b93abd4799aae4384a23a.png","modified":0,"renderable":0},{"_id":"source/media/e3b2ae52a820296728e9a11336313dcd.png","path":"media/e3b2ae52a820296728e9a11336313dcd.png","modified":0,"renderable":0},{"_id":"source/media/f1a009c02af2e121f29b74a8c7899747.png","path":"media/f1a009c02af2e121f29b74a8c7899747.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/img/avatar1.jpg","hash":"ad42266cd221268f96fd454c345ff7b7c93f7434","modified":1692875375485},{"_id":"source/_data/link.yml","hash":"2579982f3b72166a54c8b86aa88a6257c8c5baa2","modified":1692787760073},{"_id":"source/img/avatar.png","hash":"16615605a9c2d46fba3e8c1bec94258649aa5a4b","modified":1692804863508},{"_id":"source/categories/index.md","hash":"df36239f3e6260a7571d45566a094e093ab0dd2c","modified":1692713222372},{"_id":"source/img/material-4.png","hash":"b475dfbf67a076a4e17a5527fd1973b1d4adac07","modified":1692942889407},{"_id":"source/img/material-10.png","hash":"363466a376e4df9e61acc904cd25f3c7ae1a7280","modified":1692942850125},{"_id":"source/img/material-3.png","hash":"848eaa70b9b0cd7a2204c78e8aa324d8f96bb097","modified":1692942880379},{"_id":"source/img/material-8.png","hash":"57db542d526ef6866cb34e261096e93a0e6f3a82","modified":1692942812781},{"_id":"source/img/material-9.png","hash":"840319c4d1f38fb8df79eb4669ed2e14d89fd680","modified":1692942938845},{"_id":"source/about/index.md","hash":"75810a164e1c2a46bac8452cc6f29ffd78c754ff","modified":1692928685460},{"_id":"source/media/3d9e381b93fe4df790357680b15d4635.png","hash":"77263e78cc605e067e989530faf4798e1b9d3993","modified":1672370024817},{"_id":"source/img/material-6.png","hash":"2f841e0c064fecb607ad1e149662a0c96d9e725d","modified":1692942833250},{"_id":"source/media/1dc08fc545592a16bdd4e69456f7603f.png","hash":"d331238b1d702f641d96a830a4a9658c8796e40d","modified":1672370024817},{"_id":"source/media/84e9d962295b753134094e778499e2a0.png","hash":"658fb0b3661edfc262e25f6b121a2d78a08f550f","modified":1672370024820},{"_id":"source/media/GetImage.png","hash":"f8820ce334ff2f8bcbcafa1aaf4703215b61c54a","modified":1672370024822},{"_id":"source/media/GetImage(1).png","hash":"1de2d0231623da0ff97baadce48ce89c9af422df","modified":1672370024822},{"_id":"source/media/899e5f1f4f1d4a5651454501e4b6a19c.png","hash":"b46020a05ef74367622f1564d63403b8e9e2bc20","modified":1672370024820},{"_id":"source/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGI3ZTczMjExYjRjODliLnBuZw.png","hash":"e06df56cfb89ef3f7968e73494e92caeeea92aa2","modified":1672370024823},{"_id":"source/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iNDg4YzYyMDk0NTE2ZTBjLnBuZw.png","hash":"ae5ac019e222faa603a826ca9a57986f0b4da567","modified":1672370024827},{"_id":"source/media/c++const修饰的局部变量分配到符号表上.png","hash":"cb17f92ba81b69b161a914db030fadb5a030bf83","modified":1672370024828},{"_id":"source/media/b5d733fac8312c1270eb8bc87d58c555.png","hash":"b9e4dc24a6089ae3003b4075333fda22cf092d34","modified":1672370024828},{"_id":"source/media/f700387f242b93abd4799aae4384a23a.png","hash":"4e33e0f0486f2a68b6e42839acb4c06d32252f21","modified":1672370024833},{"_id":"source/tags/index.md","hash":"838424a46be5e9942c0317045a81db84e6337d1f","modified":1692713239222},{"_id":"source/software/index.md","hash":"b339083102760bf593eac6319c9ce005fe5c223e","modified":1692943509022},{"_id":"source/ebook/index.md","hash":"903f2dfa6592faba8df4b6b95061903957cef6cf","modified":1692943568756},{"_id":"source/link/index.md","hash":"4db31cb9cbe254aa24057cc429ff14360f7a0d78","modified":1692713318936},{"_id":"source/_posts/C++/CMakeLists简易模板.md","hash":"7d336eb0519f8de19886731dab7022cb813d851a","modified":1672370024814},{"_id":"source/_posts/C++/Eigen几何模块的引入.md","hash":"9df572489eca9a1b66bd2bb3273c27c2acaefb10","modified":1672370024815},{"_id":"source/_posts/C++/C++11chrono库.md","hash":"633630d02191059f7e780f3045f711c4edd21b36","modified":1692891877042},{"_id":"source/_posts/C++/C++下const增强.md","hash":"f7b4dbcb02a11b90a6beb54482a46c43ab4a773d","modified":1672370024814},{"_id":"source/_posts/C++/Find_package.md","hash":"4e2f5ded1ce0222ea301e44a7dcf552fa1d172d6","modified":1672370024815},{"_id":"source/_posts/C++/GoogleTest.md","hash":"5c720cabc3920b1ed32b0b79d63dea588c25563e","modified":1688981701939},{"_id":"source/_posts/C++/EigenGeometry.md","hash":"ed8bdb2dd051740bc9d9b7eb85ce260e4474d7a1","modified":1672370024815},{"_id":"source/_posts/C++/Opencv_Mat.md","hash":"3d72fb47aed23677b18d4547a4054a135da17f6e","modified":1672370024815},{"_id":"source/_posts/C++/Protocol_Buffers基本使用.md","hash":"799e62282e3f5aa089517c862465fecf52457943","modified":1672370024815},{"_id":"source/_posts/C++/CMakelists基础指令.md","hash":"af72f4d23cb5c10c67e938c0d06f51d1f2619ae1","modified":1672370024814},{"_id":"source/_posts/C++/STL容器使用时机.md","hash":"2f99ad77ba92a5693eefc2c6c70d469a62f12804","modified":1672370024816},{"_id":"source/_posts/C++/c++并发与多线程.md","hash":"1b3f9e9d2968a6c039beb7c76edc367780e4d54f","modified":1692891889073},{"_id":"source/_posts/C++/ROS指令.md","hash":"eda1b93dee4a9e071be46f2587fbcefdea85d531","modified":1672370024816},{"_id":"source/_posts/C++/const成员函数.md","hash":"0e3f55da57868069b2592d34357c341422e0e3c7","modified":1672370024816},{"_id":"source/_posts/C++/gflags使用.md","hash":"da23ef3be3dfba0d7bf6889535ed7564c52f2df2","modified":1672370024816},{"_id":"source/_posts/C++/cin与get()getline()输入问题.md","hash":"65c26a6b72b326c6efae1a5a21b8f2cd5bf00692","modified":1672370024816},{"_id":"source/_posts/C++/opencv常用api.md","hash":"d7765a86c928c723402b3b4ec22dcd13cc6cfddc","modified":1672370024833},{"_id":"source/_posts/C++/string和cstring头文件的区别.md","hash":"368eebdeabcd9bd9d22d0bff174dfe9f04ee8348","modified":1672370024834},{"_id":"source/_posts/C++/内联函数.md","hash":"0e4d95d77e0ea3a7f81080e0e1cf54faab5b686e","modified":1672370024834},{"_id":"source/_posts/C++/二叉树遍历.md","hash":"26e0da938dc099f38684e513cc257acc5ac4df7e","modified":1672370024834},{"_id":"source/_posts/C++/常用函数.md","hash":"91a261f3ae2251eeb5c3a6f3ca027e1b5d93d0ff","modified":1672370024834},{"_id":"source/_posts/C++/左值与右值.md","hash":"e578c66f03368b0b44aee06afda3c2ca3a26502d","modified":1672370024834},{"_id":"source/_posts/C++/函数指针的定义方式.md","hash":"afdba33c9dd647e9a90d42cd1a42f192b483e67e","modified":1672370024834},{"_id":"source/_posts/C++/单例模式.md","hash":"714b8cd6fd01273c04aaf504d913395a53dfbbce","modified":1672370024834},{"_id":"source/_posts/C++/构造函数的调用时机.md","hash":"30d0c9eaebc5b6a2e8904f68f2a055fbe0691872","modified":1672370024834},{"_id":"source/_posts/C++/常规函数与内联函数.md","hash":"83b0b89cd25ae9dea3aeb4dc4955e4910037dccc","modified":1672370024834},{"_id":"source/_posts/C++/数据类型字节数.md","hash":"dd9cc9c579ab8ba73081810e38e86f0f644caa8b","modified":1673928156198},{"_id":"source/_posts/C++/计算时间.md","hash":"20a71c62da48431a20d9c888c5841943c38807d2","modified":1672370024835},{"_id":"source/_posts/C++/转换.md","hash":"2ee49854284d22541dc4c396d76188e25461f7bc","modified":1672370024835},{"_id":"source/_posts/C++/类知识点.md","hash":"e91a33c95fd007bb342f99eb7c850463b2b342eb","modified":1672370024835},{"_id":"source/_posts/C++/media/3d9e381b93fe4df790357680b15d4635.png","hash":"77263e78cc605e067e989530faf4798e1b9d3993","modified":1672370024817},{"_id":"source/_posts/C++/media/1dc08fc545592a16bdd4e69456f7603f.png","hash":"d331238b1d702f641d96a830a4a9658c8796e40d","modified":1672370024817},{"_id":"source/_posts/C++/media/84e9d962295b753134094e778499e2a0.png","hash":"658fb0b3661edfc262e25f6b121a2d78a08f550f","modified":1672370024820},{"_id":"source/_posts/C++/media/899e5f1f4f1d4a5651454501e4b6a19c.png","hash":"b46020a05ef74367622f1564d63403b8e9e2bc20","modified":1672370024820},{"_id":"source/_posts/C++/media/GetImage(1).png","hash":"1de2d0231623da0ff97baadce48ce89c9af422df","modified":1672370024822},{"_id":"source/_posts/C++/media/GetImage.png","hash":"f8820ce334ff2f8bcbcafa1aaf4703215b61c54a","modified":1672370024822},{"_id":"source/_posts/C++/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGI3ZTczMjExYjRjODliLnBuZw.png","hash":"e06df56cfb89ef3f7968e73494e92caeeea92aa2","modified":1672370024823},{"_id":"source/_posts/C++/media/b5d733fac8312c1270eb8bc87d58c555.png","hash":"b9e4dc24a6089ae3003b4075333fda22cf092d34","modified":1672370024828},{"_id":"source/_posts/C++/media/c++const修饰的局部变量分配到符号表上.png","hash":"cb17f92ba81b69b161a914db030fadb5a030bf83","modified":1672370024828},{"_id":"source/_posts/C++/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iNDg4YzYyMDk0NTE2ZTBjLnBuZw.png","hash":"ae5ac019e222faa603a826ca9a57986f0b4da567","modified":1672370024827},{"_id":"source/_posts/C++/media/f700387f242b93abd4799aae4384a23a.png","hash":"4e33e0f0486f2a68b6e42839acb4c06d32252f21","modified":1672370024833},{"_id":"source/img/material-1.png","hash":"4839299eaa4db7272befa7b824e54b647fbbfc44","modified":1692942953780},{"_id":"source/img/material-2.png","hash":"faba2ce69c19d6c1dac392dd10b054e0061f6fb7","modified":1692942917610},{"_id":"source/img/material-5.png","hash":"5041ebd073a139c67f8ed271e74c967c7eb9c5be","modified":1692942927921},{"_id":"source/img/material-7.png","hash":"5c49ff3c064aaeb21227c2bd98b5ae422ddca84c","modified":1692942905388},{"_id":"source/media/7186eb58ef60fc61dc55f573da016c01.png","hash":"b1532e42947c534b5c0711f57dbceac3b655fb02","modified":1672370024819},{"_id":"source/media/69f20a18f8f1c1c329109e71c3456afc.png","hash":"d1f4e7d7b303b53e0b1f0b408cc93680ca6aef4c","modified":1672370024819},{"_id":"source/media/90765ad142ae9c04739fde85d776f281.png","hash":"7e4a726eb9d110647923e89296b30a465775af70","modified":1672370024821},{"_id":"source/media/82e528c1d8aeb1e85113f6a7d826cdfd.png","hash":"b8c7f08b686bccbd1cc2a729492544a76f2840ea","modified":1672370024820},{"_id":"source/media/a5f23af609c2c0cc2c6cfe51f1ca22f0.png","hash":"2993d43fb0126beaff642eb5d28ebd1870a37831","modified":1672370024822},{"_id":"source/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS01NjYzNTk5ZTg0MzNmNWI4LnBuZw.png","hash":"032bde9ad75d0604fee9ee3f482385546a00b173","modified":1672370024823},{"_id":"source/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0wM2ViZDRkZjlkZTVkNTU1LnBuZw.png","hash":"6278e38b49ac16264d4b0a28dbbedfc9a0c39661","modified":1672370024825},{"_id":"source/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGJhY2Q4N2Y0NDlkYmI4LnBuZw.png","hash":"098fb3bd15a3627b077f60de22df7724ae512842","modified":1672370024824},{"_id":"source/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS04Nzc5YmMwOWE1M2ViNDBjLnBuZw.png","hash":"b34846923a38341adc41e607877bd3a53f3ea403","modified":1672370024825},{"_id":"source/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iZjE3MjU0NTIwOWI4N2UxLnBuZw.png","hash":"4fc06223e530b50b7c1929e6915d8ef82af8497d","modified":1672370024828},{"_id":"source/media/b80e022befbbb1f86356f354c265237d.png","hash":"96e542ef5a3e3532ede7d8c879f529960f73537c","modified":1672370024828},{"_id":"source/_posts/C++/media/82e528c1d8aeb1e85113f6a7d826cdfd.png","hash":"b8c7f08b686bccbd1cc2a729492544a76f2840ea","modified":1672370024820},{"_id":"source/_posts/C++/media/69f20a18f8f1c1c329109e71c3456afc.png","hash":"d1f4e7d7b303b53e0b1f0b408cc93680ca6aef4c","modified":1672370024819},{"_id":"source/_posts/C++/media/90765ad142ae9c04739fde85d776f281.png","hash":"7e4a726eb9d110647923e89296b30a465775af70","modified":1672370024821},{"_id":"source/_posts/C++/media/7186eb58ef60fc61dc55f573da016c01.png","hash":"b1532e42947c534b5c0711f57dbceac3b655fb02","modified":1672370024819},{"_id":"source/_posts/C++/media/a5f23af609c2c0cc2c6cfe51f1ca22f0.png","hash":"2993d43fb0126beaff642eb5d28ebd1870a37831","modified":1672370024822},{"_id":"source/_posts/C++/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGJhY2Q4N2Y0NDlkYmI4LnBuZw.png","hash":"098fb3bd15a3627b077f60de22df7724ae512842","modified":1672370024824},{"_id":"source/_posts/C++/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS01NjYzNTk5ZTg0MzNmNWI4LnBuZw.png","hash":"032bde9ad75d0604fee9ee3f482385546a00b173","modified":1672370024823},{"_id":"source/_posts/C++/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0wM2ViZDRkZjlkZTVkNTU1LnBuZw.png","hash":"6278e38b49ac16264d4b0a28dbbedfc9a0c39661","modified":1672370024825},{"_id":"source/_posts/C++/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS04Nzc5YmMwOWE1M2ViNDBjLnBuZw.png","hash":"b34846923a38341adc41e607877bd3a53f3ea403","modified":1672370024825},{"_id":"source/_posts/C++/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iZjE3MjU0NTIwOWI4N2UxLnBuZw.png","hash":"4fc06223e530b50b7c1929e6915d8ef82af8497d","modified":1672370024828},{"_id":"source/_posts/C++/media/b80e022befbbb1f86356f354c265237d.png","hash":"96e542ef5a3e3532ede7d8c879f529960f73537c","modified":1672370024828},{"_id":"source/media/c48e58454fc351e9fe69d2891a001cae.png","hash":"c6729861a1661c9bae092fe7e9b9866bacc34540","modified":1672370024829},{"_id":"source/_posts/C++/media/c48e58454fc351e9fe69d2891a001cae.png","hash":"c6729861a1661c9bae092fe7e9b9866bacc34540","modified":1672370024829},{"_id":"source/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1hOWIzZmMyZWQxNmY2MWU1LnBuZw","hash":"aa71e1867d6a1938bd91df4723d7b07481396d01","modified":1672370024826},{"_id":"source/_posts/C++/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1hOWIzZmMyZWQxNmY2MWU1LnBuZw","hash":"aa71e1867d6a1938bd91df4723d7b07481396d01","modified":1672370024826},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1692703059480},{"_id":"themes/butterfly/package.json","hash":"a6a032654a36408d7b7274bc9cfe21f89946d29c","modified":1692703059501},{"_id":"themes/butterfly/README.md","hash":"5ca893c78f8971f512da55c785b8ccbfa9d37cfc","modified":1692703059480},{"_id":"themes/butterfly/_config.yml","hash":"b684e7cc1100d22a59a13ec48d09b1eef0610e34","modified":1692944171265},{"_id":"themes/butterfly/languages/default.yml","hash":"d444cbb5c5456aaf27f3fb1b4308634689c7bb53","modified":1692703059481},{"_id":"themes/butterfly/README_CN.md","hash":"f6ae7f38d016135340fd25c5fd1be65452b6773d","modified":1692703059480},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"145ec301db185c8a06de1f34a77ca391e1d2729b","modified":1692703059483},{"_id":"themes/butterfly/languages/en.yml","hash":"4957fd976c99745d3aa24000a85b2955e8d1cf81","modified":1692703059481},{"_id":"themes/butterfly/plugins.yml","hash":"6d68dab3b79accb1bceb4710c8aaab724a45053a","modified":1692703059501},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1692703059501},{"_id":"themes/butterfly/layout/post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1692703059501},{"_id":"themes/butterfly/layout/category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1692703059483},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"d9ff4bad9c9664e12729c7a531169a05698a3fd1","modified":1692703059479},{"_id":"themes/butterfly/layout/page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1692703059500},{"_id":"themes/butterfly/layout/archive.pug","hash":"115fa5ee8864e5c97549eff91a17c66101d724ab","modified":1692703059483},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"cc8672dc0c2762b694f689cbeb6e34810f1c194e","modified":1692703059483},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1692703059479},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1692703059500},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"92683cb785a29e5a73701b33dba73d3afac268c3","modified":1692703059479},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1692703059479},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1692703059483},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"b50b0afdc41c54279587410c3f82c8cb3c5ff46d","modified":1692703059483},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1692703059479},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1692703059483},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9277fead4c29dbe93976f078adaa26e8f9253da3","modified":1692703059488},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"50eea5aa78cdeb6c72dd22f0aeabc407cc0f712e","modified":1692703059483},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1692703059502},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"c5c58714fb3cb839653e5c32e6094784c8662935","modified":1692703059487},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1692703059501},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"c55f05400eb27ab051f47396ec8d4249ce6f71ec","modified":1692703059488},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"96df62e34661d8ca4a45267286127479e5178a79","modified":1692703059486},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"95479790234c291b064d031577d71214cdd1d820","modified":1692703059502},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"5fd6c9659262dc8f61d87866d0417fd534292c88","modified":1692703059502},{"_id":"themes/butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1692703059502},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1692703059502},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"a3323fcb11cfd3f3e21230737341beb5d76b40aa","modified":1692703059503},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"8ff03b35385f9162e1eb54dceb5fa7f781306caf","modified":1692703059503},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"218add7e9b39b6fb6e69921abb9e44891a6cc3ce","modified":1692703059502},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1692703059503},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"76343ac8422c9c8539082e77eda6ffee4b877eb2","modified":1692703059504},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1692703059503},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1692703059516},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"7222102f9919f8e961d4f1688425845fb7775ada","modified":1692703059503},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"6005907245dd74b153f03afdccfae1abb66bb482","modified":1692703059503},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1692703059516},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1692703059504},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"b8d95ac1851c37f1dce4b1dd4a1d3ffdff501a03","modified":1692703059504},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"44cca49ddc76921bb455465ef912cab46c993cef","modified":1692703059504},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1692703059516},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"e01a3967e5884881bab858b11635457df412de80","modified":1692703059504},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1692703059505},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"fc5a80707cf522378be3cf8638ef78bccc88c510","modified":1692703059505},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"551f1b8edc973bd8afc5cce2eae546f002fa84c3","modified":1692703059505},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1692703059505},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"56a5d41487d74654b75305c5325167a116495900","modified":1692703059505},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"4c7056d3cd56f10bd209d2ba4d3cc2027aad1440","modified":1692703059505},{"_id":"themes/butterfly/source/css/var.styl","hash":"e1e37a2e932163886789b72624c7348545003f1d","modified":1692703059515},{"_id":"themes/butterfly/source/js/main.js","hash":"4fd1cd7a02dedcb686caf6149c35fd8e1fbcafc9","modified":1692703059516},{"_id":"themes/butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1692703059515},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"fd683ccc090db3122d77c7ee73e8d35dc8735ee3","modified":1692703059505},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"a102a6cacf7b20183946a54580867a964f3674c4","modified":1692703059517},{"_id":"themes/butterfly/source/js/utils.js","hash":"13b2b02118a0f4ec2e9e0bb1b90f5b1a30a70f44","modified":1692703059517},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"1bef867c799ba158c5417272fb137539951aa120","modified":1692703059485},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"50b4b9c7f6a4771910be4198639cfcfc6d7b8925","modified":1692703059485},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1692703059485},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"7a641b5dd45b970e1dafd1433eb32ea149e55cf2","modified":1692703059485},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c7666a10448edd93f5ace37296051b7670495f1b","modified":1692703059483},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"962ee70a35e60a13c31eea47d16b9f98069fe417","modified":1692703059485},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"c8dbdfe6145a0bc6f7691c9551be8169a2698f0a","modified":1692703059483},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"f5207840c96df6b26ad227433babca4f8c362624","modified":1692703059483},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1692703059484},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1692703059484},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1692703059484},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1692703059484},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"fd55f0e09827ef40c53c48d184a553464aac3e03","modified":1692703059484},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"00ae419f527d8225a2dc03d4f977cec737248423","modified":1692703059486},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1692703059484},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"a6fde4835d6460ce7baf792fd5e1977fad73db25","modified":1692703059486},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"766baca6ddce49d1724a02312387b292ff2d0bdc","modified":1692703059486},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"3adb731465a4ab14529277fd7867889e0800ad16","modified":1692703059486},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"cc1f7ae8a7ce5445277215821092e712ec8cc296","modified":1692703059487},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"9155f01d4c644a2e19b2b13b2d3c6d5e34dd0abf","modified":1692703059486},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1692703059487},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"594626a18b7efbf771232855dfbce143fb244bc6","modified":1692703059488},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1692703059487},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"12be059c536490af216a397e8f2a7abbf6d4610e","modified":1692703059487},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1692703059489},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"e37681bc9c169d4220f26ecda2b3d5c02b6b9a0f","modified":1692703059487},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1692703059496},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"82bb447a5d045980789cf3f9de9d49cc32011b13","modified":1692703059496},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4e37535c63149708ecbedb262336014524ad8723","modified":1692703059493},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1692703059496},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1692703059499},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1692703059499},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"dfb5e16a7e7106bb20b2ac2d0df1251d0fc79609","modified":1692703059498},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"ab037bf5794638bd30da4cf7cf106e5d03b5f696","modified":1692703059499},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1692703059499},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1692703059499},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1692703059499},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"8e22f53886a57a68286970d8af8b4c950fd4a1d7","modified":1692703059499},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"59d979702fa21d960443824198614d63aaf69662","modified":1692703059499},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1692703059500},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"12185713f9ca08984fc74e3b69d8cd6828d23da8","modified":1692703059500},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"e43017dbc73e0ce95dcfcb9dfb4fcce0c1715dd4","modified":1692703059506},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1692703059500},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"4c86c10f8ec0c8fb60b400a5a2f14699d3155be4","modified":1692703059510},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"9066a62e442affce3a923a06a90486bf9d364e0e","modified":1692703059510},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"ba94ceb40d7c81372a76103d958dcc2cc6a84f00","modified":1692703059500},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1692703059507},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1692703059500},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"9893656128c347d1c09c90784627c84c979b326f","modified":1692703059506},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"431b4a252443e224872bd6b4f6aa76ed1679a82c","modified":1692703059506},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1692703059511},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1692703059511},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1692703059511},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"5dd1ba997741d02894ff846eda939ad8051c0bb2","modified":1692703059511},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"df7a51fcabbadab5aa31770e3202a47c9599bbb7","modified":1692703059511},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"57d333ef47bfb8fd22da31f600527c9d91e8e322","modified":1692703059511},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1692703059512},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"0abe05309a186682772a94e5e759b63f8028e61a","modified":1692703059508},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"3969f599e8657adf8c3ce287d83f5d0a23f276a9","modified":1692703059508},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"5e27f7842af82ff7498d4b59787ce9ca90fa9e6f","modified":1692703059508},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"20303c0dad28e5c5335ce2fa6582f1fafae5b628","modified":1692703059508},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1692703059509},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"792a04d36de32f230ca3256ad87a90fe8392f333","modified":1692703059508},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"fc029f5e00d7904c0878efd20dd4e09fc55e1d03","modified":1692703059509},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1692703059509},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"824b2b2d2ee72583b9e009c0bb13e29e806534cc","modified":1692703059510},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1692703059508},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"7e9b65dcae7ac54e0183bc841fea0f4bd4d78e5c","modified":1692703059510},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"15ea7564b2e3bf46bc91fb6e49c94d057b37caaf","modified":1692703059510},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"cf90ea339fbb7f345212319627fcd68964024e40","modified":1692703059512},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"b5ba2c3339ad406ce611d12d3f8cc84f864fbc03","modified":1692703059509},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"0b23010154e19f37f0c4af0110f9f834d6d41a13","modified":1692703059512},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1692703059513},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1692703059514},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"7c463ba25b3b54f0f46dfd75971d792816e942a8","modified":1692703059513},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1692703059513},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"37db99299af380e9111dce2a78a5049b301b13e0","modified":1692703059512},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1692703059513},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1692703059513},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1692703059513},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"ec81ea316c82b83d6aee31e52f248d329559d5d3","modified":1692703059514},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"bbe930d8425bdaee2a5ba3cade42b617cee42934","modified":1692703059517},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1692703059514},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"40e76d6da538cb3c1ef6b79ffc0adfa64fe6b8ba","modified":1692703059517},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"19b5cfa1f77781246e02967cefe149f19170e45f","modified":1692703059489},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"331c89ecfb79fab68466944a43e9e3d0ff49c646","modified":1692703059513},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4b98145d6584d586cabf033493282afc72ae816a","modified":1692703059489},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1692703059489},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1692703059490},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1692703059490},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"c42bbce31fcd8846cf3360f4c383dec9368daeba","modified":1692703059490},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1692703059489},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1692703059490},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1692703059490},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"6d40b521eec4136f6742c548a4445ed593470b1b","modified":1692703059491},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"799da8f3015e6fe440681b21644bcb3810a5518c","modified":1692703059491},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1692703059490},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"1157118db9f5d7c0c5a0fc7c346f6e934ca00d52","modified":1692703059491},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"0010c7a10d265c4329f0fd4db85b4a9ea7ba06b5","modified":1692703059488},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1692703059489},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"b47698e153c73cb29286b19bec5ddd920cb7ffba","modified":1692703059491},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f8b73bc63ec1b45d86aa3891d8c81ef4d5980943","modified":1692703059491},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"58f37823f6cd9a194fb50f7ca7c2233e49939034","modified":1692703059488},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"b19b123df682b23491b17dcca386d79062cd8f6e","modified":1692703059491},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"1a20b11fa0e6b1943e9b4d81e197a25ca36af66d","modified":1692703059492},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"7c7fbe27d82becc9ee509765f1195c69f5864a0b","modified":1692703059492},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"a56edeb1ce2f1b1fb0e866a30543f274b9f7d69e","modified":1692703059492},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"c5e131d65a7ad30f3cb98ac3b94cd2f6a94c22e9","modified":1692703059492},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"f618457d62ef35d78a31e7fb1e375a462f64b228","modified":1692703059493},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1692703059492},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1692703059492},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"cba55cbbd0962bf84b8956195e686b0e158ed247","modified":1692703059493},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4bb4cf58e219dfb8787273c931b1ea978b2ab88f","modified":1692703059493},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"386a2b371644c2682560733617561ba6e6bf9ab2","modified":1692703059493},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1692703059494},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"6b0d28671afd5ed286a714f25ba16256a2e7d880","modified":1692703059493},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f0d3eddd2bed68e5517274b3530bfe0fa5057d8e","modified":1692703059494},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1692703059494},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"da94966a9650ef3e4c69f3ee93758b30fa42cb78","modified":1692703059494},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"cfcfaed3a52fa47fff4cc65a053a2f025fb3b7b6","modified":1692703059495},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"a6be932d1f64c6190f5d03b5b77fba09fa0fd6b8","modified":1692703059495},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"4f8bd22c5c32d5430cbe08ab4e861b6f8b86f820","modified":1692703059495},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f8b65460c399973090c1fb7ab81e3708c252e7cc","modified":1692703059495},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"4fb998a05e51ef2302775945883307ee3039a544","modified":1692703059495},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"edd4ebf76a79fb74cfae03a286fab90f74324dbd","modified":1692703059495},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"2f3af113713563e34b10bbe998cc15008f81c85a","modified":1692703059496},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1692703059497},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"ce4ab79c85df9f77395269eb01e9a023d7f96376","modified":1692703059496},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4898a09d8e67fb358ffd74b3a1f0014f555dd856","modified":1692703059498},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1692703059497},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"8106bd031586f075a994956ee4438eb13be25d7b","modified":1692703059498},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1692703059497},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"ba04174d977da988a1d49c06641262c413352346","modified":1692703059497},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1692703059507},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1692703059507},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1692703059507},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"4b9c35375e0eb9cf99ad246d5ca838eca64a635d","modified":1692703059497},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"90338ac4cd114d324fe1caaaeea8be9ca05d6a46","modified":1692703059497},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1692703059507},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1692703059507},{"_id":"source/media/4c410326f68b9c901ae092e6d1bee594.png","hash":"b69d76fc3ceb2c42c09c31b643de13f661cdcc9a","modified":1672370024818},{"_id":"source/_posts/C++/media/4c410326f68b9c901ae092e6d1bee594.png","hash":"b69d76fc3ceb2c42c09c31b643de13f661cdcc9a","modified":1672370024818},{"_id":"source/media/e3b2ae52a820296728e9a11336313dcd.png","hash":"f6c03fc190a9e827632dfad0e7216ea2f04c40ce","modified":1672370024831},{"_id":"source/_posts/C++/media/e3b2ae52a820296728e9a11336313dcd.png","hash":"f6c03fc190a9e827632dfad0e7216ea2f04c40ce","modified":1672370024831},{"_id":"source/img/beautiful_space_view-wallpaper-2560x1440.jpg","hash":"99086edb07ad383cee986e2796d5ad11aa386f9a","modified":1692928406836},{"_id":"source/media/f1a009c02af2e121f29b74a8c7899747.png","hash":"289afe0ae037b03569398f8d8b12f91fb94e61a8","modified":1672370024833},{"_id":"source/_posts/C++/media/f1a009c02af2e121f29b74a8c7899747.png","hash":"289afe0ae037b03569398f8d8b12f91fb94e61a8","modified":1672370024833},{"_id":"source/img/earth_from_space_2-wallpaper-2560x1440.jpg","hash":"9ea320694d078aa4a3a51844bf1b68207e80dd52","modified":1692928457818},{"_id":"source/img/earth_sunrise_from_space-wallpaper-2560x1440.jpg","hash":"17f0d57373b73a27bf32c0c49a78154957e6eeb2","modified":1692928425320},{"_id":"source/img/a_kings_demise-wallpaper-2560x1440.jpg","hash":"505574768527e32382927b5814b2ffefc039fa1f","modified":1692928447974},{"_id":"source/img/beautifulmountain.png","hash":"01d52fa2920daa59b7bfcb7fc005030eff5295b7","modified":1692805861571},{"_id":"source/img/landscape_54-wallpaper-1920x1080.jpg","hash":"a6bdabee513b0dd357bd4319a61525bb51cb32a5","modified":1692928468233},{"_id":"source/img/mountains_night_sky-wallpaper-2560x1440.jpg","hash":"5863d36513d6c5a5a4ae7e3fcbd8d4aa5cee6e18","modified":1692928366683},{"_id":"source/img/mountains_night-wallpaper-2560x1440.jpg","hash":"ab77d0b6cc4f24e88fa27ef42cd211d44bdbfcaa","modified":1692928385140},{"_id":"public/tags/index.html","hash":"82eeac324a0663c25c710dda3dfd28ffc2f5e728","modified":1692948335237},{"_id":"public/about/index.html","hash":"ee19da9792519aa6262544973833eebff79b1c40","modified":1692948335237},{"_id":"public/software/index.html","hash":"c730a49e47cfe12e5848f92fa0be8736e5de3697","modified":1692948335237},{"_id":"public/categories/index.html","hash":"4695a5537247b3b6dc92863339bbe7b4aff56c4f","modified":1692948335237},{"_id":"public/link/index.html","hash":"22c91c1cf81539caaa4a4b889432a544812e9361","modified":1692948335237},{"_id":"public/ebook/index.html","hash":"581f1d337104822c5155741132f7983e420941e8","modified":1692948335237},{"_id":"public/2023/08/24/C++/转换/index.html","hash":"38a2357cc38f02d399c4948db68e50c3f4770c4d","modified":1692948249587},{"_id":"public/2023/08/24/C++/计算时间/index.html","hash":"8b2d3738b7f02c246a4fdc2539455e1f6b830230","modified":1692948249587},{"_id":"public/2023/08/24/C++/类知识点/index.html","hash":"9d47b42d2fb5f6bd0a10d1c04eb8d24df2c1205f","modified":1692948249587},{"_id":"public/2023/08/24/C++/数据类型字节数/index.html","hash":"e2f96672cf87f7e0ca2136d6123530fa038f5f48","modified":1692948249587},{"_id":"public/2023/08/24/C++/构造函数的调用时机/index.html","hash":"013c74cd3da0b70985c1a3cf38bacf85a00d1902","modified":1692948249587},{"_id":"public/2023/08/24/C++/常规函数与内联函数/index.html","hash":"6d40e737ab63bafee826f4cbb32c1e22907c24c2","modified":1692948249587},{"_id":"public/2023/08/24/C++/常用函数/index.html","hash":"64fb0d6cffd91e03c66345f28097ee5f099c0ca2","modified":1692948249587},{"_id":"public/2023/08/24/C++/左值与右值/index.html","hash":"17dfdb1ec7e83b06bd92de2336b8a8a61074bd3f","modified":1692948249587},{"_id":"public/2023/08/24/C++/单例模式/index.html","hash":"5632a0dfe149964cf775d29b60633a6b6f62c698","modified":1692948249587},{"_id":"public/2023/08/24/C++/函数指针的定义方式/index.html","hash":"2be2ae629591b218d24203db36c9794d1c175025","modified":1692948249587},{"_id":"public/2023/08/24/C++/内联函数/index.html","hash":"d6e94a89ef7b206ecf98adf59ca30502cf5e5181","modified":1692948249587},{"_id":"public/2023/08/24/C++/二叉树遍历/index.html","hash":"e577d1c6444a5b9cc5606b252a885929950cb3d8","modified":1692948249587},{"_id":"public/2023/08/24/C++/STL容器使用时机/index.html","hash":"fe95ff271b634bdb9f532a65731eb6e45639902c","modified":1692948249587},{"_id":"public/2023/08/24/C++/string和cstring头文件的区别/index.html","hash":"b4ae48fae3bcf9c6d56c33e04ceaa8ed0c383c1d","modified":1692948249587},{"_id":"public/2023/08/24/C++/ROS指令/index.html","hash":"51cc00d18ea91b1003cc69ec70d2acbebf4b057d","modified":1692948249587},{"_id":"public/2023/08/24/C++/Protocol_Buffers基本使用/index.html","hash":"5af4f53b5561dd7eef79b315d56e92b47a75556a","modified":1692948249587},{"_id":"public/2023/08/24/C++/opencv常用api/index.html","hash":"e1b531d5a9368585e8e2a825cef06fca155bb0b0","modified":1692948249587},{"_id":"public/2023/08/24/C++/Opencv_Mat/index.html","hash":"fa4f371089349c001607875bf8862de7d8a8d9d0","modified":1692948249587},{"_id":"public/2023/08/24/C++/gflags使用/index.html","hash":"4b08145015a88b11afc16b15db0b21cccf6cb379","modified":1692948249587},{"_id":"public/2023/08/24/C++/GoogleTest/index.html","hash":"b739e87b352f61942803b5c6ea159df62aafe95b","modified":1692948249587},{"_id":"public/2023/08/24/C++/Eigen几何模块的引入/index.html","hash":"e0c2740a32ef1f54b499b3260b1d79de0dea2098","modified":1692948249587},{"_id":"public/2023/08/24/C++/Find_package/index.html","hash":"295f6371396c569a7ac783471593495eac01f9f0","modified":1692948249587},{"_id":"public/2023/08/24/C++/EigenGeometry/index.html","hash":"0577cf477ae81be1e5ace8d34976612dc8efa799","modified":1692948249587},{"_id":"public/2023/08/24/C++/const成员函数/index.html","hash":"60f2ac63141cfc6d6a23f5b71d77bde42f9eeb23","modified":1692948249587},{"_id":"public/2023/08/24/C++/CMakeLists简易模板/index.html","hash":"b727c6a3584c292cc742322fe2b4b1803095f4ce","modified":1692948249587},{"_id":"public/2023/08/24/C++/CMakelists基础指令/index.html","hash":"c783485264ffab6da4c43208a6c9afe59b37ce0a","modified":1692948249587},{"_id":"public/2023/08/24/C++/cin与get()getline()输入问题/index.html","hash":"a1fc7c95c142025d144e4fb233b857d7c07f972e","modified":1692948249587},{"_id":"public/2023/08/24/C++/c++并发与多线程/index.html","hash":"56f58d69938220c81e87c211ac8e06136ea27066","modified":1692948166546},{"_id":"public/index.html","hash":"af34f229fa55d42ad6733cb8b82e50ea7e9ccc65","modified":1692948335237},{"_id":"public/2023/08/24/C++/C++下const增强/index.html","hash":"635d14ae22e114cb6b912c2b6533484cae85557b","modified":1692948249587},{"_id":"public/2023/08/24/C++/C++11chrono库/index.html","hash":"f36cff531ca64e2c59c785c11548ef0255c5ef3d","modified":1692948166546},{"_id":"public/page/2/index.html","hash":"49aa7bfd42bd80e68ee72f01d6c9d69e9e74dd51","modified":1692948335237},{"_id":"public/page/3/index.html","hash":"575b97660c1238c57896e3aa5ef02a0524b6bf04","modified":1692948335237},{"_id":"public/archives/index.html","hash":"62b15b710481166e095e84647237867220150fc1","modified":1692948335237},{"_id":"public/archives/page/2/index.html","hash":"a2535035ed6f3f9fc835769a08f53070b5272dbe","modified":1692948335237},{"_id":"public/archives/page/3/index.html","hash":"33b9e10451935d4bec2ba4d162d64d9bcafc5a72","modified":1692948335237},{"_id":"public/archives/2023/page/2/index.html","hash":"d4e7347199c7da98390951c75bd100c3c1baddad","modified":1692948335237},{"_id":"public/archives/2023/index.html","hash":"e4082e35f8049c28696774075ebe0ddb88f5e08c","modified":1692948335237},{"_id":"public/archives/2023/page/3/index.html","hash":"44a6421dbb44db9b6e12825580ab4552a4332550","modified":1692948335237},{"_id":"public/archives/2023/08/index.html","hash":"4097a6b13c5d2946a034fa0e6aaba1a5f8783d85","modified":1692948335237},{"_id":"public/archives/2023/08/page/2/index.html","hash":"981cafd19e1f76dff6fed9d491d77504796e741d","modified":1692948335237},{"_id":"public/archives/2023/08/page/3/index.html","hash":"6d8dfa07a0c87242195f1e5a4463e4f173f77276","modified":1692948335237},{"_id":"public/tags/C/index.html","hash":"cd65bcc7995a8f34e649e707a7c3e7f86f056cf6","modified":1692948335237},{"_id":"public/categories/C/index.html","hash":"556c879f9f01b69fc8ee9b503ad0cfb433dea9f1","modified":1692948335237},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1692946504780},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1692946504780},{"_id":"public/img/avatar.png","hash":"16615605a9c2d46fba3e8c1bec94258649aa5a4b","modified":1692946504780},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1692946504780},{"_id":"public/img/avatar1.jpg","hash":"ad42266cd221268f96fd454c345ff7b7c93f7434","modified":1692946504780},{"_id":"public/img/material-4.png","hash":"b475dfbf67a076a4e17a5527fd1973b1d4adac07","modified":1692946504780},{"_id":"public/img/material-3.png","hash":"848eaa70b9b0cd7a2204c78e8aa324d8f96bb097","modified":1692946504780},{"_id":"public/img/material-6.png","hash":"2f841e0c064fecb607ad1e149662a0c96d9e725d","modified":1692946504780},{"_id":"public/img/material-9.png","hash":"840319c4d1f38fb8df79eb4669ed2e14d89fd680","modified":1692946504780},{"_id":"public/img/material-10.png","hash":"363466a376e4df9e61acc904cd25f3c7ae1a7280","modified":1692946504780},{"_id":"public/img/material-8.png","hash":"57db542d526ef6866cb34e261096e93a0e6f3a82","modified":1692946504780},{"_id":"public/media/3d9e381b93fe4df790357680b15d4635.png","hash":"77263e78cc605e067e989530faf4798e1b9d3993","modified":1692946504780},{"_id":"public/media/1dc08fc545592a16bdd4e69456f7603f.png","hash":"d331238b1d702f641d96a830a4a9658c8796e40d","modified":1692946504780},{"_id":"public/media/GetImage(1).png","hash":"1de2d0231623da0ff97baadce48ce89c9af422df","modified":1692946504780},{"_id":"public/media/84e9d962295b753134094e778499e2a0.png","hash":"658fb0b3661edfc262e25f6b121a2d78a08f550f","modified":1692946504780},{"_id":"public/media/GetImage.png","hash":"f8820ce334ff2f8bcbcafa1aaf4703215b61c54a","modified":1692946504780},{"_id":"public/media/899e5f1f4f1d4a5651454501e4b6a19c.png","hash":"b46020a05ef74367622f1564d63403b8e9e2bc20","modified":1692946504780},{"_id":"public/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGI3ZTczMjExYjRjODliLnBuZw.png","hash":"e06df56cfb89ef3f7968e73494e92caeeea92aa2","modified":1692946504780},{"_id":"public/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iNDg4YzYyMDk0NTE2ZTBjLnBuZw.png","hash":"ae5ac019e222faa603a826ca9a57986f0b4da567","modified":1692946504780},{"_id":"public/media/b5d733fac8312c1270eb8bc87d58c555.png","hash":"b9e4dc24a6089ae3003b4075333fda22cf092d34","modified":1692946504780},{"_id":"public/media/c++const修饰的局部变量分配到符号表上.png","hash":"cb17f92ba81b69b161a914db030fadb5a030bf83","modified":1692946504780},{"_id":"public/media/f700387f242b93abd4799aae4384a23a.png","hash":"4e33e0f0486f2a68b6e42839acb4c06d32252f21","modified":1692946504780},{"_id":"public/img/material-1.png","hash":"4839299eaa4db7272befa7b824e54b647fbbfc44","modified":1692946504780},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1692946504780},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1692946504780},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1692946504780},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1692946504780},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1692946504780},{"_id":"public/css/index.css","hash":"13371dfefb3ac2b52430ffbd2fe915316ac85b2f","modified":1692946504780},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1692946504780},{"_id":"public/img/material-5.png","hash":"5041ebd073a139c67f8ed271e74c967c7eb9c5be","modified":1692946504780},{"_id":"public/img/material-2.png","hash":"faba2ce69c19d6c1dac392dd10b054e0061f6fb7","modified":1692946504780},{"_id":"public/img/material-7.png","hash":"5c49ff3c064aaeb21227c2bd98b5ae422ddca84c","modified":1692946504780},{"_id":"public/media/7186eb58ef60fc61dc55f573da016c01.png","hash":"b1532e42947c534b5c0711f57dbceac3b655fb02","modified":1692946504780},{"_id":"public/media/69f20a18f8f1c1c329109e71c3456afc.png","hash":"d1f4e7d7b303b53e0b1f0b408cc93680ca6aef4c","modified":1692946504780},{"_id":"public/media/82e528c1d8aeb1e85113f6a7d826cdfd.png","hash":"b8c7f08b686bccbd1cc2a729492544a76f2840ea","modified":1692946504780},{"_id":"public/media/90765ad142ae9c04739fde85d776f281.png","hash":"7e4a726eb9d110647923e89296b30a465775af70","modified":1692946504780},{"_id":"public/media/a5f23af609c2c0cc2c6cfe51f1ca22f0.png","hash":"2993d43fb0126beaff642eb5d28ebd1870a37831","modified":1692946504780},{"_id":"public/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS01NjYzNTk5ZTg0MzNmNWI4LnBuZw.png","hash":"032bde9ad75d0604fee9ee3f482385546a00b173","modified":1692946504780},{"_id":"public/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGJhY2Q4N2Y0NDlkYmI4LnBuZw.png","hash":"098fb3bd15a3627b077f60de22df7724ae512842","modified":1692946504780},{"_id":"public/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS04Nzc5YmMwOWE1M2ViNDBjLnBuZw.png","hash":"b34846923a38341adc41e607877bd3a53f3ea403","modified":1692946504780},{"_id":"public/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0wM2ViZDRkZjlkZTVkNTU1LnBuZw.png","hash":"6278e38b49ac16264d4b0a28dbbedfc9a0c39661","modified":1692946504780},{"_id":"public/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iZjE3MjU0NTIwOWI4N2UxLnBuZw.png","hash":"4fc06223e530b50b7c1929e6915d8ef82af8497d","modified":1692946504780},{"_id":"public/media/b80e022befbbb1f86356f354c265237d.png","hash":"96e542ef5a3e3532ede7d8c879f529960f73537c","modified":1692946504780},{"_id":"public/media/c48e58454fc351e9fe69d2891a001cae.png","hash":"c6729861a1661c9bae092fe7e9b9866bacc34540","modified":1692946504780},{"_id":"public/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1hOWIzZmMyZWQxNmY2MWU1LnBuZw","hash":"aa71e1867d6a1938bd91df4723d7b07481396d01","modified":1692946504780},{"_id":"public/media/4c410326f68b9c901ae092e6d1bee594.png","hash":"b69d76fc3ceb2c42c09c31b643de13f661cdcc9a","modified":1692946504780},{"_id":"public/media/e3b2ae52a820296728e9a11336313dcd.png","hash":"f6c03fc190a9e827632dfad0e7216ea2f04c40ce","modified":1692946504780},{"_id":"public/img/beautiful_space_view-wallpaper-2560x1440.jpg","hash":"99086edb07ad383cee986e2796d5ad11aa386f9a","modified":1692946504780},{"_id":"public/media/f1a009c02af2e121f29b74a8c7899747.png","hash":"289afe0ae037b03569398f8d8b12f91fb94e61a8","modified":1692946504780},{"_id":"public/img/earth_from_space_2-wallpaper-2560x1440.jpg","hash":"9ea320694d078aa4a3a51844bf1b68207e80dd52","modified":1692946504780},{"_id":"public/img/earth_sunrise_from_space-wallpaper-2560x1440.jpg","hash":"17f0d57373b73a27bf32c0c49a78154957e6eeb2","modified":1692946504780},{"_id":"public/img/a_kings_demise-wallpaper-2560x1440.jpg","hash":"505574768527e32382927b5814b2ffefc039fa1f","modified":1692946504780},{"_id":"public/img/beautifulmountain.png","hash":"01d52fa2920daa59b7bfcb7fc005030eff5295b7","modified":1692946504780},{"_id":"public/img/landscape_54-wallpaper-1920x1080.jpg","hash":"a6bdabee513b0dd357bd4319a61525bb51cb32a5","modified":1692946504780},{"_id":"public/img/mountains_night_sky-wallpaper-2560x1440.jpg","hash":"5863d36513d6c5a5a4ae7e3fcbd8d4aa5cee6e18","modified":1692946504780},{"_id":"public/img/mountains_night-wallpaper-2560x1440.jpg","hash":"ab77d0b6cc4f24e88fa27ef42cd211d44bdbfcaa","modified":1692946504780}],"Category":[{"name":"C++","_id":"cllq8n0t90008dkr786iz7mq6"}],"Data":[{"_id":"link","data":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}],"Page":[{"title":"标签","date":"2018-01-04T16:00:00.000Z","type":"tags","orderby":"random","order":1,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-01-05 00:00:00\ntype: \"tags\"\norderby: random\norder: 1\n---","updated":"2023-08-22T14:07:19.222Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cllq8n0t20000dkr704nd9kpt","content":"","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-1.png","cover_type":"img","excerpt":"","more":""},{"title":"about","date":"2023-08-24T14:16:41.000Z","type":"about","_content":"\n吕程\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2023-08-24 22:16:41\ntype: \"about\"\n---\n\n吕程\n\n","updated":"2023-08-25T01:58:05.460Z","path":"about/index.html","comments":1,"layout":"page","_id":"cllq8n0t60002dkr7ekb773ng","content":"<p>吕程</p>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-7.png","cover_type":"img","excerpt":"","more":"<p>吕程</p>\n"},{"title":"分类","date":"2018-01-04T16:00:00.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-01-05 00:00:00\ntype: \"categories\"\n---","updated":"2023-08-22T14:07:02.372Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cllq8n0t70004dkr7brzhdlsm","content":"","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-3.png","cover_type":"img","excerpt":"","more":""},{"title":"software","date":"2023-08-25T06:05:09.000Z","_content":"","source":"software/index.md","raw":"---\ntitle: software\ndate: 2023-08-25 14:05:09\n---\n","updated":"2023-08-25T06:05:09.022Z","path":"software/index.html","comments":1,"layout":"page","_id":"cllq8n0t80006dkr70iaf5ahj","content":"","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-10.png","cover_type":"img","excerpt":"","more":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: 友情链接\ndate: 2018-06-07 22:17:49\ntype: \"link\"\n---\n","updated":"2023-08-22T14:08:38.936Z","path":"link/index.html","comments":1,"layout":"page","_id":"cllq8n0ta000adkr7dnod6j66","content":"","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-6.png","cover_type":"img","excerpt":"","more":""},{"title":"ebook","date":"2023-08-25T06:06:08.000Z","_content":"","source":"ebook/index.md","raw":"---\ntitle: ebook\ndate: 2023-08-25 14:06:08\n---\n","updated":"2023-08-25T06:06:08.756Z","path":"ebook/index.html","comments":1,"layout":"page","_id":"cllq8n0tb000cdkr79go05qrc","content":"","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-1.png","cover_type":"img","excerpt":"","more":""}],"Post":[{"_content":"# Eigen几何模块的引入 \n\n## 1、在CMakeLists文件中添加 \n\n```\ninclude_directories(\"/usr/include/eigen3\") \n```\n\n## 2、在main.cpp中添加 \n\n```\n#include <cmath>             //c++的标准数学函数库，不是Eigen中的，但一般要用到 \n#include <Eigen/Core> \n#include <Eigen/Geometry> \nusing namespace Eigen; \n```\n\n## 二、Eigen几何模块的使用 \n\n### 1、定义 \n\n#### 1）三维空间坐标定义 \n\n```\nVector3d v(1,0,0); \n//使用三维纵向量Vector3d定义 \n```\n\n#### 2）旋转矩阵定义 \n\n```\nMatrix3d rotation_matrix = Matrix3d::Identity(); \n//使用Matrix3d或者Matrix3f定义，Matrix3d::Identity()是三阶单位阵\n```\n\n#### 3）旋转向量定义 \n\n```\nAngleAxisd rotation_vector(M_PI / 4,Vector3d(0,0,1)); \n//沿Z轴旋转45度 \n//使用AngleAxisd定义，AngleAxisd（旋转角度，旋转轴单位向量Vector3d） \n//AngleAxisd的底层不直接是Matrix，但由于重载了运算符，因此仍可以当做矩阵运算\n```\n\n注意：AngleAxisd不能用cout输出，以该定义为例，要用rotation_vector.matrix()转换成矩阵形式才能输出，但转换后不再是旋转向量形式，而是3x3的旋转矩阵形式。 \n\n**注意：使用AngleAxisd定义旋转向量时候，C++中M_PI的精度是二十位，并不是真正数学意义上的π \\piπ,因此在计算过程中会引入误差。例子如下：** \n\n```\nAngleAxisd angle_vector = AngleAxisd(M_PI/2,Vector3d(0, 0, 1)); \ncout << angle_vector.matrix() << endl; \n```\n\n数学理论上所出来的angle_vector对应的矩阵应该为： \n\n[0 -1 0] \n\n[1 0 0] \n\n[0 0 1] \n\n但程序输出为： \n\n6.12323e-17 -1 0 \n\n1 6.12323e-17 0 \n\n0 0 1 \n\n将程序中精度由d改成f后，程序输出为： \n\n-4.37114e-08 -1 0 \n\n1 -4.37114e-08 0 \n\n0 0 1 \n\n其中，本应该矩阵中应该为0的元素出现了一个极小值，而且该极小值会随着精度的变化而变化，不过目前发现的影响只有对0元素的影响，这个极小值可以看成0. \n\n#### 4）欧拉角定义 \n\n```\nVector3d eulerangles(0,0,0); \n//使用三维纵向量Vector3d定义\n```\n\n#### 5）欧氏变换矩阵定义 \n\n```\nIsometry3d T = Isometry3d::Identity(); \n//使用Isometry3d定义，虽然叫3d，但实际上是4x4矩阵 \n//Isometry3d::Identity()是将欧氏矩阵初始化为单位矩阵 \nIsometry3d T(q); \n//使用四元数初始化欧氏变换矩阵 \n```\n\n注意：欧氏变换矩阵不能直接用cout输出，以该定义为例，要使用 \n\nT.matrix()转换为矩阵形式输出，转换后仍为4x4的欧氏变换矩阵 \n\n#### 6）四元数定义 \n\n```\nQuaterniond q(Vector4d(1,2,3,4)); \n//使用Vector4d定义，定义格式为（x,y,z,w) \nQuaterniond q((1,2,3,4)); \n//直接赋值，定义格式为(w,x,y,z) \n```\n\n注意：该定义方法下，Vector中四个元素对应关系为（x,y,z,w)，即最后以为才是四元数的实部 \n\n注意：四元数不能直接用cout输出，以该定义为例，输出格式为 \n\n```\ncout << q.coeffs() << endl;  //输出格式为（x,y,z,w)\n```\n\n注意：四元数在使用前要进行归一化，这样由四元数转化出来的旋转矩阵才满足正交性。归一化方法为： \n\n```\nq.normalize(); \n```\n\n### 2、各种变换表达形式之间的转换 \n\n#### 1）旋转向量与旋转矩阵之间的变换 \n\n显示转换 \n\n```\nrotation_matrix = rotation_vector.toRotationMatrix(); \n或 \nrotation_matrix = rotation_vector.matrix(); \n```\n\n注意：此处也存在M_PI引入的误差问题，详讲1-3）旋转向量定义。 \n\n隐式转换（直接赋值） \n\n```\nrotation_matrix = rotation_vector; \nrotation_vector = rotation_matrix; \n```\n\n#### 2）旋转矩阵与欧拉角的变换 \n\n```\neulerangles = rotation_matrix.eulerAngles(2,1,0); \n//参数（2.1.0）表示这是ZYX顺序，即roll pitch yaw \n```\n\n#### 3）欧氏变换矩阵按照旋转向量或旋转矩阵旋转 \n\n```\nT.rotate(rotation_matrix);   //在原来T的基础上按照旋转矩阵进行旋转，然后返回T。就是讲旋转矩阵的变换整合到T中 \nT.rotate(rotation_vector);   //按照旋转向量进行旋转\n```\n\n#### 4）欧氏变换矩阵平移 \n\n```\nT.pretranslate(Vector3d(1,3,4));   //按照向量Vector3d(1,3,4)平移\n```\n\n#### 5）四元数与旋转向量旋转矩阵之间的转换 \n\n显式转换 \n\n```\n q = Quaterniond(rotation_vector)\n q = Quaterniond(rotation_matrix)\n```\n\n隐式转换 \n\n```\nrotation_vector = q\nrotation_matrix = q\nq = rotation_matrix\nq = rotation_vector\n```\n\n### 3、坐标变换 \n\n```\nVector3d v(1,0,0); //定义初始坐标v \nVector3d v_rotated； //定义坐标转换后坐标v_rotated\n```\n\n#### 1）使用旋转矩阵 \n\n```\nv_rotated = rotation_matrix * v \n```\n\n#### 2）使用旋转向量 \n\n```\nv_rotated = rotation_vector * v \n```\n\n#### 3）使用变换矩阵 \n\n```\nVector3d v_tranformed = T * v\n```\n\n#### 4）使用四元数 \n\n```\nv_rotated = q*v\n```\n\n","source":"_posts/C++/Eigen几何模块的引入.md","raw":"# Eigen几何模块的引入 \n\n## 1、在CMakeLists文件中添加 \n\n```\ninclude_directories(\"/usr/include/eigen3\") \n```\n\n## 2、在main.cpp中添加 \n\n```\n#include <cmath>             //c++的标准数学函数库，不是Eigen中的，但一般要用到 \n#include <Eigen/Core> \n#include <Eigen/Geometry> \nusing namespace Eigen; \n```\n\n## 二、Eigen几何模块的使用 \n\n### 1、定义 \n\n#### 1）三维空间坐标定义 \n\n```\nVector3d v(1,0,0); \n//使用三维纵向量Vector3d定义 \n```\n\n#### 2）旋转矩阵定义 \n\n```\nMatrix3d rotation_matrix = Matrix3d::Identity(); \n//使用Matrix3d或者Matrix3f定义，Matrix3d::Identity()是三阶单位阵\n```\n\n#### 3）旋转向量定义 \n\n```\nAngleAxisd rotation_vector(M_PI / 4,Vector3d(0,0,1)); \n//沿Z轴旋转45度 \n//使用AngleAxisd定义，AngleAxisd（旋转角度，旋转轴单位向量Vector3d） \n//AngleAxisd的底层不直接是Matrix，但由于重载了运算符，因此仍可以当做矩阵运算\n```\n\n注意：AngleAxisd不能用cout输出，以该定义为例，要用rotation_vector.matrix()转换成矩阵形式才能输出，但转换后不再是旋转向量形式，而是3x3的旋转矩阵形式。 \n\n**注意：使用AngleAxisd定义旋转向量时候，C++中M_PI的精度是二十位，并不是真正数学意义上的π \\piπ,因此在计算过程中会引入误差。例子如下：** \n\n```\nAngleAxisd angle_vector = AngleAxisd(M_PI/2,Vector3d(0, 0, 1)); \ncout << angle_vector.matrix() << endl; \n```\n\n数学理论上所出来的angle_vector对应的矩阵应该为： \n\n[0 -1 0] \n\n[1 0 0] \n\n[0 0 1] \n\n但程序输出为： \n\n6.12323e-17 -1 0 \n\n1 6.12323e-17 0 \n\n0 0 1 \n\n将程序中精度由d改成f后，程序输出为： \n\n-4.37114e-08 -1 0 \n\n1 -4.37114e-08 0 \n\n0 0 1 \n\n其中，本应该矩阵中应该为0的元素出现了一个极小值，而且该极小值会随着精度的变化而变化，不过目前发现的影响只有对0元素的影响，这个极小值可以看成0. \n\n#### 4）欧拉角定义 \n\n```\nVector3d eulerangles(0,0,0); \n//使用三维纵向量Vector3d定义\n```\n\n#### 5）欧氏变换矩阵定义 \n\n```\nIsometry3d T = Isometry3d::Identity(); \n//使用Isometry3d定义，虽然叫3d，但实际上是4x4矩阵 \n//Isometry3d::Identity()是将欧氏矩阵初始化为单位矩阵 \nIsometry3d T(q); \n//使用四元数初始化欧氏变换矩阵 \n```\n\n注意：欧氏变换矩阵不能直接用cout输出，以该定义为例，要使用 \n\nT.matrix()转换为矩阵形式输出，转换后仍为4x4的欧氏变换矩阵 \n\n#### 6）四元数定义 \n\n```\nQuaterniond q(Vector4d(1,2,3,4)); \n//使用Vector4d定义，定义格式为（x,y,z,w) \nQuaterniond q((1,2,3,4)); \n//直接赋值，定义格式为(w,x,y,z) \n```\n\n注意：该定义方法下，Vector中四个元素对应关系为（x,y,z,w)，即最后以为才是四元数的实部 \n\n注意：四元数不能直接用cout输出，以该定义为例，输出格式为 \n\n```\ncout << q.coeffs() << endl;  //输出格式为（x,y,z,w)\n```\n\n注意：四元数在使用前要进行归一化，这样由四元数转化出来的旋转矩阵才满足正交性。归一化方法为： \n\n```\nq.normalize(); \n```\n\n### 2、各种变换表达形式之间的转换 \n\n#### 1）旋转向量与旋转矩阵之间的变换 \n\n显示转换 \n\n```\nrotation_matrix = rotation_vector.toRotationMatrix(); \n或 \nrotation_matrix = rotation_vector.matrix(); \n```\n\n注意：此处也存在M_PI引入的误差问题，详讲1-3）旋转向量定义。 \n\n隐式转换（直接赋值） \n\n```\nrotation_matrix = rotation_vector; \nrotation_vector = rotation_matrix; \n```\n\n#### 2）旋转矩阵与欧拉角的变换 \n\n```\neulerangles = rotation_matrix.eulerAngles(2,1,0); \n//参数（2.1.0）表示这是ZYX顺序，即roll pitch yaw \n```\n\n#### 3）欧氏变换矩阵按照旋转向量或旋转矩阵旋转 \n\n```\nT.rotate(rotation_matrix);   //在原来T的基础上按照旋转矩阵进行旋转，然后返回T。就是讲旋转矩阵的变换整合到T中 \nT.rotate(rotation_vector);   //按照旋转向量进行旋转\n```\n\n#### 4）欧氏变换矩阵平移 \n\n```\nT.pretranslate(Vector3d(1,3,4));   //按照向量Vector3d(1,3,4)平移\n```\n\n#### 5）四元数与旋转向量旋转矩阵之间的转换 \n\n显式转换 \n\n```\n q = Quaterniond(rotation_vector)\n q = Quaterniond(rotation_matrix)\n```\n\n隐式转换 \n\n```\nrotation_vector = q\nrotation_matrix = q\nq = rotation_matrix\nq = rotation_vector\n```\n\n### 3、坐标变换 \n\n```\nVector3d v(1,0,0); //定义初始坐标v \nVector3d v_rotated； //定义坐标转换后坐标v_rotated\n```\n\n#### 1）使用旋转矩阵 \n\n```\nv_rotated = rotation_matrix * v \n```\n\n#### 2）使用旋转向量 \n\n```\nv_rotated = rotation_vector * v \n```\n\n#### 3）使用变换矩阵 \n\n```\nVector3d v_tranformed = T * v\n```\n\n#### 4）使用四元数 \n\n```\nv_rotated = q*v\n```\n\n","slug":"C++/Eigen几何模块的引入","published":1,"date":"2023-08-24T14:38:18.620Z","updated":"2022-12-30T03:13:44.815Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0t40001dkr7fm8z82qb","content":"<h1 id=\"Eigen几何模块的引入\"><a href=\"#Eigen几何模块的引入\" class=\"headerlink\" title=\"Eigen几何模块的引入\"></a>Eigen几何模块的引入</h1><h2 id=\"1、在CMakeLists文件中添加\"><a href=\"#1、在CMakeLists文件中添加\" class=\"headerlink\" title=\"1、在CMakeLists文件中添加\"></a>1、在CMakeLists文件中添加</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include_directories(&quot;/usr/include/eigen3&quot;) </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、在main-cpp中添加\"><a href=\"#2、在main-cpp中添加\" class=\"headerlink\" title=\"2、在main.cpp中添加\"></a>2、在main.cpp中添加</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;cmath&gt;             //c++的标准数学函数库，不是Eigen中的，但一般要用到 </span><br><span class=\"line\">#include &lt;Eigen/Core&gt; </span><br><span class=\"line\">#include &lt;Eigen/Geometry&gt; </span><br><span class=\"line\">using namespace Eigen; </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、Eigen几何模块的使用\"><a href=\"#二、Eigen几何模块的使用\" class=\"headerlink\" title=\"二、Eigen几何模块的使用\"></a>二、Eigen几何模块的使用</h2><h3 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h3><h4 id=\"1）三维空间坐标定义\"><a href=\"#1）三维空间坐标定义\" class=\"headerlink\" title=\"1）三维空间坐标定义\"></a>1）三维空间坐标定义</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vector3d v(1,0,0); </span><br><span class=\"line\">//使用三维纵向量Vector3d定义 </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2）旋转矩阵定义\"><a href=\"#2）旋转矩阵定义\" class=\"headerlink\" title=\"2）旋转矩阵定义\"></a>2）旋转矩阵定义</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Matrix3d rotation_matrix = Matrix3d::Identity(); </span><br><span class=\"line\">//使用Matrix3d或者Matrix3f定义，Matrix3d::Identity()是三阶单位阵</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3）旋转向量定义\"><a href=\"#3）旋转向量定义\" class=\"headerlink\" title=\"3）旋转向量定义\"></a>3）旋转向量定义</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AngleAxisd rotation_vector(M_PI / 4,Vector3d(0,0,1)); </span><br><span class=\"line\">//沿Z轴旋转45度 </span><br><span class=\"line\">//使用AngleAxisd定义，AngleAxisd（旋转角度，旋转轴单位向量Vector3d） </span><br><span class=\"line\">//AngleAxisd的底层不直接是Matrix，但由于重载了运算符，因此仍可以当做矩阵运算</span><br></pre></td></tr></table></figure>\n\n<p>注意：AngleAxisd不能用cout输出，以该定义为例，要用rotation_vector.matrix()转换成矩阵形式才能输出，但转换后不再是旋转向量形式，而是3x3的旋转矩阵形式。 </p>\n<p><strong>注意：使用AngleAxisd定义旋转向量时候，C++中M_PI的精度是二十位，并不是真正数学意义上的π \\piπ,因此在计算过程中会引入误差。例子如下：</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AngleAxisd angle_vector = AngleAxisd(M_PI/2,Vector3d(0, 0, 1)); </span><br><span class=\"line\">cout &lt;&lt; angle_vector.matrix() &lt;&lt; endl; </span><br></pre></td></tr></table></figure>\n\n<p>数学理论上所出来的angle_vector对应的矩阵应该为： </p>\n<p>[0 -1 0] </p>\n<p>[1 0 0] </p>\n<p>[0 0 1] </p>\n<p>但程序输出为： </p>\n<p>6.12323e-17 -1 0 </p>\n<p>1 6.12323e-17 0 </p>\n<p>0 0 1 </p>\n<p>将程序中精度由d改成f后，程序输出为： </p>\n<p>-4.37114e-08 -1 0 </p>\n<p>1 -4.37114e-08 0 </p>\n<p>0 0 1 </p>\n<p>其中，本应该矩阵中应该为0的元素出现了一个极小值，而且该极小值会随着精度的变化而变化，不过目前发现的影响只有对0元素的影响，这个极小值可以看成0. </p>\n<h4 id=\"4）欧拉角定义\"><a href=\"#4）欧拉角定义\" class=\"headerlink\" title=\"4）欧拉角定义\"></a>4）欧拉角定义</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vector3d eulerangles(0,0,0); </span><br><span class=\"line\">//使用三维纵向量Vector3d定义</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5）欧氏变换矩阵定义\"><a href=\"#5）欧氏变换矩阵定义\" class=\"headerlink\" title=\"5）欧氏变换矩阵定义\"></a>5）欧氏变换矩阵定义</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Isometry3d T = Isometry3d::Identity(); </span><br><span class=\"line\">//使用Isometry3d定义，虽然叫3d，但实际上是4x4矩阵 </span><br><span class=\"line\">//Isometry3d::Identity()是将欧氏矩阵初始化为单位矩阵 </span><br><span class=\"line\">Isometry3d T(q); </span><br><span class=\"line\">//使用四元数初始化欧氏变换矩阵 </span><br></pre></td></tr></table></figure>\n\n<p>注意：欧氏变换矩阵不能直接用cout输出，以该定义为例，要使用 </p>\n<p>T.matrix()转换为矩阵形式输出，转换后仍为4x4的欧氏变换矩阵 </p>\n<h4 id=\"6）四元数定义\"><a href=\"#6）四元数定义\" class=\"headerlink\" title=\"6）四元数定义\"></a>6）四元数定义</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Quaterniond q(Vector4d(1,2,3,4)); </span><br><span class=\"line\">//使用Vector4d定义，定义格式为（x,y,z,w) </span><br><span class=\"line\">Quaterniond q((1,2,3,4)); </span><br><span class=\"line\">//直接赋值，定义格式为(w,x,y,z) </span><br></pre></td></tr></table></figure>\n\n<p>注意：该定义方法下，Vector中四个元素对应关系为（x,y,z,w)，即最后以为才是四元数的实部 </p>\n<p>注意：四元数不能直接用cout输出，以该定义为例，输出格式为 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; q.coeffs() &lt;&lt; endl;  //输出格式为（x,y,z,w)</span><br></pre></td></tr></table></figure>\n\n<p>注意：四元数在使用前要进行归一化，这样由四元数转化出来的旋转矩阵才满足正交性。归一化方法为： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">q.normalize(); </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、各种变换表达形式之间的转换\"><a href=\"#2、各种变换表达形式之间的转换\" class=\"headerlink\" title=\"2、各种变换表达形式之间的转换\"></a>2、各种变换表达形式之间的转换</h3><h4 id=\"1）旋转向量与旋转矩阵之间的变换\"><a href=\"#1）旋转向量与旋转矩阵之间的变换\" class=\"headerlink\" title=\"1）旋转向量与旋转矩阵之间的变换\"></a>1）旋转向量与旋转矩阵之间的变换</h4><p>显示转换 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rotation_matrix = rotation_vector.toRotationMatrix(); </span><br><span class=\"line\">或 </span><br><span class=\"line\">rotation_matrix = rotation_vector.matrix(); </span><br></pre></td></tr></table></figure>\n\n<p>注意：此处也存在M_PI引入的误差问题，详讲1-3）旋转向量定义。 </p>\n<p>隐式转换（直接赋值） </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rotation_matrix = rotation_vector; </span><br><span class=\"line\">rotation_vector = rotation_matrix; </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2）旋转矩阵与欧拉角的变换\"><a href=\"#2）旋转矩阵与欧拉角的变换\" class=\"headerlink\" title=\"2）旋转矩阵与欧拉角的变换\"></a>2）旋转矩阵与欧拉角的变换</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eulerangles = rotation_matrix.eulerAngles(2,1,0); </span><br><span class=\"line\">//参数（2.1.0）表示这是ZYX顺序，即roll pitch yaw </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3）欧氏变换矩阵按照旋转向量或旋转矩阵旋转\"><a href=\"#3）欧氏变换矩阵按照旋转向量或旋转矩阵旋转\" class=\"headerlink\" title=\"3）欧氏变换矩阵按照旋转向量或旋转矩阵旋转\"></a>3）欧氏变换矩阵按照旋转向量或旋转矩阵旋转</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T.rotate(rotation_matrix);   //在原来T的基础上按照旋转矩阵进行旋转，然后返回T。就是讲旋转矩阵的变换整合到T中 </span><br><span class=\"line\">T.rotate(rotation_vector);   //按照旋转向量进行旋转</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4）欧氏变换矩阵平移\"><a href=\"#4）欧氏变换矩阵平移\" class=\"headerlink\" title=\"4）欧氏变换矩阵平移\"></a>4）欧氏变换矩阵平移</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T.pretranslate(Vector3d(1,3,4));   //按照向量Vector3d(1,3,4)平移</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5）四元数与旋转向量旋转矩阵之间的转换\"><a href=\"#5）四元数与旋转向量旋转矩阵之间的转换\" class=\"headerlink\" title=\"5）四元数与旋转向量旋转矩阵之间的转换\"></a>5）四元数与旋转向量旋转矩阵之间的转换</h4><p>显式转换 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">q = Quaterniond(rotation_vector)</span><br><span class=\"line\">q = Quaterniond(rotation_matrix)</span><br></pre></td></tr></table></figure>\n\n<p>隐式转换 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rotation_vector = q</span><br><span class=\"line\">rotation_matrix = q</span><br><span class=\"line\">q = rotation_matrix</span><br><span class=\"line\">q = rotation_vector</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、坐标变换\"><a href=\"#3、坐标变换\" class=\"headerlink\" title=\"3、坐标变换\"></a>3、坐标变换</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vector3d v(1,0,0); //定义初始坐标v </span><br><span class=\"line\">Vector3d v_rotated； //定义坐标转换后坐标v_rotated</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1）使用旋转矩阵\"><a href=\"#1）使用旋转矩阵\" class=\"headerlink\" title=\"1）使用旋转矩阵\"></a>1）使用旋转矩阵</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v_rotated = rotation_matrix * v </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2）使用旋转向量\"><a href=\"#2）使用旋转向量\" class=\"headerlink\" title=\"2）使用旋转向量\"></a>2）使用旋转向量</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v_rotated = rotation_vector * v </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3）使用变换矩阵\"><a href=\"#3）使用变换矩阵\" class=\"headerlink\" title=\"3）使用变换矩阵\"></a>3）使用变换矩阵</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vector3d v_tranformed = T * v</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4）使用四元数\"><a href=\"#4）使用四元数\" class=\"headerlink\" title=\"4）使用四元数\"></a>4）使用四元数</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v_rotated = q*v</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-7.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Eigen几何模块的引入\"><a href=\"#Eigen几何模块的引入\" class=\"headerlink\" title=\"Eigen几何模块的引入\"></a>Eigen几何模块的引入</h1><h2 id=\"1、在CMakeLists文件中添加\"><a href=\"#1、在CMakeLists文件中添加\" class=\"headerlink\" title=\"1、在CMakeLists文件中添加\"></a>1、在CMakeLists文件中添加</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include_directories(&quot;/usr/include/eigen3&quot;) </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、在main-cpp中添加\"><a href=\"#2、在main-cpp中添加\" class=\"headerlink\" title=\"2、在main.cpp中添加\"></a>2、在main.cpp中添加</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;cmath&gt;             //c++的标准数学函数库，不是Eigen中的，但一般要用到 </span><br><span class=\"line\">#include &lt;Eigen/Core&gt; </span><br><span class=\"line\">#include &lt;Eigen/Geometry&gt; </span><br><span class=\"line\">using namespace Eigen; </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、Eigen几何模块的使用\"><a href=\"#二、Eigen几何模块的使用\" class=\"headerlink\" title=\"二、Eigen几何模块的使用\"></a>二、Eigen几何模块的使用</h2><h3 id=\"1、定义\"><a href=\"#1、定义\" class=\"headerlink\" title=\"1、定义\"></a>1、定义</h3><h4 id=\"1）三维空间坐标定义\"><a href=\"#1）三维空间坐标定义\" class=\"headerlink\" title=\"1）三维空间坐标定义\"></a>1）三维空间坐标定义</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vector3d v(1,0,0); </span><br><span class=\"line\">//使用三维纵向量Vector3d定义 </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2）旋转矩阵定义\"><a href=\"#2）旋转矩阵定义\" class=\"headerlink\" title=\"2）旋转矩阵定义\"></a>2）旋转矩阵定义</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Matrix3d rotation_matrix = Matrix3d::Identity(); </span><br><span class=\"line\">//使用Matrix3d或者Matrix3f定义，Matrix3d::Identity()是三阶单位阵</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3）旋转向量定义\"><a href=\"#3）旋转向量定义\" class=\"headerlink\" title=\"3）旋转向量定义\"></a>3）旋转向量定义</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AngleAxisd rotation_vector(M_PI / 4,Vector3d(0,0,1)); </span><br><span class=\"line\">//沿Z轴旋转45度 </span><br><span class=\"line\">//使用AngleAxisd定义，AngleAxisd（旋转角度，旋转轴单位向量Vector3d） </span><br><span class=\"line\">//AngleAxisd的底层不直接是Matrix，但由于重载了运算符，因此仍可以当做矩阵运算</span><br></pre></td></tr></table></figure>\n\n<p>注意：AngleAxisd不能用cout输出，以该定义为例，要用rotation_vector.matrix()转换成矩阵形式才能输出，但转换后不再是旋转向量形式，而是3x3的旋转矩阵形式。 </p>\n<p><strong>注意：使用AngleAxisd定义旋转向量时候，C++中M_PI的精度是二十位，并不是真正数学意义上的π \\piπ,因此在计算过程中会引入误差。例子如下：</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AngleAxisd angle_vector = AngleAxisd(M_PI/2,Vector3d(0, 0, 1)); </span><br><span class=\"line\">cout &lt;&lt; angle_vector.matrix() &lt;&lt; endl; </span><br></pre></td></tr></table></figure>\n\n<p>数学理论上所出来的angle_vector对应的矩阵应该为： </p>\n<p>[0 -1 0] </p>\n<p>[1 0 0] </p>\n<p>[0 0 1] </p>\n<p>但程序输出为： </p>\n<p>6.12323e-17 -1 0 </p>\n<p>1 6.12323e-17 0 </p>\n<p>0 0 1 </p>\n<p>将程序中精度由d改成f后，程序输出为： </p>\n<p>-4.37114e-08 -1 0 </p>\n<p>1 -4.37114e-08 0 </p>\n<p>0 0 1 </p>\n<p>其中，本应该矩阵中应该为0的元素出现了一个极小值，而且该极小值会随着精度的变化而变化，不过目前发现的影响只有对0元素的影响，这个极小值可以看成0. </p>\n<h4 id=\"4）欧拉角定义\"><a href=\"#4）欧拉角定义\" class=\"headerlink\" title=\"4）欧拉角定义\"></a>4）欧拉角定义</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vector3d eulerangles(0,0,0); </span><br><span class=\"line\">//使用三维纵向量Vector3d定义</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5）欧氏变换矩阵定义\"><a href=\"#5）欧氏变换矩阵定义\" class=\"headerlink\" title=\"5）欧氏变换矩阵定义\"></a>5）欧氏变换矩阵定义</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Isometry3d T = Isometry3d::Identity(); </span><br><span class=\"line\">//使用Isometry3d定义，虽然叫3d，但实际上是4x4矩阵 </span><br><span class=\"line\">//Isometry3d::Identity()是将欧氏矩阵初始化为单位矩阵 </span><br><span class=\"line\">Isometry3d T(q); </span><br><span class=\"line\">//使用四元数初始化欧氏变换矩阵 </span><br></pre></td></tr></table></figure>\n\n<p>注意：欧氏变换矩阵不能直接用cout输出，以该定义为例，要使用 </p>\n<p>T.matrix()转换为矩阵形式输出，转换后仍为4x4的欧氏变换矩阵 </p>\n<h4 id=\"6）四元数定义\"><a href=\"#6）四元数定义\" class=\"headerlink\" title=\"6）四元数定义\"></a>6）四元数定义</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Quaterniond q(Vector4d(1,2,3,4)); </span><br><span class=\"line\">//使用Vector4d定义，定义格式为（x,y,z,w) </span><br><span class=\"line\">Quaterniond q((1,2,3,4)); </span><br><span class=\"line\">//直接赋值，定义格式为(w,x,y,z) </span><br></pre></td></tr></table></figure>\n\n<p>注意：该定义方法下，Vector中四个元素对应关系为（x,y,z,w)，即最后以为才是四元数的实部 </p>\n<p>注意：四元数不能直接用cout输出，以该定义为例，输出格式为 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; q.coeffs() &lt;&lt; endl;  //输出格式为（x,y,z,w)</span><br></pre></td></tr></table></figure>\n\n<p>注意：四元数在使用前要进行归一化，这样由四元数转化出来的旋转矩阵才满足正交性。归一化方法为： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">q.normalize(); </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、各种变换表达形式之间的转换\"><a href=\"#2、各种变换表达形式之间的转换\" class=\"headerlink\" title=\"2、各种变换表达形式之间的转换\"></a>2、各种变换表达形式之间的转换</h3><h4 id=\"1）旋转向量与旋转矩阵之间的变换\"><a href=\"#1）旋转向量与旋转矩阵之间的变换\" class=\"headerlink\" title=\"1）旋转向量与旋转矩阵之间的变换\"></a>1）旋转向量与旋转矩阵之间的变换</h4><p>显示转换 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rotation_matrix = rotation_vector.toRotationMatrix(); </span><br><span class=\"line\">或 </span><br><span class=\"line\">rotation_matrix = rotation_vector.matrix(); </span><br></pre></td></tr></table></figure>\n\n<p>注意：此处也存在M_PI引入的误差问题，详讲1-3）旋转向量定义。 </p>\n<p>隐式转换（直接赋值） </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rotation_matrix = rotation_vector; </span><br><span class=\"line\">rotation_vector = rotation_matrix; </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2）旋转矩阵与欧拉角的变换\"><a href=\"#2）旋转矩阵与欧拉角的变换\" class=\"headerlink\" title=\"2）旋转矩阵与欧拉角的变换\"></a>2）旋转矩阵与欧拉角的变换</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eulerangles = rotation_matrix.eulerAngles(2,1,0); </span><br><span class=\"line\">//参数（2.1.0）表示这是ZYX顺序，即roll pitch yaw </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3）欧氏变换矩阵按照旋转向量或旋转矩阵旋转\"><a href=\"#3）欧氏变换矩阵按照旋转向量或旋转矩阵旋转\" class=\"headerlink\" title=\"3）欧氏变换矩阵按照旋转向量或旋转矩阵旋转\"></a>3）欧氏变换矩阵按照旋转向量或旋转矩阵旋转</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T.rotate(rotation_matrix);   //在原来T的基础上按照旋转矩阵进行旋转，然后返回T。就是讲旋转矩阵的变换整合到T中 </span><br><span class=\"line\">T.rotate(rotation_vector);   //按照旋转向量进行旋转</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4）欧氏变换矩阵平移\"><a href=\"#4）欧氏变换矩阵平移\" class=\"headerlink\" title=\"4）欧氏变换矩阵平移\"></a>4）欧氏变换矩阵平移</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T.pretranslate(Vector3d(1,3,4));   //按照向量Vector3d(1,3,4)平移</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5）四元数与旋转向量旋转矩阵之间的转换\"><a href=\"#5）四元数与旋转向量旋转矩阵之间的转换\" class=\"headerlink\" title=\"5）四元数与旋转向量旋转矩阵之间的转换\"></a>5）四元数与旋转向量旋转矩阵之间的转换</h4><p>显式转换 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">q = Quaterniond(rotation_vector)</span><br><span class=\"line\">q = Quaterniond(rotation_matrix)</span><br></pre></td></tr></table></figure>\n\n<p>隐式转换 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rotation_vector = q</span><br><span class=\"line\">rotation_matrix = q</span><br><span class=\"line\">q = rotation_matrix</span><br><span class=\"line\">q = rotation_vector</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、坐标变换\"><a href=\"#3、坐标变换\" class=\"headerlink\" title=\"3、坐标变换\"></a>3、坐标变换</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vector3d v(1,0,0); //定义初始坐标v </span><br><span class=\"line\">Vector3d v_rotated； //定义坐标转换后坐标v_rotated</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1）使用旋转矩阵\"><a href=\"#1）使用旋转矩阵\" class=\"headerlink\" title=\"1）使用旋转矩阵\"></a>1）使用旋转矩阵</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v_rotated = rotation_matrix * v </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2）使用旋转向量\"><a href=\"#2）使用旋转向量\" class=\"headerlink\" title=\"2）使用旋转向量\"></a>2）使用旋转向量</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v_rotated = rotation_vector * v </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3）使用变换矩阵\"><a href=\"#3）使用变换矩阵\" class=\"headerlink\" title=\"3）使用变换矩阵\"></a>3）使用变换矩阵</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vector3d v_tranformed = T * v</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4）使用四元数\"><a href=\"#4）使用四元数\" class=\"headerlink\" title=\"4）使用四元数\"></a>4）使用四元数</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v_rotated = q*v</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"# C++下const增强\n\n### 全局const间接修改\n\n```c++\nconst int m_a = 100;\t//分配到常量区\nvoid fun()\n{\n\tint * p = (int *)&m_a;\n\t*p = 200;\n}\n```\n\n结论：编译成功，但是运行失败，修改失败\n\n###  局部const间接修改\n\n```c++\nvoid fun()\n{\n\tconst int m_b = 100;\t//分配到栈上\n\tint * p = (int *)&m_b;\n\t*p = 200; \n    cout << m_b << endl;\n}\n```\n\n结论：运行成功，修改失败\n\n### 原因分析：\n\n![c++const修饰的局部变量分配到符号表上](media/c++const%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%88%86%E9%85%8D%E5%88%B0%E7%AC%A6%E5%8F%B7%E8%A1%A8%E4%B8%8A.png)\n\n`因此c++ const可以称为常量`\n\n### 链接属性\n\nconst变量默认是内部链接属性，加extern可以提高作用域\n\n### 内存分配\n\n```c++\nvoid fun()\n{\n\tconst int m_b = 100;\t//分配到栈上\n\tint * p = (int *)&m_b;\n\t*p = 200; \n}\n```\n\n同上分配的临时内存\n\n```c++\nvoid fun()\n{\n\tint a = 10;\n\tconst int m_b = a;\t//分配到栈上\n\tint * p = (int *)&m_b;\n\t*p = 200; \n}\n```\n\n修改成功，因为分配了内存\n\n```c++\nstruct Person\n{\n\tstring m_Name;\n\tint m_Age;\n};\nvoid test03()\n{\n\tconst Person p;\n\t//p.m_Age = 10;      //直接修改失败\n\n\tPerson * pp = (Person *)&p;\n\t(*pp).m_Name = \"Tom\";\n\tpp->m_Age = 10;\n\n\tcout << \"姓名 \" << p.m_Name << \" 年龄\" << p.m_Age << endl;\n}\n```\n\n间接修改成功，分配了内存","source":"_posts/C++/C++下const增强.md","raw":"# C++下const增强\n\n### 全局const间接修改\n\n```c++\nconst int m_a = 100;\t//分配到常量区\nvoid fun()\n{\n\tint * p = (int *)&m_a;\n\t*p = 200;\n}\n```\n\n结论：编译成功，但是运行失败，修改失败\n\n###  局部const间接修改\n\n```c++\nvoid fun()\n{\n\tconst int m_b = 100;\t//分配到栈上\n\tint * p = (int *)&m_b;\n\t*p = 200; \n    cout << m_b << endl;\n}\n```\n\n结论：运行成功，修改失败\n\n### 原因分析：\n\n![c++const修饰的局部变量分配到符号表上](media/c++const%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%88%86%E9%85%8D%E5%88%B0%E7%AC%A6%E5%8F%B7%E8%A1%A8%E4%B8%8A.png)\n\n`因此c++ const可以称为常量`\n\n### 链接属性\n\nconst变量默认是内部链接属性，加extern可以提高作用域\n\n### 内存分配\n\n```c++\nvoid fun()\n{\n\tconst int m_b = 100;\t//分配到栈上\n\tint * p = (int *)&m_b;\n\t*p = 200; \n}\n```\n\n同上分配的临时内存\n\n```c++\nvoid fun()\n{\n\tint a = 10;\n\tconst int m_b = a;\t//分配到栈上\n\tint * p = (int *)&m_b;\n\t*p = 200; \n}\n```\n\n修改成功，因为分配了内存\n\n```c++\nstruct Person\n{\n\tstring m_Name;\n\tint m_Age;\n};\nvoid test03()\n{\n\tconst Person p;\n\t//p.m_Age = 10;      //直接修改失败\n\n\tPerson * pp = (Person *)&p;\n\t(*pp).m_Name = \"Tom\";\n\tpp->m_Age = 10;\n\n\tcout << \"姓名 \" << p.m_Name << \" 年龄\" << p.m_Age << endl;\n}\n```\n\n间接修改成功，分配了内存","slug":"C++/C++下const增强","published":1,"date":"2023-08-24T14:38:18.607Z","updated":"2022-12-30T03:13:44.814Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0t60003dkr7ff1x7whd","content":"<h1 id=\"C-下const增强\"><a href=\"#C-下const增强\" class=\"headerlink\" title=\"C++下const增强\"></a>C++下const增强</h1><h3 id=\"全局const间接修改\"><a href=\"#全局const间接修改\" class=\"headerlink\" title=\"全局const间接修改\"></a>全局const间接修改</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> m_a = <span class=\"number\">100</span>;\t<span class=\"comment\">//分配到常量区</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> * p = (<span class=\"type\">int</span> *)&amp;m_a;</span><br><span class=\"line\">\t*p = <span class=\"number\">200</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结论：编译成功，但是运行失败，修改失败</p>\n<h3 id=\"局部const间接修改\"><a href=\"#局部const间接修改\" class=\"headerlink\" title=\"局部const间接修改\"></a>局部const间接修改</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">int</span> m_b = <span class=\"number\">100</span>;\t<span class=\"comment\">//分配到栈上</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> * p = (<span class=\"type\">int</span> *)&amp;m_b;</span><br><span class=\"line\">\t*p = <span class=\"number\">200</span>; </span><br><span class=\"line\">    cout &lt;&lt; m_b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结论：运行成功，修改失败</p>\n<h3 id=\"原因分析：\"><a href=\"#原因分析：\" class=\"headerlink\" title=\"原因分析：\"></a>原因分析：</h3><p><img src=\"/media/c++const%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%88%86%E9%85%8D%E5%88%B0%E7%AC%A6%E5%8F%B7%E8%A1%A8%E4%B8%8A.png\" alt=\"c++const修饰的局部变量分配到符号表上\"></p>\n<p><code>因此c++ const可以称为常量</code></p>\n<h3 id=\"链接属性\"><a href=\"#链接属性\" class=\"headerlink\" title=\"链接属性\"></a>链接属性</h3><p>const变量默认是内部链接属性，加extern可以提高作用域</p>\n<h3 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">int</span> m_b = <span class=\"number\">100</span>;\t<span class=\"comment\">//分配到栈上</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> * p = (<span class=\"type\">int</span> *)&amp;m_b;</span><br><span class=\"line\">\t*p = <span class=\"number\">200</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同上分配的临时内存</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">int</span> m_b = a;\t<span class=\"comment\">//分配到栈上</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> * p = (<span class=\"type\">int</span> *)&amp;m_b;</span><br><span class=\"line\">\t*p = <span class=\"number\">200</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改成功，因为分配了内存</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstring m_Name;</span><br><span class=\"line\">\t<span class=\"type\">int</span> m_Age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test03</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">const</span> Person p;</span><br><span class=\"line\">\t<span class=\"comment\">//p.m_Age = 10;      //直接修改失败</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tPerson * pp = (Person *)&amp;p;</span><br><span class=\"line\">\t(*pp).m_Name = <span class=\"string\">&quot;Tom&quot;</span>;</span><br><span class=\"line\">\tpp-&gt;m_Age = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;姓名 &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class=\"string\">&quot; 年龄&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>间接修改成功，分配了内存</p>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-5.png","cover_type":"img","excerpt":"","more":"<h1 id=\"C-下const增强\"><a href=\"#C-下const增强\" class=\"headerlink\" title=\"C++下const增强\"></a>C++下const增强</h1><h3 id=\"全局const间接修改\"><a href=\"#全局const间接修改\" class=\"headerlink\" title=\"全局const间接修改\"></a>全局const间接修改</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> m_a = <span class=\"number\">100</span>;\t<span class=\"comment\">//分配到常量区</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> * p = (<span class=\"type\">int</span> *)&amp;m_a;</span><br><span class=\"line\">\t*p = <span class=\"number\">200</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结论：编译成功，但是运行失败，修改失败</p>\n<h3 id=\"局部const间接修改\"><a href=\"#局部const间接修改\" class=\"headerlink\" title=\"局部const间接修改\"></a>局部const间接修改</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">int</span> m_b = <span class=\"number\">100</span>;\t<span class=\"comment\">//分配到栈上</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> * p = (<span class=\"type\">int</span> *)&amp;m_b;</span><br><span class=\"line\">\t*p = <span class=\"number\">200</span>; </span><br><span class=\"line\">    cout &lt;&lt; m_b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结论：运行成功，修改失败</p>\n<h3 id=\"原因分析：\"><a href=\"#原因分析：\" class=\"headerlink\" title=\"原因分析：\"></a>原因分析：</h3><p><img src=\"/media/c++const%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%88%86%E9%85%8D%E5%88%B0%E7%AC%A6%E5%8F%B7%E8%A1%A8%E4%B8%8A.png\" alt=\"c++const修饰的局部变量分配到符号表上\"></p>\n<p><code>因此c++ const可以称为常量</code></p>\n<h3 id=\"链接属性\"><a href=\"#链接属性\" class=\"headerlink\" title=\"链接属性\"></a>链接属性</h3><p>const变量默认是内部链接属性，加extern可以提高作用域</p>\n<h3 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">int</span> m_b = <span class=\"number\">100</span>;\t<span class=\"comment\">//分配到栈上</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> * p = (<span class=\"type\">int</span> *)&amp;m_b;</span><br><span class=\"line\">\t*p = <span class=\"number\">200</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同上分配的临时内存</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">int</span> m_b = a;\t<span class=\"comment\">//分配到栈上</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> * p = (<span class=\"type\">int</span> *)&amp;m_b;</span><br><span class=\"line\">\t*p = <span class=\"number\">200</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改成功，因为分配了内存</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Person</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstring m_Name;</span><br><span class=\"line\">\t<span class=\"type\">int</span> m_Age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test03</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">const</span> Person p;</span><br><span class=\"line\">\t<span class=\"comment\">//p.m_Age = 10;      //直接修改失败</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tPerson * pp = (Person *)&amp;p;</span><br><span class=\"line\">\t(*pp).m_Name = <span class=\"string\">&quot;Tom&quot;</span>;</span><br><span class=\"line\">\tpp-&gt;m_Age = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;姓名 &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class=\"string\">&quot; 年龄&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>间接修改成功，分配了内存</p>\n"},{"title":"C++11:chrono库 (日期和时间库)","date":"2023-08-24T11:00:19.071Z","description":null,"top_img":false,"_content":"\n# C++11:chrono库 (日期和时间库)\n\n> ​\tC++11标准已经支持std::chrono了，但是为了兼容老编译系统现在很多C++库和程序都使用boost::chrono作为时间类库(还有的原因就std::chrono没有收录boost::chrono的所有功能，比如统计CPU使用时间、自定义时间输出格式等)，Boost::Chrono的时间类型分为duration和time_point，也就是时长和时刻两类，很多概念和接口都是围绕这两个维度去定义和实现的。\n\nchrono库主要包含了三种类型:\n时间间隔Duration\n时钟Clocks\n时间点Time point\n\n## **Duration**\n\nduration表示一段时间间隔，用来记录时间长度，可以表示几秒钟、几分钟或者几个小时的时间间隔。\n\n其原型:\n\n```c++\ntemplate<class Rep,class Period = std::ration<1>> class duration;\n```\n\n第一个模板参数Rep是一个数值类型，表明存储所用的数据类型(int、long、double等)；第二个模板参数是一个默认模板参数std::ratio，它的原型是：\n\n```c++\ntemplate<std::intmax_t Num, std::intmax_t Denom = 1> class ratio;\n```\n\n第一个模板参数Rep是一个数值类型，表明存储所用的数据类型(int、long、double等)；第二个模板参数是一个默认模板参数std::ratio，它的原型是：\n\n它表示每个时钟周期的秒数，其中第一个模板参数Num代表分子，Denom代表分母，分母默认为1，ratio代表的是一个分子除以分母的分数值，比如ratio<2>代表一个时钟周期是两秒，ratio<60>代表了一分钟，ratio<60 * 60>代表一个小时，ratio<60 * 60 * 24>代表一天。而ratio<1, 1000>代表的则是1/1000秒即一毫秒，ratio<1, 1000000>代表一微秒，ratio<1, 1000000000>代表一纳秒。\n\n标准库为了方便使用，就定义了一些常用的时间间隔，如时、分、秒、毫秒、微秒和纳秒，在chrono命名空间下，它们的定义如下：\n\n```c++\ntypedef duration <Rep, ratio<3600,1>> hours;\n\ntypedef duration <Rep, ratio<60,1>> minutes;\n\ntypedef duration <Rep, ratio<1,1>> seconds;\n\ntypedef duration <Rep, ratio<1,1000>> milliseconds;\n\ntypedef duration <Rep, ratio<1,1000000>> microseconds;\n\ntypedef duration <Rep, ratio<1,1000000000>> nanoseconds;\n```\n\n```c++\n#include <chrono>\n#include <iostream>\nusing namespace std;\nint main()\n{\n    chrono::hours h(1); // 一小时\n    chrono::milliseconds ms{ 3 }; // 3 毫秒\n    chrono::duration<int, ratio<1000>> ks(3); // 3000 秒\n\n    // chrono::duration<int, ratio<1000>> d3(3.5); // error\n    chrono::duration<double> dd(6.6); // 6.6 秒\n\n    // 使用小数表示时钟周期的次数\n    chrono::duration<double, std::ratio<1, 30>> hz(3.5);\n    return 0;\n}\n\n/*********************************************************************\nh(1) 时钟周期为 1 小时，共有 1 个时钟周期，所以 h 表示的时间间隔为 1 小时\nms(3) 时钟周期为 1 毫秒，共有 3 个时钟周期，所以 ms 表示的时间间隔为 3 毫秒\nks(3) 时钟周期为 1000 秒，一共有三个时钟周期，所以 ks 表示的时间间隔为 3000 秒\nd3(3.5) 时钟周期为 1000 秒，时钟周期数量只能用整形来表示，但是此处指定的是浮点数，因此语法错误\ndd(6.6) 时钟周期为默认的 1 秒，共有 6.6 个时钟周期，所以 dd 表示的时间间隔为 6.6 秒\nhz(3.5) 时钟周期为 1/30 秒，共有 3.5 个时钟周期，所以 hz 表示的时间间隔为 1/30*3.5 秒\nchrono 库中根据 duration 类封装了不同长度的时钟周期（也可以自定义），基于这个时钟周期再进行周期次数的设置就可以得到总的时间间隔了（时钟周期 * 周期次数 = 总的时间间隔）。\n*************************************************************************/\n```\n\nchrono还提供了获取时间间隔的时钟周期个数的方法count()，它的基本用法：\n\n```c++\n#include <chrono>\n#include <iostream>\nint main()\n{\n    std::chrono::milliseconds ms{ 3 }; // 3 毫秒\n    std::chrono::microseconds us = 2 * ms; // 6000 微秒\n    // 时间间隔周期为 1/30 秒\n    std::chrono::duration<double, std::ratio<1, 30>> hz(3.5);\n\n    std::cout << \"3 ms duration has \" << ms.count() << \" ticks\\n\"\n        << \"6000 us duration has \" << us.count() << \" ticks\\n\"\n        << \"3.5 hz duration has \" << hz.count() << \" ticks\\n\";\n    return 0;\n}\n```\n\n```c++\n3 ms duration has 3 ticks\n6000 us duration has 6000 ticks\n3.5 hz duration has 3.5 ticks\n\nms 时间单位为毫秒，初始化操作 ms{3} 表示时间间隔为 3 毫秒，一共有 3 个时间周期，每个周期为 1 毫秒\nus 时间单位为微秒，初始化操作 2*ms 表示时间间隔为 6000 微秒，一共有 6000 个时间周期，每个周期为 1 微秒\nhz 时间单位为秒，初始化操作 hz(3.5) 表示时间间隔为 1/30*3.5 秒，一共有 3.5 个时间周期，每个周期为 1/30 秒\n```\n\n通过定义这些常用的时间间隔类型，我们能方便的使用它们，比如线程的休眠:\n\n```c++\nstd::this_thread::sleep_for(std::chrono::seconds(3)); //休眠三秒\n\nstd::this_thread::sleep_for(std::chrono:: milliseconds (100)); //休眠100毫秒\n```\n\n由于在 duration 类内部做了操作符重载，因此时间间隔之间可以直接进行算术运算，比如我们要计算两个时间间隔的差值，就可以在代码中做如下处理：\n\n```c++\n#include <iostream>\n#include <chrono>\nusing namespace boost;\n\nint main()\n{\n    chrono::minutes t1(10);\n    chrono::seconds t2(60);\n    chrono::seconds t3 = t1 - t2;\n    cout << t3.count() << \" second\" << endl;\n    return 0;\n}\n```\n\n```c++\n540 second\n```\n\n在上面的测试程序中，t1 代表 10 分钟，t2 代表 60 秒，t3 是 t1 减去 t2，也就是 60*10-60=540，这个 540 表示的时钟周期，每个时钟周期是 1 秒，因此两个时间间隔之间的差值为 540 秒。\n\n注意事项：duration 的加减运算有一定的规则，当两个 duration 时钟周期不相同的时候，会先统一成一种时钟，然后再进行算术运算.\n\n因为类型表示的维度不一，粗粒度的时长肯定能用细粒度的类型表示，反之则可能丢失精度，所以需要使用`chrono::duration_cast()`函数做显式的转换。将当前的时钟周期转换为其它的时钟周期，比如我可以把秒的时钟周期转换为分钟的时钟周期，然后通过count来获取转换后的分钟时间间隔：\n\n```c++\ncout << chrono::duration_cast<chrono::minutes>( t3 ).count() <<” minutes”<< endl;\n\n将会输出:\n9 minutes\n```\n\n## **Time point**\n\ntime_point表示一个时间点，用来获取1970.1.1以来的秒数和当前的时间, 可以做一些时间的比较和算术运算，可以和ctime库结合起来显示时间。time_point必须要clock来计时，\n\ntime_point有一个函数`time_from_eproch()`用来获得1970年1月1日到time_point时间经过的duration。\n\n有一个`chrono::time_point_cast`转换函数，可以显式从高粒度向低粒度对time_point进行转换。\n\n下面的例子计算当前时间距离1970年1月1日有多少天：\n\n```c++\n#include <iostream>\n#include <ratio>\n#include <chrono>\n\nint main ()\n{\n  using namespace std::chrono;\n  typedef duration<int,std::ratio<60*60*24>> days_type;\n  time_point<system_clock,days_type> today = time_point_cast<days_type>(system_clock::now());\n  std::cout << today.time_since_epoch().count() << \" days since epoch\" << std::endl;\n\n  return 0;\n}\n```\n\ntime_point还支持一些算术元算，比如两个time_point的差值时钟周期数，还可以和duration相加减。下面的例子输出前一天和后一天的日期：\n\n```c++\n#include <iostream>\n#include <iomanip>\n#include <ctime>\n#include <chrono>\n\nint main()\n{\n    using namespace std::chrono;\n    system_clock::time_point now = system_clock::now();\n    std::time_t last = system_clock::to_time_t(now - std::chrono::hours(24));\n\n　　std::time_t next= system_clock::to_time_t(now - std::chrono::hours(24));\n\n    std::cout << \"One day ago, the time was \"<< std::put_time(std::localtime(&last), \"%F %T\") << '\\n';\n\n　　std::cout << \"Next day, the time was \"<< std::put_time(std::localtime(&next), \"%F %T\") << '\\n';\n\n}\n\n输出：\nOne day ago, the time was 2014-3-2622:38:27\nNext day, the time was 2014-3-2822:38:27\n```\n\n## **Clocks**\n\nclock是Chrono中的重要概念，而且这些clock都包含一个`now()`的成员函数，用于返回当前的time_point。Boost.Chrono包含的clock类型有：\n\n　　(1) `chrono::system_clock` 代表系统时间，比如电脑上显示的当前时间，其特点是这个时间可以被用户手动设置更新，所以这个时钟是可以和外部时钟源同步的。\n\n　　(2) `chrono::steady_clock` 其特点是时间是单调增长的，后一个时刻访问得到的时间点肯定比之前时刻得到的时间点要晚，即使我们手动将系统时间向前调整了也不会改变这个时钟稳步向前推行累计，其也被称为monotonic time，该时钟是均匀增长且不能被调整，其特性对于很多不允许时间错乱的系统是十分重要的。`chrono::steady_clock`通常是基于系统启动时间来计时的，而且常常用来进行耗时、等待等工作使用。**steady_clock可以获取稳定可靠的时间间隔，后一次调用now()的值和前一次的差值是不因为修改了系统时间而改变，它保证了稳定的时间间隔。它的用法和system用法一样。**\n\n　　(3) `chrono::high_resolution_clock `依赖于系统实现，通常是上面两种时钟的某个宏定义，取决于哪个时钟源更为的精确，所以其输出也决定于取决于上面哪个clock来实现的。\n\n　　(4) `chrono::process_real_cpu_clock `表示自进程启动以来使用的CPU时间，而这个数据也可以通过使用std::clock()来获得。`chrono::process_user_cpu_clock`、`boost::chrono::process_system_cpu_clock`表示自进程启动以来，在用户态、内核态所花费的时间，而所有的这些事件可以通过`chrono::process_cpu_clock`来获得，他返回上面所有时间组成的一个tuple结构。\n\n　　(5) `chrono::thread_clock` 返回基于线程统计的花费时间，而且不区分用户态、内核态的时间。\n\n在这些时钟类的内部有 time_point、duration、Rep、Period 等信息，基于这些信息来获取当前时间。\n\n可以通过now()来获取当前时间点：\n\n```c++\n#include <iostream>\n#include <chrono>\n\nint main()\n{\nstd::chrono::steady_clock::time_point t1 = std::chrono::system_clock::now();\n\nstd::cout << \"Hello World\\n\";\nstd::chrono::steady_clock::time_point t2 = std::chrono:: system_clock::now();\n\nstd::cout << (t2-t1).count()<<” tick count”<<endl;\n}\n\n输出：\nHello World\n20801tick count\n```\n\n通过时钟获取两个时间点之相差多少个时钟周期，我们可以通过duration_cast将其转换为其它时钟周期的duration：\n\n```c++\ncout << std::chrono::duration_cast<std::chrono::microseconds>( t2-t1 ).count() <<” microseconds”<< endl;\n\n输出：\n20 microseconds\n```\n\n还可以实现 `time_t` 和 `time_point` 之间的相互转换。\n\n```c++\n//system_clock的to_time_t方法可以将一个time_point转换为ctime：\nstd::time_t now_c = std::chrono::system_clock::to_time_t(time_point);\n//而from_time_t方法则是相反的，它将ctime转换为time_point。\n```\n\n```c++\n#include <chrono>\n#include <iostream>\nusing namespace std;\nusing namespace std::chrono;\nint main()\n{\n    // 新纪元1970.1.1时间\n    system_clock::time_point epoch;\n\n    duration<int, ratio<60 * 60 * 24>> day(1);\n    // 新纪元1970.1.1时间 + 1天\n    system_clock::time_point ppt(day);\n\n    using dday = duration<int, ratio<60 * 60 * 24>>;\n    // 新纪元1970.1.1时间 + 10天\n    time_point<system_clock, dday> t(dday(10));\n\n    // 系统当前时间\n    system_clock::time_point today = system_clock::now();\n\n    // 转换为time_t时间类型\n    time_t tm = system_clock::to_time_t(today);\n    cout << \"今天的日期是: \" << ctime(&tm);\n\n    time_t tm1 = system_clock::to_time_t(today + day);\n    cout << \"明天的日期是: \" << ctime(&tm1);\n\n    time_t tm2 = system_clock::to_time_t(epoch);\n    cout << \"新纪元时间: \" << ctime(&tm2);\n\n    time_t tm3 = system_clock::to_time_t(ppt);\n    cout << \"新纪元时间+1天: \" << ctime(&tm3);\n\n    time_t tm4 = system_clock::to_time_t(t);\n    cout << \"新纪元时间+10天: \" << ctime(&tm4);\n    return 0;\n}\n```\n\n```c++\n今天的日期是: Thu Apr 8 11:09:49 2021\n明天的日期是: Fri Apr 9 11:09:49 2021\n新纪元时间: Thu Jan 1 08:00:00 1970\n新纪元时间+1天: Fri Jan 2 08:00:00 1970\n新纪元时间+10天: Sun Jan 11 08:00:00 1970\n```\n\n### 参考链接\n\nhttps://blog.csdn.net/weixin_42907473/article/details/90278426\n\nhttps://www.cnblogs.com/Galesaur-wcy/p/15380832.html\n\nhttps://www.jb51.net/article/122979.htm","source":"_posts/C++/C++11chrono库.md","raw":"---\ntitle: C++11:chrono库 (日期和时间库)\ndate:\ntags: \n- C++\ncategories:\n- C++\ndescription:\ntop_img: false\n---\n\n# C++11:chrono库 (日期和时间库)\n\n> ​\tC++11标准已经支持std::chrono了，但是为了兼容老编译系统现在很多C++库和程序都使用boost::chrono作为时间类库(还有的原因就std::chrono没有收录boost::chrono的所有功能，比如统计CPU使用时间、自定义时间输出格式等)，Boost::Chrono的时间类型分为duration和time_point，也就是时长和时刻两类，很多概念和接口都是围绕这两个维度去定义和实现的。\n\nchrono库主要包含了三种类型:\n时间间隔Duration\n时钟Clocks\n时间点Time point\n\n## **Duration**\n\nduration表示一段时间间隔，用来记录时间长度，可以表示几秒钟、几分钟或者几个小时的时间间隔。\n\n其原型:\n\n```c++\ntemplate<class Rep,class Period = std::ration<1>> class duration;\n```\n\n第一个模板参数Rep是一个数值类型，表明存储所用的数据类型(int、long、double等)；第二个模板参数是一个默认模板参数std::ratio，它的原型是：\n\n```c++\ntemplate<std::intmax_t Num, std::intmax_t Denom = 1> class ratio;\n```\n\n第一个模板参数Rep是一个数值类型，表明存储所用的数据类型(int、long、double等)；第二个模板参数是一个默认模板参数std::ratio，它的原型是：\n\n它表示每个时钟周期的秒数，其中第一个模板参数Num代表分子，Denom代表分母，分母默认为1，ratio代表的是一个分子除以分母的分数值，比如ratio<2>代表一个时钟周期是两秒，ratio<60>代表了一分钟，ratio<60 * 60>代表一个小时，ratio<60 * 60 * 24>代表一天。而ratio<1, 1000>代表的则是1/1000秒即一毫秒，ratio<1, 1000000>代表一微秒，ratio<1, 1000000000>代表一纳秒。\n\n标准库为了方便使用，就定义了一些常用的时间间隔，如时、分、秒、毫秒、微秒和纳秒，在chrono命名空间下，它们的定义如下：\n\n```c++\ntypedef duration <Rep, ratio<3600,1>> hours;\n\ntypedef duration <Rep, ratio<60,1>> minutes;\n\ntypedef duration <Rep, ratio<1,1>> seconds;\n\ntypedef duration <Rep, ratio<1,1000>> milliseconds;\n\ntypedef duration <Rep, ratio<1,1000000>> microseconds;\n\ntypedef duration <Rep, ratio<1,1000000000>> nanoseconds;\n```\n\n```c++\n#include <chrono>\n#include <iostream>\nusing namespace std;\nint main()\n{\n    chrono::hours h(1); // 一小时\n    chrono::milliseconds ms{ 3 }; // 3 毫秒\n    chrono::duration<int, ratio<1000>> ks(3); // 3000 秒\n\n    // chrono::duration<int, ratio<1000>> d3(3.5); // error\n    chrono::duration<double> dd(6.6); // 6.6 秒\n\n    // 使用小数表示时钟周期的次数\n    chrono::duration<double, std::ratio<1, 30>> hz(3.5);\n    return 0;\n}\n\n/*********************************************************************\nh(1) 时钟周期为 1 小时，共有 1 个时钟周期，所以 h 表示的时间间隔为 1 小时\nms(3) 时钟周期为 1 毫秒，共有 3 个时钟周期，所以 ms 表示的时间间隔为 3 毫秒\nks(3) 时钟周期为 1000 秒，一共有三个时钟周期，所以 ks 表示的时间间隔为 3000 秒\nd3(3.5) 时钟周期为 1000 秒，时钟周期数量只能用整形来表示，但是此处指定的是浮点数，因此语法错误\ndd(6.6) 时钟周期为默认的 1 秒，共有 6.6 个时钟周期，所以 dd 表示的时间间隔为 6.6 秒\nhz(3.5) 时钟周期为 1/30 秒，共有 3.5 个时钟周期，所以 hz 表示的时间间隔为 1/30*3.5 秒\nchrono 库中根据 duration 类封装了不同长度的时钟周期（也可以自定义），基于这个时钟周期再进行周期次数的设置就可以得到总的时间间隔了（时钟周期 * 周期次数 = 总的时间间隔）。\n*************************************************************************/\n```\n\nchrono还提供了获取时间间隔的时钟周期个数的方法count()，它的基本用法：\n\n```c++\n#include <chrono>\n#include <iostream>\nint main()\n{\n    std::chrono::milliseconds ms{ 3 }; // 3 毫秒\n    std::chrono::microseconds us = 2 * ms; // 6000 微秒\n    // 时间间隔周期为 1/30 秒\n    std::chrono::duration<double, std::ratio<1, 30>> hz(3.5);\n\n    std::cout << \"3 ms duration has \" << ms.count() << \" ticks\\n\"\n        << \"6000 us duration has \" << us.count() << \" ticks\\n\"\n        << \"3.5 hz duration has \" << hz.count() << \" ticks\\n\";\n    return 0;\n}\n```\n\n```c++\n3 ms duration has 3 ticks\n6000 us duration has 6000 ticks\n3.5 hz duration has 3.5 ticks\n\nms 时间单位为毫秒，初始化操作 ms{3} 表示时间间隔为 3 毫秒，一共有 3 个时间周期，每个周期为 1 毫秒\nus 时间单位为微秒，初始化操作 2*ms 表示时间间隔为 6000 微秒，一共有 6000 个时间周期，每个周期为 1 微秒\nhz 时间单位为秒，初始化操作 hz(3.5) 表示时间间隔为 1/30*3.5 秒，一共有 3.5 个时间周期，每个周期为 1/30 秒\n```\n\n通过定义这些常用的时间间隔类型，我们能方便的使用它们，比如线程的休眠:\n\n```c++\nstd::this_thread::sleep_for(std::chrono::seconds(3)); //休眠三秒\n\nstd::this_thread::sleep_for(std::chrono:: milliseconds (100)); //休眠100毫秒\n```\n\n由于在 duration 类内部做了操作符重载，因此时间间隔之间可以直接进行算术运算，比如我们要计算两个时间间隔的差值，就可以在代码中做如下处理：\n\n```c++\n#include <iostream>\n#include <chrono>\nusing namespace boost;\n\nint main()\n{\n    chrono::minutes t1(10);\n    chrono::seconds t2(60);\n    chrono::seconds t3 = t1 - t2;\n    cout << t3.count() << \" second\" << endl;\n    return 0;\n}\n```\n\n```c++\n540 second\n```\n\n在上面的测试程序中，t1 代表 10 分钟，t2 代表 60 秒，t3 是 t1 减去 t2，也就是 60*10-60=540，这个 540 表示的时钟周期，每个时钟周期是 1 秒，因此两个时间间隔之间的差值为 540 秒。\n\n注意事项：duration 的加减运算有一定的规则，当两个 duration 时钟周期不相同的时候，会先统一成一种时钟，然后再进行算术运算.\n\n因为类型表示的维度不一，粗粒度的时长肯定能用细粒度的类型表示，反之则可能丢失精度，所以需要使用`chrono::duration_cast()`函数做显式的转换。将当前的时钟周期转换为其它的时钟周期，比如我可以把秒的时钟周期转换为分钟的时钟周期，然后通过count来获取转换后的分钟时间间隔：\n\n```c++\ncout << chrono::duration_cast<chrono::minutes>( t3 ).count() <<” minutes”<< endl;\n\n将会输出:\n9 minutes\n```\n\n## **Time point**\n\ntime_point表示一个时间点，用来获取1970.1.1以来的秒数和当前的时间, 可以做一些时间的比较和算术运算，可以和ctime库结合起来显示时间。time_point必须要clock来计时，\n\ntime_point有一个函数`time_from_eproch()`用来获得1970年1月1日到time_point时间经过的duration。\n\n有一个`chrono::time_point_cast`转换函数，可以显式从高粒度向低粒度对time_point进行转换。\n\n下面的例子计算当前时间距离1970年1月1日有多少天：\n\n```c++\n#include <iostream>\n#include <ratio>\n#include <chrono>\n\nint main ()\n{\n  using namespace std::chrono;\n  typedef duration<int,std::ratio<60*60*24>> days_type;\n  time_point<system_clock,days_type> today = time_point_cast<days_type>(system_clock::now());\n  std::cout << today.time_since_epoch().count() << \" days since epoch\" << std::endl;\n\n  return 0;\n}\n```\n\ntime_point还支持一些算术元算，比如两个time_point的差值时钟周期数，还可以和duration相加减。下面的例子输出前一天和后一天的日期：\n\n```c++\n#include <iostream>\n#include <iomanip>\n#include <ctime>\n#include <chrono>\n\nint main()\n{\n    using namespace std::chrono;\n    system_clock::time_point now = system_clock::now();\n    std::time_t last = system_clock::to_time_t(now - std::chrono::hours(24));\n\n　　std::time_t next= system_clock::to_time_t(now - std::chrono::hours(24));\n\n    std::cout << \"One day ago, the time was \"<< std::put_time(std::localtime(&last), \"%F %T\") << '\\n';\n\n　　std::cout << \"Next day, the time was \"<< std::put_time(std::localtime(&next), \"%F %T\") << '\\n';\n\n}\n\n输出：\nOne day ago, the time was 2014-3-2622:38:27\nNext day, the time was 2014-3-2822:38:27\n```\n\n## **Clocks**\n\nclock是Chrono中的重要概念，而且这些clock都包含一个`now()`的成员函数，用于返回当前的time_point。Boost.Chrono包含的clock类型有：\n\n　　(1) `chrono::system_clock` 代表系统时间，比如电脑上显示的当前时间，其特点是这个时间可以被用户手动设置更新，所以这个时钟是可以和外部时钟源同步的。\n\n　　(2) `chrono::steady_clock` 其特点是时间是单调增长的，后一个时刻访问得到的时间点肯定比之前时刻得到的时间点要晚，即使我们手动将系统时间向前调整了也不会改变这个时钟稳步向前推行累计，其也被称为monotonic time，该时钟是均匀增长且不能被调整，其特性对于很多不允许时间错乱的系统是十分重要的。`chrono::steady_clock`通常是基于系统启动时间来计时的，而且常常用来进行耗时、等待等工作使用。**steady_clock可以获取稳定可靠的时间间隔，后一次调用now()的值和前一次的差值是不因为修改了系统时间而改变，它保证了稳定的时间间隔。它的用法和system用法一样。**\n\n　　(3) `chrono::high_resolution_clock `依赖于系统实现，通常是上面两种时钟的某个宏定义，取决于哪个时钟源更为的精确，所以其输出也决定于取决于上面哪个clock来实现的。\n\n　　(4) `chrono::process_real_cpu_clock `表示自进程启动以来使用的CPU时间，而这个数据也可以通过使用std::clock()来获得。`chrono::process_user_cpu_clock`、`boost::chrono::process_system_cpu_clock`表示自进程启动以来，在用户态、内核态所花费的时间，而所有的这些事件可以通过`chrono::process_cpu_clock`来获得，他返回上面所有时间组成的一个tuple结构。\n\n　　(5) `chrono::thread_clock` 返回基于线程统计的花费时间，而且不区分用户态、内核态的时间。\n\n在这些时钟类的内部有 time_point、duration、Rep、Period 等信息，基于这些信息来获取当前时间。\n\n可以通过now()来获取当前时间点：\n\n```c++\n#include <iostream>\n#include <chrono>\n\nint main()\n{\nstd::chrono::steady_clock::time_point t1 = std::chrono::system_clock::now();\n\nstd::cout << \"Hello World\\n\";\nstd::chrono::steady_clock::time_point t2 = std::chrono:: system_clock::now();\n\nstd::cout << (t2-t1).count()<<” tick count”<<endl;\n}\n\n输出：\nHello World\n20801tick count\n```\n\n通过时钟获取两个时间点之相差多少个时钟周期，我们可以通过duration_cast将其转换为其它时钟周期的duration：\n\n```c++\ncout << std::chrono::duration_cast<std::chrono::microseconds>( t2-t1 ).count() <<” microseconds”<< endl;\n\n输出：\n20 microseconds\n```\n\n还可以实现 `time_t` 和 `time_point` 之间的相互转换。\n\n```c++\n//system_clock的to_time_t方法可以将一个time_point转换为ctime：\nstd::time_t now_c = std::chrono::system_clock::to_time_t(time_point);\n//而from_time_t方法则是相反的，它将ctime转换为time_point。\n```\n\n```c++\n#include <chrono>\n#include <iostream>\nusing namespace std;\nusing namespace std::chrono;\nint main()\n{\n    // 新纪元1970.1.1时间\n    system_clock::time_point epoch;\n\n    duration<int, ratio<60 * 60 * 24>> day(1);\n    // 新纪元1970.1.1时间 + 1天\n    system_clock::time_point ppt(day);\n\n    using dday = duration<int, ratio<60 * 60 * 24>>;\n    // 新纪元1970.1.1时间 + 10天\n    time_point<system_clock, dday> t(dday(10));\n\n    // 系统当前时间\n    system_clock::time_point today = system_clock::now();\n\n    // 转换为time_t时间类型\n    time_t tm = system_clock::to_time_t(today);\n    cout << \"今天的日期是: \" << ctime(&tm);\n\n    time_t tm1 = system_clock::to_time_t(today + day);\n    cout << \"明天的日期是: \" << ctime(&tm1);\n\n    time_t tm2 = system_clock::to_time_t(epoch);\n    cout << \"新纪元时间: \" << ctime(&tm2);\n\n    time_t tm3 = system_clock::to_time_t(ppt);\n    cout << \"新纪元时间+1天: \" << ctime(&tm3);\n\n    time_t tm4 = system_clock::to_time_t(t);\n    cout << \"新纪元时间+10天: \" << ctime(&tm4);\n    return 0;\n}\n```\n\n```c++\n今天的日期是: Thu Apr 8 11:09:49 2021\n明天的日期是: Fri Apr 9 11:09:49 2021\n新纪元时间: Thu Jan 1 08:00:00 1970\n新纪元时间+1天: Fri Jan 2 08:00:00 1970\n新纪元时间+10天: Sun Jan 11 08:00:00 1970\n```\n\n### 参考链接\n\nhttps://blog.csdn.net/weixin_42907473/article/details/90278426\n\nhttps://www.cnblogs.com/Galesaur-wcy/p/15380832.html\n\nhttps://www.jb51.net/article/122979.htm","slug":"C++/C++11chrono库","published":1,"updated":"2023-08-24T15:44:37.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0t70005dkr76miz71pm","content":"<h1 id=\"C-11-chrono库-日期和时间库\"><a href=\"#C-11-chrono库-日期和时间库\" class=\"headerlink\" title=\"C++11:chrono库 (日期和时间库)\"></a>C++11:chrono库 (日期和时间库)</h1><blockquote>\n<p>​\tC++11标准已经支持std::chrono了，但是为了兼容老编译系统现在很多C++库和程序都使用boost::chrono作为时间类库(还有的原因就std::chrono没有收录boost::chrono的所有功能，比如统计CPU使用时间、自定义时间输出格式等)，Boost::Chrono的时间类型分为duration和time_point，也就是时长和时刻两类，很多概念和接口都是围绕这两个维度去定义和实现的。</p>\n</blockquote>\n<p>chrono库主要包含了三种类型:<br>时间间隔Duration<br>时钟Clocks<br>时间点Time point</p>\n<h2 id=\"Duration\"><a href=\"#Duration\" class=\"headerlink\" title=\"Duration\"></a><strong>Duration</strong></h2><p>duration表示一段时间间隔，用来记录时间长度，可以表示几秒钟、几分钟或者几个小时的时间间隔。</p>\n<p>其原型:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Rep</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Period</span> = std::ration&lt;<span class=\"number\">1</span>&gt;&gt; <span class=\"keyword\">class</span> duration;</span><br></pre></td></tr></table></figure>\n\n<p>第一个模板参数Rep是一个数值类型，表明存储所用的数据类型(int、long、double等)；第二个模板参数是一个默认模板参数std::ratio，它的原型是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;std::<span class=\"type\">intmax_t</span> Num, std::<span class=\"type\">intmax_t</span> Denom = <span class=\"number\">1</span>&gt; <span class=\"keyword\">class</span> ratio;</span><br></pre></td></tr></table></figure>\n\n<p>第一个模板参数Rep是一个数值类型，表明存储所用的数据类型(int、long、double等)；第二个模板参数是一个默认模板参数std::ratio，它的原型是：</p>\n<p>它表示每个时钟周期的秒数，其中第一个模板参数Num代表分子，Denom代表分母，分母默认为1，ratio代表的是一个分子除以分母的分数值，比如ratio&lt;2&gt;代表一个时钟周期是两秒，ratio&lt;60&gt;代表了一分钟，ratio&lt;60 * 60&gt;代表一个小时，ratio&lt;60 * 60 * 24&gt;代表一天。而ratio&lt;1, 1000&gt;代表的则是1&#x2F;1000秒即一毫秒，ratio&lt;1, 1000000&gt;代表一微秒，ratio&lt;1, 1000000000&gt;代表一纳秒。</p>\n<p>标准库为了方便使用，就定义了一些常用的时间间隔，如时、分、秒、毫秒、微秒和纳秒，在chrono命名空间下，它们的定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> duration &lt;Rep, ratio&lt;<span class=\"number\">3600</span>,<span class=\"number\">1</span>&gt;&gt; hours;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> duration &lt;Rep, ratio&lt;<span class=\"number\">60</span>,<span class=\"number\">1</span>&gt;&gt; minutes;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> duration &lt;Rep, ratio&lt;<span class=\"number\">1</span>,<span class=\"number\">1</span>&gt;&gt; seconds;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> duration &lt;Rep, ratio&lt;<span class=\"number\">1</span>,<span class=\"number\">1000</span>&gt;&gt; milliseconds;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> duration &lt;Rep, ratio&lt;<span class=\"number\">1</span>,<span class=\"number\">1000000</span>&gt;&gt; microseconds;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> duration &lt;Rep, ratio&lt;<span class=\"number\">1</span>,<span class=\"number\">1000000000</span>&gt;&gt; nanoseconds;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">chrono::hours <span class=\"title\">h</span><span class=\"params\">(<span class=\"number\">1</span>)</span></span>; <span class=\"comment\">// 一小时</span></span><br><span class=\"line\">    chrono::milliseconds ms&#123; <span class=\"number\">3</span> &#125;; <span class=\"comment\">// 3 毫秒</span></span><br><span class=\"line\">    chrono::duration&lt;<span class=\"type\">int</span>, ratio&lt;<span class=\"number\">1000</span>&gt;&gt; <span class=\"built_in\">ks</span>(<span class=\"number\">3</span>); <span class=\"comment\">// 3000 秒</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// chrono::duration&lt;int, ratio&lt;1000&gt;&gt; d3(3.5); // error</span></span><br><span class=\"line\">    <span class=\"function\">chrono::duration&lt;<span class=\"type\">double</span>&gt; <span class=\"title\">dd</span><span class=\"params\">(<span class=\"number\">6.6</span>)</span></span>; <span class=\"comment\">// 6.6 秒</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用小数表示时钟周期的次数</span></span><br><span class=\"line\">    chrono::duration&lt;<span class=\"type\">double</span>, std::ratio&lt;<span class=\"number\">1</span>, <span class=\"number\">30</span>&gt;&gt; <span class=\"built_in\">hz</span>(<span class=\"number\">3.5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*********************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">h(1) 时钟周期为 1 小时，共有 1 个时钟周期，所以 h 表示的时间间隔为 1 小时</span></span><br><span class=\"line\"><span class=\"comment\">ms(3) 时钟周期为 1 毫秒，共有 3 个时钟周期，所以 ms 表示的时间间隔为 3 毫秒</span></span><br><span class=\"line\"><span class=\"comment\">ks(3) 时钟周期为 1000 秒，一共有三个时钟周期，所以 ks 表示的时间间隔为 3000 秒</span></span><br><span class=\"line\"><span class=\"comment\">d3(3.5) 时钟周期为 1000 秒，时钟周期数量只能用整形来表示，但是此处指定的是浮点数，因此语法错误</span></span><br><span class=\"line\"><span class=\"comment\">dd(6.6) 时钟周期为默认的 1 秒，共有 6.6 个时钟周期，所以 dd 表示的时间间隔为 6.6 秒</span></span><br><span class=\"line\"><span class=\"comment\">hz(3.5) 时钟周期为 1/30 秒，共有 3.5 个时钟周期，所以 hz 表示的时间间隔为 1/30*3.5 秒</span></span><br><span class=\"line\"><span class=\"comment\">chrono 库中根据 duration 类封装了不同长度的时钟周期（也可以自定义），基于这个时钟周期再进行周期次数的设置就可以得到总的时间间隔了（时钟周期 * 周期次数 = 总的时间间隔）。</span></span><br><span class=\"line\"><span class=\"comment\">*************************************************************************/</span></span><br></pre></td></tr></table></figure>\n\n<p>chrono还提供了获取时间间隔的时钟周期个数的方法count()，它的基本用法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::chrono::milliseconds ms&#123; <span class=\"number\">3</span> &#125;; <span class=\"comment\">// 3 毫秒</span></span><br><span class=\"line\">    std::chrono::microseconds us = <span class=\"number\">2</span> * ms; <span class=\"comment\">// 6000 微秒</span></span><br><span class=\"line\">    <span class=\"comment\">// 时间间隔周期为 1/30 秒</span></span><br><span class=\"line\">    std::chrono::duration&lt;<span class=\"type\">double</span>, std::ratio&lt;<span class=\"number\">1</span>, <span class=\"number\">30</span>&gt;&gt; <span class=\"built_in\">hz</span>(<span class=\"number\">3.5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;3 ms duration has &quot;</span> &lt;&lt; ms.<span class=\"built_in\">count</span>() &lt;&lt; <span class=\"string\">&quot; ticks\\n&quot;</span></span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">&quot;6000 us duration has &quot;</span> &lt;&lt; us.<span class=\"built_in\">count</span>() &lt;&lt; <span class=\"string\">&quot; ticks\\n&quot;</span></span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">&quot;3.5 hz duration has &quot;</span> &lt;&lt; hz.<span class=\"built_in\">count</span>() &lt;&lt; <span class=\"string\">&quot; ticks\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span> ms duration has <span class=\"number\">3</span> ticks</span><br><span class=\"line\"><span class=\"number\">6000</span> us duration has <span class=\"number\">6000</span> ticks</span><br><span class=\"line\"><span class=\"number\">3.5</span> hz duration has <span class=\"number\">3.5</span> ticks</span><br><span class=\"line\"></span><br><span class=\"line\">ms 时间单位为毫秒，初始化操作 ms&#123;<span class=\"number\">3</span>&#125; 表示时间间隔为 <span class=\"number\">3</span> 毫秒，一共有 <span class=\"number\">3</span> 个时间周期，每个周期为 <span class=\"number\">1</span> 毫秒</span><br><span class=\"line\">us 时间单位为微秒，初始化操作 <span class=\"number\">2</span>*ms 表示时间间隔为 <span class=\"number\">6000</span> 微秒，一共有 <span class=\"number\">6000</span> 个时间周期，每个周期为 <span class=\"number\">1</span> 微秒</span><br><span class=\"line\">hz 时间单位为秒，初始化操作 <span class=\"built_in\">hz</span>(<span class=\"number\">3.5</span>) 表示时间间隔为 <span class=\"number\">1</span>/<span class=\"number\">30</span>*<span class=\"number\">3.5</span> 秒，一共有 <span class=\"number\">3.5</span> 个时间周期，每个周期为 <span class=\"number\">1</span>/<span class=\"number\">30</span> 秒</span><br></pre></td></tr></table></figure>\n\n<p>通过定义这些常用的时间间隔类型，我们能方便的使用它们，比如线程的休眠:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::this_thread::<span class=\"built_in\">sleep_for</span>(std::chrono::<span class=\"built_in\">seconds</span>(<span class=\"number\">3</span>)); <span class=\"comment\">//休眠三秒</span></span><br><span class=\"line\"></span><br><span class=\"line\">std::this_thread::<span class=\"built_in\">sleep_for</span>(std::chrono:: <span class=\"built_in\">milliseconds</span> (<span class=\"number\">100</span>)); <span class=\"comment\">//休眠100毫秒</span></span><br></pre></td></tr></table></figure>\n\n<p>由于在 duration 类内部做了操作符重载，因此时间间隔之间可以直接进行算术运算，比如我们要计算两个时间间隔的差值，就可以在代码中做如下处理：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> boost;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">chrono::minutes <span class=\"title\">t1</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">chrono::seconds <span class=\"title\">t2</span><span class=\"params\">(<span class=\"number\">60</span>)</span></span>;</span><br><span class=\"line\">    chrono::seconds t3 = t1 - t2;</span><br><span class=\"line\">    cout &lt;&lt; t3.<span class=\"built_in\">count</span>() &lt;&lt; <span class=\"string\">&quot; second&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">540</span> second</span><br></pre></td></tr></table></figure>\n\n<p>在上面的测试程序中，t1 代表 10 分钟，t2 代表 60 秒，t3 是 t1 减去 t2，也就是 60*10-60&#x3D;540，这个 540 表示的时钟周期，每个时钟周期是 1 秒，因此两个时间间隔之间的差值为 540 秒。</p>\n<p>注意事项：duration 的加减运算有一定的规则，当两个 duration 时钟周期不相同的时候，会先统一成一种时钟，然后再进行算术运算.</p>\n<p>因为类型表示的维度不一，粗粒度的时长肯定能用细粒度的类型表示，反之则可能丢失精度，所以需要使用<code>chrono::duration_cast()</code>函数做显式的转换。将当前的时钟周期转换为其它的时钟周期，比如我可以把秒的时钟周期转换为分钟的时钟周期，然后通过count来获取转换后的分钟时间间隔：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; chrono::<span class=\"built_in\">duration_cast</span>&lt;chrono::minutes&gt;( t3 ).<span class=\"built_in\">count</span>() &lt;&lt;” minutes”&lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">将会输出:</span><br><span class=\"line\"><span class=\"number\">9</span> minutes</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Time-point\"><a href=\"#Time-point\" class=\"headerlink\" title=\"Time point\"></a><strong>Time point</strong></h2><p>time_point表示一个时间点，用来获取1970.1.1以来的秒数和当前的时间, 可以做一些时间的比较和算术运算，可以和ctime库结合起来显示时间。time_point必须要clock来计时，</p>\n<p>time_point有一个函数<code>time_from_eproch()</code>用来获得1970年1月1日到time_point时间经过的duration。</p>\n<p>有一个<code>chrono::time_point_cast</code>转换函数，可以显式从高粒度向低粒度对time_point进行转换。</p>\n<p>下面的例子计算当前时间距离1970年1月1日有多少天：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ratio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std::chrono;</span><br><span class=\"line\">  <span class=\"keyword\">typedef</span> duration&lt;<span class=\"type\">int</span>,std::ratio&lt;<span class=\"number\">60</span>*<span class=\"number\">60</span>*<span class=\"number\">24</span>&gt;&gt; days_type;</span><br><span class=\"line\">  time_point&lt;system_clock,days_type&gt; today = <span class=\"built_in\">time_point_cast</span>&lt;days_type&gt;(system_clock::<span class=\"built_in\">now</span>());</span><br><span class=\"line\">  std::cout &lt;&lt; today.<span class=\"built_in\">time_since_epoch</span>().<span class=\"built_in\">count</span>() &lt;&lt; <span class=\"string\">&quot; days since epoch&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>time_point还支持一些算术元算，比如两个time_point的差值时钟周期数，还可以和duration相加减。下面的例子输出前一天和后一天的日期：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iomanip&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std::chrono;</span><br><span class=\"line\">    system_clock::time_point now = system_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">    std::<span class=\"type\">time_t</span> last = system_clock::<span class=\"built_in\">to_time_t</span>(now - std::chrono::<span class=\"built_in\">hours</span>(<span class=\"number\">24</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">　　std::<span class=\"type\">time_t</span> next= system_clock::<span class=\"built_in\">to_time_t</span>(now - std::chrono::<span class=\"built_in\">hours</span>(<span class=\"number\">24</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;One day ago, the time was &quot;</span>&lt;&lt; std::<span class=\"built_in\">put_time</span>(std::<span class=\"built_in\">localtime</span>(&amp;last), <span class=\"string\">&quot;%F %T&quot;</span>) &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">　　std::cout &lt;&lt; <span class=\"string\">&quot;Next day, the time was &quot;</span>&lt;&lt; std::<span class=\"built_in\">put_time</span>(std::<span class=\"built_in\">localtime</span>(&amp;next), <span class=\"string\">&quot;%F %T&quot;</span>) &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">One day ago, the time was <span class=\"number\">2014</span><span class=\"number\">-3</span><span class=\"number\">-2622</span>:<span class=\"number\">38</span>:<span class=\"number\">27</span></span><br><span class=\"line\">Next day, the time was <span class=\"number\">2014</span><span class=\"number\">-3</span><span class=\"number\">-2822</span>:<span class=\"number\">38</span>:<span class=\"number\">27</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Clocks\"><a href=\"#Clocks\" class=\"headerlink\" title=\"Clocks\"></a><strong>Clocks</strong></h2><p>clock是Chrono中的重要概念，而且这些clock都包含一个<code>now()</code>的成员函数，用于返回当前的time_point。Boost.Chrono包含的clock类型有：</p>\n<p>　　(1) <code>chrono::system_clock</code> 代表系统时间，比如电脑上显示的当前时间，其特点是这个时间可以被用户手动设置更新，所以这个时钟是可以和外部时钟源同步的。</p>\n<p>　　(2) <code>chrono::steady_clock</code> 其特点是时间是单调增长的，后一个时刻访问得到的时间点肯定比之前时刻得到的时间点要晚，即使我们手动将系统时间向前调整了也不会改变这个时钟稳步向前推行累计，其也被称为monotonic time，该时钟是均匀增长且不能被调整，其特性对于很多不允许时间错乱的系统是十分重要的。<code>chrono::steady_clock</code>通常是基于系统启动时间来计时的，而且常常用来进行耗时、等待等工作使用。<strong>steady_clock可以获取稳定可靠的时间间隔，后一次调用now()的值和前一次的差值是不因为修改了系统时间而改变，它保证了稳定的时间间隔。它的用法和system用法一样。</strong></p>\n<p>　　(3) <code>chrono::high_resolution_clock </code>依赖于系统实现，通常是上面两种时钟的某个宏定义，取决于哪个时钟源更为的精确，所以其输出也决定于取决于上面哪个clock来实现的。</p>\n<p>　　(4) <code>chrono::process_real_cpu_clock </code>表示自进程启动以来使用的CPU时间，而这个数据也可以通过使用std::clock()来获得。<code>chrono::process_user_cpu_clock</code>、<code>boost::chrono::process_system_cpu_clock</code>表示自进程启动以来，在用户态、内核态所花费的时间，而所有的这些事件可以通过<code>chrono::process_cpu_clock</code>来获得，他返回上面所有时间组成的一个tuple结构。</p>\n<p>　　(5) <code>chrono::thread_clock</code> 返回基于线程统计的花费时间，而且不区分用户态、内核态的时间。</p>\n<p>在这些时钟类的内部有 time_point、duration、Rep、Period 等信息，基于这些信息来获取当前时间。</p>\n<p>可以通过now()来获取当前时间点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">std::chrono::steady_clock::time_point t1 = std::chrono::system_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">std::cout &lt;&lt; <span class=\"string\">&quot;Hello World\\n&quot;</span>;</span><br><span class=\"line\">std::chrono::steady_clock::time_point t2 = std::chrono:: system_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">std::cout &lt;&lt; (t2-t1).<span class=\"built_in\">count</span>()&lt;&lt;” tick count”&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">Hello World</span><br><span class=\"line\"><span class=\"number\">20801</span>tick count</span><br></pre></td></tr></table></figure>\n\n<p>通过时钟获取两个时间点之相差多少个时钟周期，我们可以通过duration_cast将其转换为其它时钟周期的duration：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; std::chrono::<span class=\"built_in\">duration_cast</span>&lt;std::chrono::microseconds&gt;( t2-t1 ).<span class=\"built_in\">count</span>() &lt;&lt;” microseconds”&lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\"><span class=\"number\">20</span> microseconds</span><br></pre></td></tr></table></figure>\n\n<p>还可以实现 <code>time_t</code> 和 <code>time_point</code> 之间的相互转换。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//system_clock的to_time_t方法可以将一个time_point转换为ctime：</span></span><br><span class=\"line\">std::<span class=\"type\">time_t</span> now_c = std::chrono::system_clock::<span class=\"built_in\">to_time_t</span>(time_point);</span><br><span class=\"line\"><span class=\"comment\">//而from_time_t方法则是相反的，它将ctime转换为time_point。</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std::chrono;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 新纪元1970.1.1时间</span></span><br><span class=\"line\">    system_clock::time_point epoch;</span><br><span class=\"line\"></span><br><span class=\"line\">    duration&lt;<span class=\"type\">int</span>, ratio&lt;<span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span>&gt;&gt; <span class=\"built_in\">day</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 新纪元1970.1.1时间 + 1天</span></span><br><span class=\"line\">    <span class=\"function\">system_clock::time_point <span class=\"title\">ppt</span><span class=\"params\">(day)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span> dday = duration&lt;<span class=\"type\">int</span>, ratio&lt;<span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span>&gt;&gt;;</span><br><span class=\"line\">    <span class=\"comment\">// 新纪元1970.1.1时间 + 10天</span></span><br><span class=\"line\">    <span class=\"function\">time_point&lt;system_clock, dday&gt; <span class=\"title\">t</span><span class=\"params\">(dday(<span class=\"number\">10</span>))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 系统当前时间</span></span><br><span class=\"line\">    system_clock::time_point today = system_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 转换为time_t时间类型</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span> tm = system_clock::<span class=\"built_in\">to_time_t</span>(today);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;今天的日期是: &quot;</span> &lt;&lt; <span class=\"built_in\">ctime</span>(&amp;tm);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">time_t</span> tm1 = system_clock::<span class=\"built_in\">to_time_t</span>(today + day);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;明天的日期是: &quot;</span> &lt;&lt; <span class=\"built_in\">ctime</span>(&amp;tm1);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">time_t</span> tm2 = system_clock::<span class=\"built_in\">to_time_t</span>(epoch);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;新纪元时间: &quot;</span> &lt;&lt; <span class=\"built_in\">ctime</span>(&amp;tm2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">time_t</span> tm3 = system_clock::<span class=\"built_in\">to_time_t</span>(ppt);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;新纪元时间+1天: &quot;</span> &lt;&lt; <span class=\"built_in\">ctime</span>(&amp;tm3);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">time_t</span> tm4 = system_clock::<span class=\"built_in\">to_time_t</span>(t);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;新纪元时间+10天: &quot;</span> &lt;&lt; <span class=\"built_in\">ctime</span>(&amp;tm4);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">今天的日期是: Thu Apr <span class=\"number\">8</span> <span class=\"number\">11</span>:<span class=\"number\">09</span>:<span class=\"number\">49</span> <span class=\"number\">2021</span></span><br><span class=\"line\">明天的日期是: Fri Apr <span class=\"number\">9</span> <span class=\"number\">11</span>:<span class=\"number\">09</span>:<span class=\"number\">49</span> <span class=\"number\">2021</span></span><br><span class=\"line\">新纪元时间: Thu Jan <span class=\"number\">1</span> <span class=\"number\">08</span>:<span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">1970</span></span><br><span class=\"line\">新纪元时间+<span class=\"number\">1</span>天: Fri Jan <span class=\"number\">2</span> <span class=\"number\">08</span>:<span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">1970</span></span><br><span class=\"line\">新纪元时间+<span class=\"number\">10</span>天: Sun Jan <span class=\"number\">11</span> <span class=\"number\">08</span>:<span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">1970</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"https://blog.csdn.net/weixin_42907473/article/details/90278426\">https://blog.csdn.net/weixin_42907473/article/details/90278426</a></p>\n<p><a href=\"https://www.cnblogs.com/Galesaur-wcy/p/15380832.html\">https://www.cnblogs.com/Galesaur-wcy/p/15380832.html</a></p>\n<p><a href=\"https://www.jb51.net/article/122979.htm\">https://www.jb51.net/article/122979.htm</a></p>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-9.png","cover_type":"img","excerpt":"","more":"<h1 id=\"C-11-chrono库-日期和时间库\"><a href=\"#C-11-chrono库-日期和时间库\" class=\"headerlink\" title=\"C++11:chrono库 (日期和时间库)\"></a>C++11:chrono库 (日期和时间库)</h1><blockquote>\n<p>​\tC++11标准已经支持std::chrono了，但是为了兼容老编译系统现在很多C++库和程序都使用boost::chrono作为时间类库(还有的原因就std::chrono没有收录boost::chrono的所有功能，比如统计CPU使用时间、自定义时间输出格式等)，Boost::Chrono的时间类型分为duration和time_point，也就是时长和时刻两类，很多概念和接口都是围绕这两个维度去定义和实现的。</p>\n</blockquote>\n<p>chrono库主要包含了三种类型:<br>时间间隔Duration<br>时钟Clocks<br>时间点Time point</p>\n<h2 id=\"Duration\"><a href=\"#Duration\" class=\"headerlink\" title=\"Duration\"></a><strong>Duration</strong></h2><p>duration表示一段时间间隔，用来记录时间长度，可以表示几秒钟、几分钟或者几个小时的时间间隔。</p>\n<p>其原型:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Rep</span>,<span class=\"keyword\">class</span> <span class=\"title class_\">Period</span> = std::ration&lt;<span class=\"number\">1</span>&gt;&gt; <span class=\"keyword\">class</span> duration;</span><br></pre></td></tr></table></figure>\n\n<p>第一个模板参数Rep是一个数值类型，表明存储所用的数据类型(int、long、double等)；第二个模板参数是一个默认模板参数std::ratio，它的原型是：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;std::<span class=\"type\">intmax_t</span> Num, std::<span class=\"type\">intmax_t</span> Denom = <span class=\"number\">1</span>&gt; <span class=\"keyword\">class</span> ratio;</span><br></pre></td></tr></table></figure>\n\n<p>第一个模板参数Rep是一个数值类型，表明存储所用的数据类型(int、long、double等)；第二个模板参数是一个默认模板参数std::ratio，它的原型是：</p>\n<p>它表示每个时钟周期的秒数，其中第一个模板参数Num代表分子，Denom代表分母，分母默认为1，ratio代表的是一个分子除以分母的分数值，比如ratio&lt;2&gt;代表一个时钟周期是两秒，ratio&lt;60&gt;代表了一分钟，ratio&lt;60 * 60&gt;代表一个小时，ratio&lt;60 * 60 * 24&gt;代表一天。而ratio&lt;1, 1000&gt;代表的则是1&#x2F;1000秒即一毫秒，ratio&lt;1, 1000000&gt;代表一微秒，ratio&lt;1, 1000000000&gt;代表一纳秒。</p>\n<p>标准库为了方便使用，就定义了一些常用的时间间隔，如时、分、秒、毫秒、微秒和纳秒，在chrono命名空间下，它们的定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> duration &lt;Rep, ratio&lt;<span class=\"number\">3600</span>,<span class=\"number\">1</span>&gt;&gt; hours;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> duration &lt;Rep, ratio&lt;<span class=\"number\">60</span>,<span class=\"number\">1</span>&gt;&gt; minutes;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> duration &lt;Rep, ratio&lt;<span class=\"number\">1</span>,<span class=\"number\">1</span>&gt;&gt; seconds;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> duration &lt;Rep, ratio&lt;<span class=\"number\">1</span>,<span class=\"number\">1000</span>&gt;&gt; milliseconds;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> duration &lt;Rep, ratio&lt;<span class=\"number\">1</span>,<span class=\"number\">1000000</span>&gt;&gt; microseconds;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> duration &lt;Rep, ratio&lt;<span class=\"number\">1</span>,<span class=\"number\">1000000000</span>&gt;&gt; nanoseconds;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">chrono::hours <span class=\"title\">h</span><span class=\"params\">(<span class=\"number\">1</span>)</span></span>; <span class=\"comment\">// 一小时</span></span><br><span class=\"line\">    chrono::milliseconds ms&#123; <span class=\"number\">3</span> &#125;; <span class=\"comment\">// 3 毫秒</span></span><br><span class=\"line\">    chrono::duration&lt;<span class=\"type\">int</span>, ratio&lt;<span class=\"number\">1000</span>&gt;&gt; <span class=\"built_in\">ks</span>(<span class=\"number\">3</span>); <span class=\"comment\">// 3000 秒</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// chrono::duration&lt;int, ratio&lt;1000&gt;&gt; d3(3.5); // error</span></span><br><span class=\"line\">    <span class=\"function\">chrono::duration&lt;<span class=\"type\">double</span>&gt; <span class=\"title\">dd</span><span class=\"params\">(<span class=\"number\">6.6</span>)</span></span>; <span class=\"comment\">// 6.6 秒</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用小数表示时钟周期的次数</span></span><br><span class=\"line\">    chrono::duration&lt;<span class=\"type\">double</span>, std::ratio&lt;<span class=\"number\">1</span>, <span class=\"number\">30</span>&gt;&gt; <span class=\"built_in\">hz</span>(<span class=\"number\">3.5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*********************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">h(1) 时钟周期为 1 小时，共有 1 个时钟周期，所以 h 表示的时间间隔为 1 小时</span></span><br><span class=\"line\"><span class=\"comment\">ms(3) 时钟周期为 1 毫秒，共有 3 个时钟周期，所以 ms 表示的时间间隔为 3 毫秒</span></span><br><span class=\"line\"><span class=\"comment\">ks(3) 时钟周期为 1000 秒，一共有三个时钟周期，所以 ks 表示的时间间隔为 3000 秒</span></span><br><span class=\"line\"><span class=\"comment\">d3(3.5) 时钟周期为 1000 秒，时钟周期数量只能用整形来表示，但是此处指定的是浮点数，因此语法错误</span></span><br><span class=\"line\"><span class=\"comment\">dd(6.6) 时钟周期为默认的 1 秒，共有 6.6 个时钟周期，所以 dd 表示的时间间隔为 6.6 秒</span></span><br><span class=\"line\"><span class=\"comment\">hz(3.5) 时钟周期为 1/30 秒，共有 3.5 个时钟周期，所以 hz 表示的时间间隔为 1/30*3.5 秒</span></span><br><span class=\"line\"><span class=\"comment\">chrono 库中根据 duration 类封装了不同长度的时钟周期（也可以自定义），基于这个时钟周期再进行周期次数的设置就可以得到总的时间间隔了（时钟周期 * 周期次数 = 总的时间间隔）。</span></span><br><span class=\"line\"><span class=\"comment\">*************************************************************************/</span></span><br></pre></td></tr></table></figure>\n\n<p>chrono还提供了获取时间间隔的时钟周期个数的方法count()，它的基本用法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::chrono::milliseconds ms&#123; <span class=\"number\">3</span> &#125;; <span class=\"comment\">// 3 毫秒</span></span><br><span class=\"line\">    std::chrono::microseconds us = <span class=\"number\">2</span> * ms; <span class=\"comment\">// 6000 微秒</span></span><br><span class=\"line\">    <span class=\"comment\">// 时间间隔周期为 1/30 秒</span></span><br><span class=\"line\">    std::chrono::duration&lt;<span class=\"type\">double</span>, std::ratio&lt;<span class=\"number\">1</span>, <span class=\"number\">30</span>&gt;&gt; <span class=\"built_in\">hz</span>(<span class=\"number\">3.5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;3 ms duration has &quot;</span> &lt;&lt; ms.<span class=\"built_in\">count</span>() &lt;&lt; <span class=\"string\">&quot; ticks\\n&quot;</span></span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">&quot;6000 us duration has &quot;</span> &lt;&lt; us.<span class=\"built_in\">count</span>() &lt;&lt; <span class=\"string\">&quot; ticks\\n&quot;</span></span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">&quot;3.5 hz duration has &quot;</span> &lt;&lt; hz.<span class=\"built_in\">count</span>() &lt;&lt; <span class=\"string\">&quot; ticks\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span> ms duration has <span class=\"number\">3</span> ticks</span><br><span class=\"line\"><span class=\"number\">6000</span> us duration has <span class=\"number\">6000</span> ticks</span><br><span class=\"line\"><span class=\"number\">3.5</span> hz duration has <span class=\"number\">3.5</span> ticks</span><br><span class=\"line\"></span><br><span class=\"line\">ms 时间单位为毫秒，初始化操作 ms&#123;<span class=\"number\">3</span>&#125; 表示时间间隔为 <span class=\"number\">3</span> 毫秒，一共有 <span class=\"number\">3</span> 个时间周期，每个周期为 <span class=\"number\">1</span> 毫秒</span><br><span class=\"line\">us 时间单位为微秒，初始化操作 <span class=\"number\">2</span>*ms 表示时间间隔为 <span class=\"number\">6000</span> 微秒，一共有 <span class=\"number\">6000</span> 个时间周期，每个周期为 <span class=\"number\">1</span> 微秒</span><br><span class=\"line\">hz 时间单位为秒，初始化操作 <span class=\"built_in\">hz</span>(<span class=\"number\">3.5</span>) 表示时间间隔为 <span class=\"number\">1</span>/<span class=\"number\">30</span>*<span class=\"number\">3.5</span> 秒，一共有 <span class=\"number\">3.5</span> 个时间周期，每个周期为 <span class=\"number\">1</span>/<span class=\"number\">30</span> 秒</span><br></pre></td></tr></table></figure>\n\n<p>通过定义这些常用的时间间隔类型，我们能方便的使用它们，比如线程的休眠:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::this_thread::<span class=\"built_in\">sleep_for</span>(std::chrono::<span class=\"built_in\">seconds</span>(<span class=\"number\">3</span>)); <span class=\"comment\">//休眠三秒</span></span><br><span class=\"line\"></span><br><span class=\"line\">std::this_thread::<span class=\"built_in\">sleep_for</span>(std::chrono:: <span class=\"built_in\">milliseconds</span> (<span class=\"number\">100</span>)); <span class=\"comment\">//休眠100毫秒</span></span><br></pre></td></tr></table></figure>\n\n<p>由于在 duration 类内部做了操作符重载，因此时间间隔之间可以直接进行算术运算，比如我们要计算两个时间间隔的差值，就可以在代码中做如下处理：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> boost;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">chrono::minutes <span class=\"title\">t1</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">chrono::seconds <span class=\"title\">t2</span><span class=\"params\">(<span class=\"number\">60</span>)</span></span>;</span><br><span class=\"line\">    chrono::seconds t3 = t1 - t2;</span><br><span class=\"line\">    cout &lt;&lt; t3.<span class=\"built_in\">count</span>() &lt;&lt; <span class=\"string\">&quot; second&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">540</span> second</span><br></pre></td></tr></table></figure>\n\n<p>在上面的测试程序中，t1 代表 10 分钟，t2 代表 60 秒，t3 是 t1 减去 t2，也就是 60*10-60&#x3D;540，这个 540 表示的时钟周期，每个时钟周期是 1 秒，因此两个时间间隔之间的差值为 540 秒。</p>\n<p>注意事项：duration 的加减运算有一定的规则，当两个 duration 时钟周期不相同的时候，会先统一成一种时钟，然后再进行算术运算.</p>\n<p>因为类型表示的维度不一，粗粒度的时长肯定能用细粒度的类型表示，反之则可能丢失精度，所以需要使用<code>chrono::duration_cast()</code>函数做显式的转换。将当前的时钟周期转换为其它的时钟周期，比如我可以把秒的时钟周期转换为分钟的时钟周期，然后通过count来获取转换后的分钟时间间隔：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; chrono::<span class=\"built_in\">duration_cast</span>&lt;chrono::minutes&gt;( t3 ).<span class=\"built_in\">count</span>() &lt;&lt;” minutes”&lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">将会输出:</span><br><span class=\"line\"><span class=\"number\">9</span> minutes</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Time-point\"><a href=\"#Time-point\" class=\"headerlink\" title=\"Time point\"></a><strong>Time point</strong></h2><p>time_point表示一个时间点，用来获取1970.1.1以来的秒数和当前的时间, 可以做一些时间的比较和算术运算，可以和ctime库结合起来显示时间。time_point必须要clock来计时，</p>\n<p>time_point有一个函数<code>time_from_eproch()</code>用来获得1970年1月1日到time_point时间经过的duration。</p>\n<p>有一个<code>chrono::time_point_cast</code>转换函数，可以显式从高粒度向低粒度对time_point进行转换。</p>\n<p>下面的例子计算当前时间距离1970年1月1日有多少天：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ratio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std::chrono;</span><br><span class=\"line\">  <span class=\"keyword\">typedef</span> duration&lt;<span class=\"type\">int</span>,std::ratio&lt;<span class=\"number\">60</span>*<span class=\"number\">60</span>*<span class=\"number\">24</span>&gt;&gt; days_type;</span><br><span class=\"line\">  time_point&lt;system_clock,days_type&gt; today = <span class=\"built_in\">time_point_cast</span>&lt;days_type&gt;(system_clock::<span class=\"built_in\">now</span>());</span><br><span class=\"line\">  std::cout &lt;&lt; today.<span class=\"built_in\">time_since_epoch</span>().<span class=\"built_in\">count</span>() &lt;&lt; <span class=\"string\">&quot; days since epoch&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>time_point还支持一些算术元算，比如两个time_point的差值时钟周期数，还可以和duration相加减。下面的例子输出前一天和后一天的日期：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iomanip&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std::chrono;</span><br><span class=\"line\">    system_clock::time_point now = system_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">    std::<span class=\"type\">time_t</span> last = system_clock::<span class=\"built_in\">to_time_t</span>(now - std::chrono::<span class=\"built_in\">hours</span>(<span class=\"number\">24</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">　　std::<span class=\"type\">time_t</span> next= system_clock::<span class=\"built_in\">to_time_t</span>(now - std::chrono::<span class=\"built_in\">hours</span>(<span class=\"number\">24</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;One day ago, the time was &quot;</span>&lt;&lt; std::<span class=\"built_in\">put_time</span>(std::<span class=\"built_in\">localtime</span>(&amp;last), <span class=\"string\">&quot;%F %T&quot;</span>) &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">　　std::cout &lt;&lt; <span class=\"string\">&quot;Next day, the time was &quot;</span>&lt;&lt; std::<span class=\"built_in\">put_time</span>(std::<span class=\"built_in\">localtime</span>(&amp;next), <span class=\"string\">&quot;%F %T&quot;</span>) &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">One day ago, the time was <span class=\"number\">2014</span><span class=\"number\">-3</span><span class=\"number\">-2622</span>:<span class=\"number\">38</span>:<span class=\"number\">27</span></span><br><span class=\"line\">Next day, the time was <span class=\"number\">2014</span><span class=\"number\">-3</span><span class=\"number\">-2822</span>:<span class=\"number\">38</span>:<span class=\"number\">27</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Clocks\"><a href=\"#Clocks\" class=\"headerlink\" title=\"Clocks\"></a><strong>Clocks</strong></h2><p>clock是Chrono中的重要概念，而且这些clock都包含一个<code>now()</code>的成员函数，用于返回当前的time_point。Boost.Chrono包含的clock类型有：</p>\n<p>　　(1) <code>chrono::system_clock</code> 代表系统时间，比如电脑上显示的当前时间，其特点是这个时间可以被用户手动设置更新，所以这个时钟是可以和外部时钟源同步的。</p>\n<p>　　(2) <code>chrono::steady_clock</code> 其特点是时间是单调增长的，后一个时刻访问得到的时间点肯定比之前时刻得到的时间点要晚，即使我们手动将系统时间向前调整了也不会改变这个时钟稳步向前推行累计，其也被称为monotonic time，该时钟是均匀增长且不能被调整，其特性对于很多不允许时间错乱的系统是十分重要的。<code>chrono::steady_clock</code>通常是基于系统启动时间来计时的，而且常常用来进行耗时、等待等工作使用。<strong>steady_clock可以获取稳定可靠的时间间隔，后一次调用now()的值和前一次的差值是不因为修改了系统时间而改变，它保证了稳定的时间间隔。它的用法和system用法一样。</strong></p>\n<p>　　(3) <code>chrono::high_resolution_clock </code>依赖于系统实现，通常是上面两种时钟的某个宏定义，取决于哪个时钟源更为的精确，所以其输出也决定于取决于上面哪个clock来实现的。</p>\n<p>　　(4) <code>chrono::process_real_cpu_clock </code>表示自进程启动以来使用的CPU时间，而这个数据也可以通过使用std::clock()来获得。<code>chrono::process_user_cpu_clock</code>、<code>boost::chrono::process_system_cpu_clock</code>表示自进程启动以来，在用户态、内核态所花费的时间，而所有的这些事件可以通过<code>chrono::process_cpu_clock</code>来获得，他返回上面所有时间组成的一个tuple结构。</p>\n<p>　　(5) <code>chrono::thread_clock</code> 返回基于线程统计的花费时间，而且不区分用户态、内核态的时间。</p>\n<p>在这些时钟类的内部有 time_point、duration、Rep、Period 等信息，基于这些信息来获取当前时间。</p>\n<p>可以通过now()来获取当前时间点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">std::chrono::steady_clock::time_point t1 = std::chrono::system_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">std::cout &lt;&lt; <span class=\"string\">&quot;Hello World\\n&quot;</span>;</span><br><span class=\"line\">std::chrono::steady_clock::time_point t2 = std::chrono:: system_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">std::cout &lt;&lt; (t2-t1).<span class=\"built_in\">count</span>()&lt;&lt;” tick count”&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">Hello World</span><br><span class=\"line\"><span class=\"number\">20801</span>tick count</span><br></pre></td></tr></table></figure>\n\n<p>通过时钟获取两个时间点之相差多少个时钟周期，我们可以通过duration_cast将其转换为其它时钟周期的duration：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; std::chrono::<span class=\"built_in\">duration_cast</span>&lt;std::chrono::microseconds&gt;( t2-t1 ).<span class=\"built_in\">count</span>() &lt;&lt;” microseconds”&lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\"><span class=\"number\">20</span> microseconds</span><br></pre></td></tr></table></figure>\n\n<p>还可以实现 <code>time_t</code> 和 <code>time_point</code> 之间的相互转换。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//system_clock的to_time_t方法可以将一个time_point转换为ctime：</span></span><br><span class=\"line\">std::<span class=\"type\">time_t</span> now_c = std::chrono::system_clock::<span class=\"built_in\">to_time_t</span>(time_point);</span><br><span class=\"line\"><span class=\"comment\">//而from_time_t方法则是相反的，它将ctime转换为time_point。</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std::chrono;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 新纪元1970.1.1时间</span></span><br><span class=\"line\">    system_clock::time_point epoch;</span><br><span class=\"line\"></span><br><span class=\"line\">    duration&lt;<span class=\"type\">int</span>, ratio&lt;<span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span>&gt;&gt; <span class=\"built_in\">day</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 新纪元1970.1.1时间 + 1天</span></span><br><span class=\"line\">    <span class=\"function\">system_clock::time_point <span class=\"title\">ppt</span><span class=\"params\">(day)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">using</span> dday = duration&lt;<span class=\"type\">int</span>, ratio&lt;<span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span>&gt;&gt;;</span><br><span class=\"line\">    <span class=\"comment\">// 新纪元1970.1.1时间 + 10天</span></span><br><span class=\"line\">    <span class=\"function\">time_point&lt;system_clock, dday&gt; <span class=\"title\">t</span><span class=\"params\">(dday(<span class=\"number\">10</span>))</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 系统当前时间</span></span><br><span class=\"line\">    system_clock::time_point today = system_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 转换为time_t时间类型</span></span><br><span class=\"line\">    <span class=\"type\">time_t</span> tm = system_clock::<span class=\"built_in\">to_time_t</span>(today);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;今天的日期是: &quot;</span> &lt;&lt; <span class=\"built_in\">ctime</span>(&amp;tm);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">time_t</span> tm1 = system_clock::<span class=\"built_in\">to_time_t</span>(today + day);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;明天的日期是: &quot;</span> &lt;&lt; <span class=\"built_in\">ctime</span>(&amp;tm1);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">time_t</span> tm2 = system_clock::<span class=\"built_in\">to_time_t</span>(epoch);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;新纪元时间: &quot;</span> &lt;&lt; <span class=\"built_in\">ctime</span>(&amp;tm2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">time_t</span> tm3 = system_clock::<span class=\"built_in\">to_time_t</span>(ppt);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;新纪元时间+1天: &quot;</span> &lt;&lt; <span class=\"built_in\">ctime</span>(&amp;tm3);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">time_t</span> tm4 = system_clock::<span class=\"built_in\">to_time_t</span>(t);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;新纪元时间+10天: &quot;</span> &lt;&lt; <span class=\"built_in\">ctime</span>(&amp;tm4);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">今天的日期是: Thu Apr <span class=\"number\">8</span> <span class=\"number\">11</span>:<span class=\"number\">09</span>:<span class=\"number\">49</span> <span class=\"number\">2021</span></span><br><span class=\"line\">明天的日期是: Fri Apr <span class=\"number\">9</span> <span class=\"number\">11</span>:<span class=\"number\">09</span>:<span class=\"number\">49</span> <span class=\"number\">2021</span></span><br><span class=\"line\">新纪元时间: Thu Jan <span class=\"number\">1</span> <span class=\"number\">08</span>:<span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">1970</span></span><br><span class=\"line\">新纪元时间+<span class=\"number\">1</span>天: Fri Jan <span class=\"number\">2</span> <span class=\"number\">08</span>:<span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">1970</span></span><br><span class=\"line\">新纪元时间+<span class=\"number\">10</span>天: Sun Jan <span class=\"number\">11</span> <span class=\"number\">08</span>:<span class=\"number\">00</span>:<span class=\"number\">00</span> <span class=\"number\">1970</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"https://blog.csdn.net/weixin_42907473/article/details/90278426\">https://blog.csdn.net/weixin_42907473/article/details/90278426</a></p>\n<p><a href=\"https://www.cnblogs.com/Galesaur-wcy/p/15380832.html\">https://www.cnblogs.com/Galesaur-wcy/p/15380832.html</a></p>\n<p><a href=\"https://www.jb51.net/article/122979.htm\">https://www.jb51.net/article/122979.htm</a></p>\n"},{"_content":"# Find_package \n\n## **1、find_packakge命令基本介绍** \n\n> ​\t\t在我们实际开发过程中，经常不可避免会使用到第三方开源库，这些开源库可能是通过apt-get install命令自动安装到系统目录中，也可能是由我们自己下载库的源码然后通过编译安装到指令目录下的。\n>\n> ​\t\t不管哪种方式安装的库文件，如果我们需要自己的项目中使用这些库，首先面临的第一个问题就是如何找到这些库。所谓“找到”这些库，其实是根据我们的需要找到指定版本的库头文件包含路径、链接库路径等，从而能够满足我们开发项目的编译链接需要。\n>\n> ​\t\t在没有CMake的时代，这种库查找链接的工作都需要借助MakeFile中的各种命令来完成，非常的繁琐，而且不方便移植，到了CMake时代，CMake给我们提供了find_package()命令用来查找依赖包，理想情况下，一句find_package()命令就能把一整个依赖包的头文件包含路径、库路径、库名字、版本号等情况都获取到，后续只管用就好了。但实际使用过程可能会出现这样那样的问题，因此需要我们对find_package这个强大的命令有个大概的理解。 \n\n## **2、一个使用find_package命令的例子** \n\n为了能够帮助大家理解find_package命令的用法，此处首先用OpenCV库举例子，示范如何通过find_pakcage命令找到OpenCV库并配置，从而能够在我们自己的项目中调用OpenCV库，实现特定的功能。 \n\n**opencv_test.cpp:** \n\n```\n#include <cstdio> \n#include <iostream> \n#include <opencv2/opencv.hpp> \n\nusing namespace cv; \n\nint main() { \n  Mat image; \n  image = imread(\"../opencv_test.jpg\"); \n \n  if (!image.data) { \n    printf(\"No image data\\n\"); \n    return -1; \n  } \n\n  namedWindow(\"Display Image\", CV_WINDOW_AUTOSIZE); \n  imshow(\"Display Image\", image); \n  waitKey(0); \n  return 0; \n} \n```\n\n**CMakeLists.txt:** \n\n```\ncmake_minimum_required(VERSION 2.8) \nproject(find_package_learning) \nfind_package(OpenCV 3 REQUIRED) \n\n \nmessage(STATUS \"OpenCV_DIR = ${OpenCV_DIR}\") \nmessage(STATUS \"OpenCV_INCLUDE_DIRS = ${OpenCV_INCLUDE_DIRS}\") \nmessage(STATUS \"OpenCV_LIBS = ${OpenCV_LIBS}\") \n\n \ninclude_directories(${OPENCV_INCLUDE_DIRS})   \nadd_executable(opencv_test opencv_test.cpp)   \ntarget_link_libraries(opencv_test ${OpenCV_LIBS}) \n```\n\n### **2.1**编译输出与分析\n\n```\n-- The C compiler identification is GNU 7.5.0 \n-- The CXX compiler identification is GNU 7.5.0 \n-- Check for working C compiler: /usr/bin/cc \n-- Check for working C compiler: /usr/bin/cc -- works \n-- Detecting C compiler ABI info \n-- Detecting C compiler ABI info - done \n-- Detecting C compile features \n-- Detecting C compile features - done \n-- Check for working CXX compiler: /usr/bin/c++ \n-- Check for working CXX compiler: /usr/bin/c++ -- works \n-- Detecting CXX compiler ABI info \n-- Detecting CXX compiler ABI info - done \n-- Detecting CXX compile features \n-- Detecting CXX compile features - done \n-- Found OpenCV: /usr/local (found suitable version \"3.4.4\", minimum required is \"3\")  \n-- OpenCV_DIR = /usr/local/share/OpenCV \n-- OpenCV_INCLUDE_DIRS = /usr/local/include;/usr/local/include/opencv \n-- OpenCV_LIBS = opencv_calib3d;opencv_core;opencv_dnn;opencv_features2d;opencv_flann;opencv_highgui;opencv_imgcodecs;opencv_imgproc;opencv_ml;opencv_objdetect;opencv_photo;opencv_shape;opencv_stitching;opencv_superres;opencv_video;opencv_videoio;opencv_videostab;opencv_viz;opencv_aruco;opencv_bgsegm;opencv_bioinspired;opencv_ccalib;opencv_cvv;opencv_datasets;opencv_dnn_objdetect;opencv_dpm;opencv_face;opencv_freetype;opencv_fuzzy;opencv_hdf;opencv_hfs;opencv_img_hash;opencv_line_descriptor;opencv_optflow;opencv_phase_unwrapping;opencv_plot;opencv_reg;opencv_rgbd;opencv_saliency;opencv_stereo;opencv_structured_light;opencv_surface_matching;opencv_text;opencv_tracking;opencv_xfeatures2d;opencv_ximgproc;opencv_xobjdetect;opencv_xphoto \n-- Configuring done \n-- Generating done \n-- Build files have been written to: /home/zhanghm/Programming/programming-learning-examples/cmake_learning/learn_cmake_easily/find_package_learning/build \n```\n\n重点看下其中OpenCV_DIR、OpenCV_INCLUDE_DIRS和OpenCV_LIBS打印的结果，这是我在CMakeLists.txt中用message命令输出这三个变量的值的结果。 \n\n可以看到在执行find_package(OpenCV 3 REQUIRED)命令后，CMake找到了我们安装的位于/usr/local下的OpenCV库，并设置了CMake变量OpenCV_DIR为OpenCV库的配置文件所在路径，正是通过载入这个路径下的OpenCVConfig.cmake配置文件才能配置好OpenCV库，然后在OpenCVConfig.cmake配置文件中定义了变量OpenCV_INCLUDE_DIRS为OpenCV库头文件包含路径，这样我们才能才在代码中使用#include <opencv2/opencv.hpp>而不会出现编译错误，同时定义了变量OpenCV_LIBS为OpenCV链接库路径，这样我们才能正确链接到OpenCV中的库文件，而不会出现类似未定义的引用这样的链接错误。 \n\n![](media/GetImage.png)\n\n通过这个例子就可以看出find_package本质上就是一个搜包的命令，通过一些特定的规则找到<package_name>Config.cmake包配置文件，通过执行该配置文件，从而定义了一系列的变量，通过这些变量就可以准确定位到OpenCV库的头文件和库文件，完成编译。 \n\n那么关键的问题来了，find_package命令是怎么能够定位并载入指定库的配置文件的呢？这就需要梳理一下find_package命令的搜包过程。 \n\n## **3、find_package命令搜包过程** \n\n首先我们需要明确一点，CMake本身不提供任何搜索库的便捷方法，所有搜索库并给变量赋值的操作必须由CMake代码完成，也就是上述中的XXXConfig.cmake以及下面将要提到的FindXXX.cmake配置文件。只不过，库的作者通常会提供这两个文件，以方便使用者调用。\n\n### **3.1 find_package工作模式** \n\nfind_package命令有两种工作模式，这两种工作模式的不同决定了其搜包路径的不同： \n\n`Module模式` \n\nfind_package命令基础工作模式(Basic Signature)，也是默认工作模式。 \n\n`Config模式` \n\nfind_package命令高级工作模式(Full Signature)。 只有在find_package()中指定CONFIG、NO_MODULE等关键字，或者Module模式查找失败后才会进入到Config模式。 \n\n因此find_package工作模式流程图为： \n\n![](media/GetImage(1).png)\n\n### **3.2 Module模式用法** \n\n**Module**模式的参数为：\n\n```\nfind_package(<package> [version] [EXACT] [QUIET] [MODULE] \n             [REQUIRED] [[COMPONENTS] [components...]] \n             [OPTIONAL_COMPONENTS components...] \n             [NO_POLICY_SCOPE]) \n```\n\n参数解释： \n\n`package`：必填参数。需要查找的包名，注意大小写。 \n\n`version`和`EXACT`：可选参数，version指定的是版本，如果指定就必须检查找到的包的版本是否和version兼容。如果指定EXACT则表示必须完全匹配的版本而不是兼容版本就可以。 \n\n`QUIET`：可选参数，表示如果查找失败，不会在屏幕进行输出（但是如果指定了REQUIRED字段，则QUIET无效，仍然会输出查找失败提示语）。 \n\n`MODULE`：可选字段。前面提到说“如果Module模式查找失败则回退到Config模式进行查找”，但是假如加入了MODULE选项，那么就只在Module模式查找，如果Module模式下查找失败并不切换到Config模式查找。 \n\n`REQUIRED`：可选字段。表示一定要找到包，找不到的话就立即停掉整个CMake。而如果不指定REQUIRED则CMake会继续执行。 \n\n`COMPONENTS`，components：可选字段，表示查找的包中必须要找到的组件(components），如果有任何一个找不到就算失败，类似于REQUIRED，导致CMake停止执行。 \n\n**Module模式查找顺序** \n\nModule模式下是要查找到名为Find<PackageName>.cmake的配置文件。 \n\nModule模式只有两个查找路径：`CMAKE_MODULE_PATH`和`CMake安装路径下的Modules目录`， \n\n搜包路径依次为： \n\n```\nCMAKE_MODULE_PATH \nCMAKE_ROOT\n```\n\n先在CMAKE_MODULE_PATH变量对应的路径中查找。如果路径为空，或者路径中查找失败，则在CMake安装目录（即CMAKE_ROOT变量）下的Modules目录下（通常为/usr/share/cmake-3.10/Modules，3.10是我的CMake版本）查找。这两个变量可以在CMakeLists.txt文件中打印查看具体内容： \n\n```\nmessage(STATUS \"CMAKE_MODULE_PATH = ${CMAKE_MODULE_PATH}\") \nmessage(STATUS \"CMAKE_ROOT = ${CMAKE_ROOT}\") \n```\n\n其中**CMAKE_MODULE_PATH**默认为空，可以利用set命令赋值。 \n\n在安装CMake时，CMake为我们提供了很多开发库的FindXXX.cmake模块文件，可以通过命令查询： \n\n```\ncmake --help-module-list | grep -E ^Find \n```\n\n### 3.3 Config模式用法 \n\nConfig模式的完整命令参数为： \n\n```\nfind_package(<package> [version] [EXACT] [QUIET] \n             [REQUIRED] [[COMPONENTS] [components...]] \n             [CONFIG|NO_MODULE] \n             [NO_POLICY_SCOPE] \n             [NAMES name1 [name2 ...]] \n             [CONFIGS config1 [config2 ...]] \n             [HINTS path1 [path2 ... ]] \n             [PATHS path1 [path2 ... ]] \n             [PATH_SUFFIXES suffix1 [suffix2 ...]] \n             [NO_DEFAULT_PATH] \n             [NO_CMAKE_ENVIRONMENT_PATH] \n             [NO_CMAKE_PATH] \n             [NO_SYSTEM_ENVIRONMENT_PATH] \n             [NO_CMAKE_PACKAGE_REGISTRY] \n             [NO_CMAKE_BUILDS_PATH] # Deprecated; does nothing. \n             [NO_CMAKE_SYSTEM_PATH] \n             [NO_CMAKE_SYSTEM_PACKAGE_REGISTRY] \n             [CMAKE_FIND_ROOT_PATH_BOTH | \n              ONLY_CMAKE_FIND_ROOT_PATH | \n              NO_CMAKE_FIND_ROOT_PATH]) \n```\n\n相比于Module模式，Config模式的参数更多，也更复杂，但实际在使用过程中我们并不会用到所有参数，大部分参数都是可选的，我们只需要掌握基本的参数用法即可。 \n\n其中具体查找库并给XXX_INCLUDE_DIRS和XXX_LIBRARIES两个变量赋值的操作由XXXConfig.cmake模块完成。 \n\n两种模式看起来似乎差不多，不过CMake默认采取Module模式，如果Module模式未找到库，才会采取Config模式。如果XXX_DIR路径下找不到XXXConfig.cmake文件，则会找/usr/local/lib/cmake/XXX/中的XXXConfig.cmake文件。总之，Config模式是一个备选策略。通常，库安装时会拷贝一份XXXConfig.cmake到系统目录中，因此在没有显式指定搜索路径时也可以顺利找到。 \n\n#### Config模式查找顺序 \n\nConfig模式下是要查找名为<PackageName>Config.cmake或<lower-case-package-name>-config.cmake的模块文件。  \n\n搜包路径依次为： \n\n与Module模式不同，Config模式需要查找的路径非常多，也要匹配很多的可能性，因此有些路径是首先作为根目录，然后进行子目录的匹配，我会进行说明。  \n\n具体查找顺序为： \n\n1、名为<PackageName>_DIR的CMake变量或环境变量路径 \n\n默认为空。 \n\n这个路径是非根目录路径，需要指定到<PackageName>Config.cmake或<lower-case-package-name>-config.cmake文件所在目录才能找到。 \n\n2、名为CMAKE_PREFIX_PATH、CMAKE_FRAMEWORK_PATH、CMAKE_APPBUNDLE_PATH的CMake变量或环境变量路径 \n\n根目录，默认都为空。 \n\n注意如果你电脑中安装了ROS并配置好之后，你在终端执行echo $CMAKE_PREFIX_PATH会发现ROS会将CMAKE_PREFIX_PATH这个变量设置为ROS中的库的路径，意思是会首先查找ROS安装的库，如果恰好你在ROS中安装了OpenCV库，就会发现首先找到的是ROS中的OpenCV，而不是你自己安装到系统中的OpenCV。 \n\n3、PATH环境变量路径 \n\n根目录，默认为系统环境PATH环境变量值。 \n\n其实这个路径才是Config模式大部分情况下能够查找到安装到系统中各种库的原因。 \n\n这个路径的查找规则为： \n\n遍历PATH环境变量中的各路径，如果该路径如果以bin或sbin结尾，则自动回退到上一级目录得到根目录。例如我的PATH路径包括： \n\n```\n$ echo $PATH \n/home/zhanghm/.local/bin:/usr/local/cuda-10.1/bin:/opt/ros/melodic/bin:/home/zhanghm/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin\n```\n\n在上述指明的是根目录路径时，CMake会首先检查这些根目录路径下是否有名为<PackageName>Config.cmake或<lower-case-package-name>-config.cmake的模块文件，如果没有，CMake会继续检查或匹配这些根目录下的以下路径（<PackageName>_DIR路径不是根目录路径）： \n\n```\n<prefix>/(lib/<arch>|lib|share)/cmake/<name>*/ \n<prefix>/(lib/<arch>|lib|share)/<name>*/  \n<prefix>/(lib/<arch>|lib|share)/<name>*/(cmake|CMake)/\n```\n\n其中为系统架构名，如Ubuntu下一般为：/usr/lib/x86_64-linux-gnu，整个(lib/<arch>|lib|share)为可选路径，例如OpenCV库而言会检查或匹配<prefix>/OpenCV/、<prefix>/lib/x86_64-linux-gnu/OpenCV/、<prefix>/lib/share/OpenCV/、<prefix>/share/OpenCV/等路径；name为包名，不区分大小写<name>*意思是包名后接一些版本后等字符也是合法的，如pcl-1.9也会被找到。\n\n### **3.4 查找指定包建议** \n\n上面的查找规则整体看起来好像很复杂，但其实我们在安装库的时候都会自动配置安装到对的位置，一般都不会出现问题。如果我们需要指定特定的库，我们也只需要设置优先级最高的几个变量名即可。包括下面两种情况： \n\n1、如果你明确知道想要查找的库<PackageName>Config.cmake或<lower-case-package-name>-config.cmake文件所在路径，为了能够准确定位到这个包，可以直接设置变量<PackageName>_DIR为具体路径，如： \n\n```\nset(OpenCV_DIR \"/home/zhanghm/Softwares/enviroment_config/opencv3_4_4/opencv/build\") \n```\n\n就可以明确需要查找的OpenCV包的路径了。 \n\n2、如果你有多个包的配置文件需要查找，可以将这些配置文件都统一放在一个命名为cmake的文件夹下，然后设置变量CMAKE_PREFIX_PATH变量指向这个cmake文件夹路径，需要注意根据上述的匹配规则，此时每个包的配置文件需要单独放置在命名为包名的文件夹下（文件夹名不区分大小写），否则会提示找不到。 \n\n## **4、总结** \n\n通过前面的描述，我相信大家已经能够基本掌握find_package命令的各种用法了，也能够在出现各种问题时自己进行问题定位。但还有一个我们需要注意的点是我们能够在自己的项目中使用find_package命令便捷进行依赖包配置的前提是这个包的开发者也是用CMake配置好了这个包，并提供了<PackageName>Config.cmake或Find<PackageName>.cmake的配置文件。 \n\n## **参考** \n\nhttps://blog.csdn.net/zhanghm1995/article/details/105466372 \n\nhttps://cmake.org/cmake/help/v3.5/command/find_package.html （官网介绍） \n\nhttps://zhuanlan.zhihu.com/p/50829542 \n\nhttps://seanzhengw.github.io/blog/cmake/2018/04/23/cmake-find-package.html \n\nhttps://blog.csdn.net/bytxl/article/details/50637277 ","source":"_posts/C++/Find_package.md","raw":"# Find_package \n\n## **1、find_packakge命令基本介绍** \n\n> ​\t\t在我们实际开发过程中，经常不可避免会使用到第三方开源库，这些开源库可能是通过apt-get install命令自动安装到系统目录中，也可能是由我们自己下载库的源码然后通过编译安装到指令目录下的。\n>\n> ​\t\t不管哪种方式安装的库文件，如果我们需要自己的项目中使用这些库，首先面临的第一个问题就是如何找到这些库。所谓“找到”这些库，其实是根据我们的需要找到指定版本的库头文件包含路径、链接库路径等，从而能够满足我们开发项目的编译链接需要。\n>\n> ​\t\t在没有CMake的时代，这种库查找链接的工作都需要借助MakeFile中的各种命令来完成，非常的繁琐，而且不方便移植，到了CMake时代，CMake给我们提供了find_package()命令用来查找依赖包，理想情况下，一句find_package()命令就能把一整个依赖包的头文件包含路径、库路径、库名字、版本号等情况都获取到，后续只管用就好了。但实际使用过程可能会出现这样那样的问题，因此需要我们对find_package这个强大的命令有个大概的理解。 \n\n## **2、一个使用find_package命令的例子** \n\n为了能够帮助大家理解find_package命令的用法，此处首先用OpenCV库举例子，示范如何通过find_pakcage命令找到OpenCV库并配置，从而能够在我们自己的项目中调用OpenCV库，实现特定的功能。 \n\n**opencv_test.cpp:** \n\n```\n#include <cstdio> \n#include <iostream> \n#include <opencv2/opencv.hpp> \n\nusing namespace cv; \n\nint main() { \n  Mat image; \n  image = imread(\"../opencv_test.jpg\"); \n \n  if (!image.data) { \n    printf(\"No image data\\n\"); \n    return -1; \n  } \n\n  namedWindow(\"Display Image\", CV_WINDOW_AUTOSIZE); \n  imshow(\"Display Image\", image); \n  waitKey(0); \n  return 0; \n} \n```\n\n**CMakeLists.txt:** \n\n```\ncmake_minimum_required(VERSION 2.8) \nproject(find_package_learning) \nfind_package(OpenCV 3 REQUIRED) \n\n \nmessage(STATUS \"OpenCV_DIR = ${OpenCV_DIR}\") \nmessage(STATUS \"OpenCV_INCLUDE_DIRS = ${OpenCV_INCLUDE_DIRS}\") \nmessage(STATUS \"OpenCV_LIBS = ${OpenCV_LIBS}\") \n\n \ninclude_directories(${OPENCV_INCLUDE_DIRS})   \nadd_executable(opencv_test opencv_test.cpp)   \ntarget_link_libraries(opencv_test ${OpenCV_LIBS}) \n```\n\n### **2.1**编译输出与分析\n\n```\n-- The C compiler identification is GNU 7.5.0 \n-- The CXX compiler identification is GNU 7.5.0 \n-- Check for working C compiler: /usr/bin/cc \n-- Check for working C compiler: /usr/bin/cc -- works \n-- Detecting C compiler ABI info \n-- Detecting C compiler ABI info - done \n-- Detecting C compile features \n-- Detecting C compile features - done \n-- Check for working CXX compiler: /usr/bin/c++ \n-- Check for working CXX compiler: /usr/bin/c++ -- works \n-- Detecting CXX compiler ABI info \n-- Detecting CXX compiler ABI info - done \n-- Detecting CXX compile features \n-- Detecting CXX compile features - done \n-- Found OpenCV: /usr/local (found suitable version \"3.4.4\", minimum required is \"3\")  \n-- OpenCV_DIR = /usr/local/share/OpenCV \n-- OpenCV_INCLUDE_DIRS = /usr/local/include;/usr/local/include/opencv \n-- OpenCV_LIBS = opencv_calib3d;opencv_core;opencv_dnn;opencv_features2d;opencv_flann;opencv_highgui;opencv_imgcodecs;opencv_imgproc;opencv_ml;opencv_objdetect;opencv_photo;opencv_shape;opencv_stitching;opencv_superres;opencv_video;opencv_videoio;opencv_videostab;opencv_viz;opencv_aruco;opencv_bgsegm;opencv_bioinspired;opencv_ccalib;opencv_cvv;opencv_datasets;opencv_dnn_objdetect;opencv_dpm;opencv_face;opencv_freetype;opencv_fuzzy;opencv_hdf;opencv_hfs;opencv_img_hash;opencv_line_descriptor;opencv_optflow;opencv_phase_unwrapping;opencv_plot;opencv_reg;opencv_rgbd;opencv_saliency;opencv_stereo;opencv_structured_light;opencv_surface_matching;opencv_text;opencv_tracking;opencv_xfeatures2d;opencv_ximgproc;opencv_xobjdetect;opencv_xphoto \n-- Configuring done \n-- Generating done \n-- Build files have been written to: /home/zhanghm/Programming/programming-learning-examples/cmake_learning/learn_cmake_easily/find_package_learning/build \n```\n\n重点看下其中OpenCV_DIR、OpenCV_INCLUDE_DIRS和OpenCV_LIBS打印的结果，这是我在CMakeLists.txt中用message命令输出这三个变量的值的结果。 \n\n可以看到在执行find_package(OpenCV 3 REQUIRED)命令后，CMake找到了我们安装的位于/usr/local下的OpenCV库，并设置了CMake变量OpenCV_DIR为OpenCV库的配置文件所在路径，正是通过载入这个路径下的OpenCVConfig.cmake配置文件才能配置好OpenCV库，然后在OpenCVConfig.cmake配置文件中定义了变量OpenCV_INCLUDE_DIRS为OpenCV库头文件包含路径，这样我们才能才在代码中使用#include <opencv2/opencv.hpp>而不会出现编译错误，同时定义了变量OpenCV_LIBS为OpenCV链接库路径，这样我们才能正确链接到OpenCV中的库文件，而不会出现类似未定义的引用这样的链接错误。 \n\n![](media/GetImage.png)\n\n通过这个例子就可以看出find_package本质上就是一个搜包的命令，通过一些特定的规则找到<package_name>Config.cmake包配置文件，通过执行该配置文件，从而定义了一系列的变量，通过这些变量就可以准确定位到OpenCV库的头文件和库文件，完成编译。 \n\n那么关键的问题来了，find_package命令是怎么能够定位并载入指定库的配置文件的呢？这就需要梳理一下find_package命令的搜包过程。 \n\n## **3、find_package命令搜包过程** \n\n首先我们需要明确一点，CMake本身不提供任何搜索库的便捷方法，所有搜索库并给变量赋值的操作必须由CMake代码完成，也就是上述中的XXXConfig.cmake以及下面将要提到的FindXXX.cmake配置文件。只不过，库的作者通常会提供这两个文件，以方便使用者调用。\n\n### **3.1 find_package工作模式** \n\nfind_package命令有两种工作模式，这两种工作模式的不同决定了其搜包路径的不同： \n\n`Module模式` \n\nfind_package命令基础工作模式(Basic Signature)，也是默认工作模式。 \n\n`Config模式` \n\nfind_package命令高级工作模式(Full Signature)。 只有在find_package()中指定CONFIG、NO_MODULE等关键字，或者Module模式查找失败后才会进入到Config模式。 \n\n因此find_package工作模式流程图为： \n\n![](media/GetImage(1).png)\n\n### **3.2 Module模式用法** \n\n**Module**模式的参数为：\n\n```\nfind_package(<package> [version] [EXACT] [QUIET] [MODULE] \n             [REQUIRED] [[COMPONENTS] [components...]] \n             [OPTIONAL_COMPONENTS components...] \n             [NO_POLICY_SCOPE]) \n```\n\n参数解释： \n\n`package`：必填参数。需要查找的包名，注意大小写。 \n\n`version`和`EXACT`：可选参数，version指定的是版本，如果指定就必须检查找到的包的版本是否和version兼容。如果指定EXACT则表示必须完全匹配的版本而不是兼容版本就可以。 \n\n`QUIET`：可选参数，表示如果查找失败，不会在屏幕进行输出（但是如果指定了REQUIRED字段，则QUIET无效，仍然会输出查找失败提示语）。 \n\n`MODULE`：可选字段。前面提到说“如果Module模式查找失败则回退到Config模式进行查找”，但是假如加入了MODULE选项，那么就只在Module模式查找，如果Module模式下查找失败并不切换到Config模式查找。 \n\n`REQUIRED`：可选字段。表示一定要找到包，找不到的话就立即停掉整个CMake。而如果不指定REQUIRED则CMake会继续执行。 \n\n`COMPONENTS`，components：可选字段，表示查找的包中必须要找到的组件(components），如果有任何一个找不到就算失败，类似于REQUIRED，导致CMake停止执行。 \n\n**Module模式查找顺序** \n\nModule模式下是要查找到名为Find<PackageName>.cmake的配置文件。 \n\nModule模式只有两个查找路径：`CMAKE_MODULE_PATH`和`CMake安装路径下的Modules目录`， \n\n搜包路径依次为： \n\n```\nCMAKE_MODULE_PATH \nCMAKE_ROOT\n```\n\n先在CMAKE_MODULE_PATH变量对应的路径中查找。如果路径为空，或者路径中查找失败，则在CMake安装目录（即CMAKE_ROOT变量）下的Modules目录下（通常为/usr/share/cmake-3.10/Modules，3.10是我的CMake版本）查找。这两个变量可以在CMakeLists.txt文件中打印查看具体内容： \n\n```\nmessage(STATUS \"CMAKE_MODULE_PATH = ${CMAKE_MODULE_PATH}\") \nmessage(STATUS \"CMAKE_ROOT = ${CMAKE_ROOT}\") \n```\n\n其中**CMAKE_MODULE_PATH**默认为空，可以利用set命令赋值。 \n\n在安装CMake时，CMake为我们提供了很多开发库的FindXXX.cmake模块文件，可以通过命令查询： \n\n```\ncmake --help-module-list | grep -E ^Find \n```\n\n### 3.3 Config模式用法 \n\nConfig模式的完整命令参数为： \n\n```\nfind_package(<package> [version] [EXACT] [QUIET] \n             [REQUIRED] [[COMPONENTS] [components...]] \n             [CONFIG|NO_MODULE] \n             [NO_POLICY_SCOPE] \n             [NAMES name1 [name2 ...]] \n             [CONFIGS config1 [config2 ...]] \n             [HINTS path1 [path2 ... ]] \n             [PATHS path1 [path2 ... ]] \n             [PATH_SUFFIXES suffix1 [suffix2 ...]] \n             [NO_DEFAULT_PATH] \n             [NO_CMAKE_ENVIRONMENT_PATH] \n             [NO_CMAKE_PATH] \n             [NO_SYSTEM_ENVIRONMENT_PATH] \n             [NO_CMAKE_PACKAGE_REGISTRY] \n             [NO_CMAKE_BUILDS_PATH] # Deprecated; does nothing. \n             [NO_CMAKE_SYSTEM_PATH] \n             [NO_CMAKE_SYSTEM_PACKAGE_REGISTRY] \n             [CMAKE_FIND_ROOT_PATH_BOTH | \n              ONLY_CMAKE_FIND_ROOT_PATH | \n              NO_CMAKE_FIND_ROOT_PATH]) \n```\n\n相比于Module模式，Config模式的参数更多，也更复杂，但实际在使用过程中我们并不会用到所有参数，大部分参数都是可选的，我们只需要掌握基本的参数用法即可。 \n\n其中具体查找库并给XXX_INCLUDE_DIRS和XXX_LIBRARIES两个变量赋值的操作由XXXConfig.cmake模块完成。 \n\n两种模式看起来似乎差不多，不过CMake默认采取Module模式，如果Module模式未找到库，才会采取Config模式。如果XXX_DIR路径下找不到XXXConfig.cmake文件，则会找/usr/local/lib/cmake/XXX/中的XXXConfig.cmake文件。总之，Config模式是一个备选策略。通常，库安装时会拷贝一份XXXConfig.cmake到系统目录中，因此在没有显式指定搜索路径时也可以顺利找到。 \n\n#### Config模式查找顺序 \n\nConfig模式下是要查找名为<PackageName>Config.cmake或<lower-case-package-name>-config.cmake的模块文件。  \n\n搜包路径依次为： \n\n与Module模式不同，Config模式需要查找的路径非常多，也要匹配很多的可能性，因此有些路径是首先作为根目录，然后进行子目录的匹配，我会进行说明。  \n\n具体查找顺序为： \n\n1、名为<PackageName>_DIR的CMake变量或环境变量路径 \n\n默认为空。 \n\n这个路径是非根目录路径，需要指定到<PackageName>Config.cmake或<lower-case-package-name>-config.cmake文件所在目录才能找到。 \n\n2、名为CMAKE_PREFIX_PATH、CMAKE_FRAMEWORK_PATH、CMAKE_APPBUNDLE_PATH的CMake变量或环境变量路径 \n\n根目录，默认都为空。 \n\n注意如果你电脑中安装了ROS并配置好之后，你在终端执行echo $CMAKE_PREFIX_PATH会发现ROS会将CMAKE_PREFIX_PATH这个变量设置为ROS中的库的路径，意思是会首先查找ROS安装的库，如果恰好你在ROS中安装了OpenCV库，就会发现首先找到的是ROS中的OpenCV，而不是你自己安装到系统中的OpenCV。 \n\n3、PATH环境变量路径 \n\n根目录，默认为系统环境PATH环境变量值。 \n\n其实这个路径才是Config模式大部分情况下能够查找到安装到系统中各种库的原因。 \n\n这个路径的查找规则为： \n\n遍历PATH环境变量中的各路径，如果该路径如果以bin或sbin结尾，则自动回退到上一级目录得到根目录。例如我的PATH路径包括： \n\n```\n$ echo $PATH \n/home/zhanghm/.local/bin:/usr/local/cuda-10.1/bin:/opt/ros/melodic/bin:/home/zhanghm/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin\n```\n\n在上述指明的是根目录路径时，CMake会首先检查这些根目录路径下是否有名为<PackageName>Config.cmake或<lower-case-package-name>-config.cmake的模块文件，如果没有，CMake会继续检查或匹配这些根目录下的以下路径（<PackageName>_DIR路径不是根目录路径）： \n\n```\n<prefix>/(lib/<arch>|lib|share)/cmake/<name>*/ \n<prefix>/(lib/<arch>|lib|share)/<name>*/  \n<prefix>/(lib/<arch>|lib|share)/<name>*/(cmake|CMake)/\n```\n\n其中为系统架构名，如Ubuntu下一般为：/usr/lib/x86_64-linux-gnu，整个(lib/<arch>|lib|share)为可选路径，例如OpenCV库而言会检查或匹配<prefix>/OpenCV/、<prefix>/lib/x86_64-linux-gnu/OpenCV/、<prefix>/lib/share/OpenCV/、<prefix>/share/OpenCV/等路径；name为包名，不区分大小写<name>*意思是包名后接一些版本后等字符也是合法的，如pcl-1.9也会被找到。\n\n### **3.4 查找指定包建议** \n\n上面的查找规则整体看起来好像很复杂，但其实我们在安装库的时候都会自动配置安装到对的位置，一般都不会出现问题。如果我们需要指定特定的库，我们也只需要设置优先级最高的几个变量名即可。包括下面两种情况： \n\n1、如果你明确知道想要查找的库<PackageName>Config.cmake或<lower-case-package-name>-config.cmake文件所在路径，为了能够准确定位到这个包，可以直接设置变量<PackageName>_DIR为具体路径，如： \n\n```\nset(OpenCV_DIR \"/home/zhanghm/Softwares/enviroment_config/opencv3_4_4/opencv/build\") \n```\n\n就可以明确需要查找的OpenCV包的路径了。 \n\n2、如果你有多个包的配置文件需要查找，可以将这些配置文件都统一放在一个命名为cmake的文件夹下，然后设置变量CMAKE_PREFIX_PATH变量指向这个cmake文件夹路径，需要注意根据上述的匹配规则，此时每个包的配置文件需要单独放置在命名为包名的文件夹下（文件夹名不区分大小写），否则会提示找不到。 \n\n## **4、总结** \n\n通过前面的描述，我相信大家已经能够基本掌握find_package命令的各种用法了，也能够在出现各种问题时自己进行问题定位。但还有一个我们需要注意的点是我们能够在自己的项目中使用find_package命令便捷进行依赖包配置的前提是这个包的开发者也是用CMake配置好了这个包，并提供了<PackageName>Config.cmake或Find<PackageName>.cmake的配置文件。 \n\n## **参考** \n\nhttps://blog.csdn.net/zhanghm1995/article/details/105466372 \n\nhttps://cmake.org/cmake/help/v3.5/command/find_package.html （官网介绍） \n\nhttps://zhuanlan.zhihu.com/p/50829542 \n\nhttps://seanzhengw.github.io/blog/cmake/2018/04/23/cmake-find-package.html \n\nhttps://blog.csdn.net/bytxl/article/details/50637277 ","slug":"C++/Find_package","published":1,"date":"2023-08-24T14:38:18.623Z","updated":"2022-12-30T03:13:44.815Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0t80007dkr74xopbc12","content":"<h1 id=\"Find-package\"><a href=\"#Find-package\" class=\"headerlink\" title=\"Find_package\"></a>Find_package</h1><h2 id=\"1、find-packakge命令基本介绍\"><a href=\"#1、find-packakge命令基本介绍\" class=\"headerlink\" title=\"1、find_packakge命令基本介绍\"></a><strong>1、find_packakge命令基本介绍</strong></h2><blockquote>\n<p>​\t\t在我们实际开发过程中，经常不可避免会使用到第三方开源库，这些开源库可能是通过apt-get install命令自动安装到系统目录中，也可能是由我们自己下载库的源码然后通过编译安装到指令目录下的。</p>\n<p>​\t\t不管哪种方式安装的库文件，如果我们需要自己的项目中使用这些库，首先面临的第一个问题就是如何找到这些库。所谓“找到”这些库，其实是根据我们的需要找到指定版本的库头文件包含路径、链接库路径等，从而能够满足我们开发项目的编译链接需要。</p>\n<p>​\t\t在没有CMake的时代，这种库查找链接的工作都需要借助MakeFile中的各种命令来完成，非常的繁琐，而且不方便移植，到了CMake时代，CMake给我们提供了find_package()命令用来查找依赖包，理想情况下，一句find_package()命令就能把一整个依赖包的头文件包含路径、库路径、库名字、版本号等情况都获取到，后续只管用就好了。但实际使用过程可能会出现这样那样的问题，因此需要我们对find_package这个强大的命令有个大概的理解。 </p>\n</blockquote>\n<h2 id=\"2、一个使用find-package命令的例子\"><a href=\"#2、一个使用find-package命令的例子\" class=\"headerlink\" title=\"2、一个使用find_package命令的例子\"></a><strong>2、一个使用find_package命令的例子</strong></h2><p>为了能够帮助大家理解find_package命令的用法，此处首先用OpenCV库举例子，示范如何通过find_pakcage命令找到OpenCV库并配置，从而能够在我们自己的项目中调用OpenCV库，实现特定的功能。 </p>\n<p><strong>opencv_test.cpp:</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;cstdio&gt; </span><br><span class=\"line\">#include &lt;iostream&gt; </span><br><span class=\"line\">#include &lt;opencv2/opencv.hpp&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">using namespace cv; </span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123; </span><br><span class=\"line\">  Mat image; </span><br><span class=\"line\">  image = imread(&quot;../opencv_test.jpg&quot;); </span><br><span class=\"line\"> </span><br><span class=\"line\">  if (!image.data) &#123; </span><br><span class=\"line\">    printf(&quot;No image data\\n&quot;); </span><br><span class=\"line\">    return -1; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">  namedWindow(&quot;Display Image&quot;, CV_WINDOW_AUTOSIZE); </span><br><span class=\"line\">  imshow(&quot;Display Image&quot;, image); </span><br><span class=\"line\">  waitKey(0); </span><br><span class=\"line\">  return 0; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p><strong>CMakeLists.txt:</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake_minimum_required(VERSION 2.8) </span><br><span class=\"line\">project(find_package_learning) </span><br><span class=\"line\">find_package(OpenCV 3 REQUIRED) </span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">message(STATUS &quot;OpenCV_DIR = $&#123;OpenCV_DIR&#125;&quot;) </span><br><span class=\"line\">message(STATUS &quot;OpenCV_INCLUDE_DIRS = $&#123;OpenCV_INCLUDE_DIRS&#125;&quot;) </span><br><span class=\"line\">message(STATUS &quot;OpenCV_LIBS = $&#123;OpenCV_LIBS&#125;&quot;) </span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">include_directories($&#123;OPENCV_INCLUDE_DIRS&#125;)   </span><br><span class=\"line\">add_executable(opencv_test opencv_test.cpp)   </span><br><span class=\"line\">target_link_libraries(opencv_test $&#123;OpenCV_LIBS&#125;) </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1编译输出与分析\"><a href=\"#2-1编译输出与分析\" class=\"headerlink\" title=\"2.1编译输出与分析\"></a><strong>2.1</strong>编译输出与分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- The C compiler identification is GNU 7.5.0 </span><br><span class=\"line\">-- The CXX compiler identification is GNU 7.5.0 </span><br><span class=\"line\">-- Check for working C compiler: /usr/bin/cc </span><br><span class=\"line\">-- Check for working C compiler: /usr/bin/cc -- works </span><br><span class=\"line\">-- Detecting C compiler ABI info </span><br><span class=\"line\">-- Detecting C compiler ABI info - done </span><br><span class=\"line\">-- Detecting C compile features </span><br><span class=\"line\">-- Detecting C compile features - done </span><br><span class=\"line\">-- Check for working CXX compiler: /usr/bin/c++ </span><br><span class=\"line\">-- Check for working CXX compiler: /usr/bin/c++ -- works </span><br><span class=\"line\">-- Detecting CXX compiler ABI info </span><br><span class=\"line\">-- Detecting CXX compiler ABI info - done </span><br><span class=\"line\">-- Detecting CXX compile features </span><br><span class=\"line\">-- Detecting CXX compile features - done </span><br><span class=\"line\">-- Found OpenCV: /usr/local (found suitable version &quot;3.4.4&quot;, minimum required is &quot;3&quot;)  </span><br><span class=\"line\">-- OpenCV_DIR = /usr/local/share/OpenCV </span><br><span class=\"line\">-- OpenCV_INCLUDE_DIRS = /usr/local/include;/usr/local/include/opencv </span><br><span class=\"line\">-- OpenCV_LIBS = opencv_calib3d;opencv_core;opencv_dnn;opencv_features2d;opencv_flann;opencv_highgui;opencv_imgcodecs;opencv_imgproc;opencv_ml;opencv_objdetect;opencv_photo;opencv_shape;opencv_stitching;opencv_superres;opencv_video;opencv_videoio;opencv_videostab;opencv_viz;opencv_aruco;opencv_bgsegm;opencv_bioinspired;opencv_ccalib;opencv_cvv;opencv_datasets;opencv_dnn_objdetect;opencv_dpm;opencv_face;opencv_freetype;opencv_fuzzy;opencv_hdf;opencv_hfs;opencv_img_hash;opencv_line_descriptor;opencv_optflow;opencv_phase_unwrapping;opencv_plot;opencv_reg;opencv_rgbd;opencv_saliency;opencv_stereo;opencv_structured_light;opencv_surface_matching;opencv_text;opencv_tracking;opencv_xfeatures2d;opencv_ximgproc;opencv_xobjdetect;opencv_xphoto </span><br><span class=\"line\">-- Configuring done </span><br><span class=\"line\">-- Generating done </span><br><span class=\"line\">-- Build files have been written to: /home/zhanghm/Programming/programming-learning-examples/cmake_learning/learn_cmake_easily/find_package_learning/build </span><br></pre></td></tr></table></figure>\n\n<p>重点看下其中OpenCV_DIR、OpenCV_INCLUDE_DIRS和OpenCV_LIBS打印的结果，这是我在CMakeLists.txt中用message命令输出这三个变量的值的结果。 </p>\n<p>可以看到在执行find_package(OpenCV 3 REQUIRED)命令后，CMake找到了我们安装的位于&#x2F;usr&#x2F;local下的OpenCV库，并设置了CMake变量OpenCV_DIR为OpenCV库的配置文件所在路径，正是通过载入这个路径下的OpenCVConfig.cmake配置文件才能配置好OpenCV库，然后在OpenCVConfig.cmake配置文件中定义了变量OpenCV_INCLUDE_DIRS为OpenCV库头文件包含路径，这样我们才能才在代码中使用#include &lt;opencv2&#x2F;opencv.hpp&gt;而不会出现编译错误，同时定义了变量OpenCV_LIBS为OpenCV链接库路径，这样我们才能正确链接到OpenCV中的库文件，而不会出现类似未定义的引用这样的链接错误。 </p>\n<p><img src=\"/media/GetImage.png\"></p>\n<p>通过这个例子就可以看出find_package本质上就是一个搜包的命令，通过一些特定的规则找到<package_name>Config.cmake包配置文件，通过执行该配置文件，从而定义了一系列的变量，通过这些变量就可以准确定位到OpenCV库的头文件和库文件，完成编译。 </p>\n<p>那么关键的问题来了，find_package命令是怎么能够定位并载入指定库的配置文件的呢？这就需要梳理一下find_package命令的搜包过程。 </p>\n<h2 id=\"3、find-package命令搜包过程\"><a href=\"#3、find-package命令搜包过程\" class=\"headerlink\" title=\"3、find_package命令搜包过程\"></a><strong>3、find_package命令搜包过程</strong></h2><p>首先我们需要明确一点，CMake本身不提供任何搜索库的便捷方法，所有搜索库并给变量赋值的操作必须由CMake代码完成，也就是上述中的XXXConfig.cmake以及下面将要提到的FindXXX.cmake配置文件。只不过，库的作者通常会提供这两个文件，以方便使用者调用。</p>\n<h3 id=\"3-1-find-package工作模式\"><a href=\"#3-1-find-package工作模式\" class=\"headerlink\" title=\"3.1 find_package工作模式\"></a><strong>3.1 find_package工作模式</strong></h3><p>find_package命令有两种工作模式，这两种工作模式的不同决定了其搜包路径的不同： </p>\n<p><code>Module模式</code> </p>\n<p>find_package命令基础工作模式(Basic Signature)，也是默认工作模式。 </p>\n<p><code>Config模式</code> </p>\n<p>find_package命令高级工作模式(Full Signature)。 只有在find_package()中指定CONFIG、NO_MODULE等关键字，或者Module模式查找失败后才会进入到Config模式。 </p>\n<p>因此find_package工作模式流程图为： </p>\n<p><img src=\"/media/GetImage(1).png\"></p>\n<h3 id=\"3-2-Module模式用法\"><a href=\"#3-2-Module模式用法\" class=\"headerlink\" title=\"3.2 Module模式用法\"></a><strong>3.2 Module模式用法</strong></h3><p><strong>Module</strong>模式的参数为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find_package(&lt;package&gt; [version] [EXACT] [QUIET] [MODULE] </span><br><span class=\"line\">             [REQUIRED] [[COMPONENTS] [components...]] </span><br><span class=\"line\">             [OPTIONAL_COMPONENTS components...] </span><br><span class=\"line\">             [NO_POLICY_SCOPE]) </span><br></pre></td></tr></table></figure>\n\n<p>参数解释： </p>\n<p><code>package</code>：必填参数。需要查找的包名，注意大小写。 </p>\n<p><code>version</code>和<code>EXACT</code>：可选参数，version指定的是版本，如果指定就必须检查找到的包的版本是否和version兼容。如果指定EXACT则表示必须完全匹配的版本而不是兼容版本就可以。 </p>\n<p><code>QUIET</code>：可选参数，表示如果查找失败，不会在屏幕进行输出（但是如果指定了REQUIRED字段，则QUIET无效，仍然会输出查找失败提示语）。 </p>\n<p><code>MODULE</code>：可选字段。前面提到说“如果Module模式查找失败则回退到Config模式进行查找”，但是假如加入了MODULE选项，那么就只在Module模式查找，如果Module模式下查找失败并不切换到Config模式查找。 </p>\n<p><code>REQUIRED</code>：可选字段。表示一定要找到包，找不到的话就立即停掉整个CMake。而如果不指定REQUIRED则CMake会继续执行。 </p>\n<p><code>COMPONENTS</code>，components：可选字段，表示查找的包中必须要找到的组件(components），如果有任何一个找不到就算失败，类似于REQUIRED，导致CMake停止执行。 </p>\n<p><strong>Module模式查找顺序</strong> </p>\n<p>Module模式下是要查找到名为Find<PackageName>.cmake的配置文件。 </p>\n<p>Module模式只有两个查找路径：<code>CMAKE_MODULE_PATH</code>和<code>CMake安装路径下的Modules目录</code>， </p>\n<p>搜包路径依次为： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMAKE_MODULE_PATH </span><br><span class=\"line\">CMAKE_ROOT</span><br></pre></td></tr></table></figure>\n\n<p>先在CMAKE_MODULE_PATH变量对应的路径中查找。如果路径为空，或者路径中查找失败，则在CMake安装目录（即CMAKE_ROOT变量）下的Modules目录下（通常为&#x2F;usr&#x2F;share&#x2F;cmake-3.10&#x2F;Modules，3.10是我的CMake版本）查找。这两个变量可以在CMakeLists.txt文件中打印查看具体内容： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message(STATUS &quot;CMAKE_MODULE_PATH = $&#123;CMAKE_MODULE_PATH&#125;&quot;) </span><br><span class=\"line\">message(STATUS &quot;CMAKE_ROOT = $&#123;CMAKE_ROOT&#125;&quot;) </span><br></pre></td></tr></table></figure>\n\n<p>其中<strong>CMAKE_MODULE_PATH</strong>默认为空，可以利用set命令赋值。 </p>\n<p>在安装CMake时，CMake为我们提供了很多开发库的FindXXX.cmake模块文件，可以通过命令查询： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake --help-module-list | grep -E ^Find </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-Config模式用法\"><a href=\"#3-3-Config模式用法\" class=\"headerlink\" title=\"3.3 Config模式用法\"></a>3.3 Config模式用法</h3><p>Config模式的完整命令参数为： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find_package(&lt;package&gt; [version] [EXACT] [QUIET] </span><br><span class=\"line\">             [REQUIRED] [[COMPONENTS] [components...]] </span><br><span class=\"line\">             [CONFIG|NO_MODULE] </span><br><span class=\"line\">             [NO_POLICY_SCOPE] </span><br><span class=\"line\">             [NAMES name1 [name2 ...]] </span><br><span class=\"line\">             [CONFIGS config1 [config2 ...]] </span><br><span class=\"line\">             [HINTS path1 [path2 ... ]] </span><br><span class=\"line\">             [PATHS path1 [path2 ... ]] </span><br><span class=\"line\">             [PATH_SUFFIXES suffix1 [suffix2 ...]] </span><br><span class=\"line\">             [NO_DEFAULT_PATH] </span><br><span class=\"line\">             [NO_CMAKE_ENVIRONMENT_PATH] </span><br><span class=\"line\">             [NO_CMAKE_PATH] </span><br><span class=\"line\">             [NO_SYSTEM_ENVIRONMENT_PATH] </span><br><span class=\"line\">             [NO_CMAKE_PACKAGE_REGISTRY] </span><br><span class=\"line\">             [NO_CMAKE_BUILDS_PATH] # Deprecated; does nothing. </span><br><span class=\"line\">             [NO_CMAKE_SYSTEM_PATH] </span><br><span class=\"line\">             [NO_CMAKE_SYSTEM_PACKAGE_REGISTRY] </span><br><span class=\"line\">             [CMAKE_FIND_ROOT_PATH_BOTH | </span><br><span class=\"line\">              ONLY_CMAKE_FIND_ROOT_PATH | </span><br><span class=\"line\">              NO_CMAKE_FIND_ROOT_PATH]) </span><br></pre></td></tr></table></figure>\n\n<p>相比于Module模式，Config模式的参数更多，也更复杂，但实际在使用过程中我们并不会用到所有参数，大部分参数都是可选的，我们只需要掌握基本的参数用法即可。 </p>\n<p>其中具体查找库并给XXX_INCLUDE_DIRS和XXX_LIBRARIES两个变量赋值的操作由XXXConfig.cmake模块完成。 </p>\n<p>两种模式看起来似乎差不多，不过CMake默认采取Module模式，如果Module模式未找到库，才会采取Config模式。如果XXX_DIR路径下找不到XXXConfig.cmake文件，则会找&#x2F;usr&#x2F;local&#x2F;lib&#x2F;cmake&#x2F;XXX&#x2F;中的XXXConfig.cmake文件。总之，Config模式是一个备选策略。通常，库安装时会拷贝一份XXXConfig.cmake到系统目录中，因此在没有显式指定搜索路径时也可以顺利找到。 </p>\n<h4 id=\"Config模式查找顺序\"><a href=\"#Config模式查找顺序\" class=\"headerlink\" title=\"Config模式查找顺序\"></a>Config模式查找顺序</h4><p>Config模式下是要查找名为<PackageName>Config.cmake或<lower-case-package-name>-config.cmake的模块文件。  </p>\n<p>搜包路径依次为： </p>\n<p>与Module模式不同，Config模式需要查找的路径非常多，也要匹配很多的可能性，因此有些路径是首先作为根目录，然后进行子目录的匹配，我会进行说明。  </p>\n<p>具体查找顺序为： </p>\n<p>1、名为<PackageName>_DIR的CMake变量或环境变量路径 </p>\n<p>默认为空。 </p>\n<p>这个路径是非根目录路径，需要指定到<PackageName>Config.cmake或<lower-case-package-name>-config.cmake文件所在目录才能找到。 </p>\n<p>2、名为CMAKE_PREFIX_PATH、CMAKE_FRAMEWORK_PATH、CMAKE_APPBUNDLE_PATH的CMake变量或环境变量路径 </p>\n<p>根目录，默认都为空。 </p>\n<p>注意如果你电脑中安装了ROS并配置好之后，你在终端执行echo $CMAKE_PREFIX_PATH会发现ROS会将CMAKE_PREFIX_PATH这个变量设置为ROS中的库的路径，意思是会首先查找ROS安装的库，如果恰好你在ROS中安装了OpenCV库，就会发现首先找到的是ROS中的OpenCV，而不是你自己安装到系统中的OpenCV。 </p>\n<p>3、PATH环境变量路径 </p>\n<p>根目录，默认为系统环境PATH环境变量值。 </p>\n<p>其实这个路径才是Config模式大部分情况下能够查找到安装到系统中各种库的原因。 </p>\n<p>这个路径的查找规则为： </p>\n<p>遍历PATH环境变量中的各路径，如果该路径如果以bin或sbin结尾，则自动回退到上一级目录得到根目录。例如我的PATH路径包括： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo $PATH </span><br><span class=\"line\">/home/zhanghm/.local/bin:/usr/local/cuda-10.1/bin:/opt/ros/melodic/bin:/home/zhanghm/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure>\n\n<p>在上述指明的是根目录路径时，CMake会首先检查这些根目录路径下是否有名为<PackageName>Config.cmake或<lower-case-package-name>-config.cmake的模块文件，如果没有，CMake会继续检查或匹配这些根目录下的以下路径（<PackageName>_DIR路径不是根目录路径）： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;prefix&gt;/(lib/&lt;arch&gt;|lib|share)/cmake/&lt;name&gt;*/ </span><br><span class=\"line\">&lt;prefix&gt;/(lib/&lt;arch&gt;|lib|share)/&lt;name&gt;*/  </span><br><span class=\"line\">&lt;prefix&gt;/(lib/&lt;arch&gt;|lib|share)/&lt;name&gt;*/(cmake|CMake)/</span><br></pre></td></tr></table></figure>\n\n<p>其中为系统架构名，如Ubuntu下一般为：&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu，整个(lib&#x2F;<arch>|lib|share)为可选路径，例如OpenCV库而言会检查或匹配<prefix>&#x2F;OpenCV&#x2F;、<prefix>&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;OpenCV&#x2F;、<prefix>&#x2F;lib&#x2F;share&#x2F;OpenCV&#x2F;、<prefix>&#x2F;share&#x2F;OpenCV&#x2F;等路径；name为包名，不区分大小写<name>*意思是包名后接一些版本后等字符也是合法的，如pcl-1.9也会被找到。</p>\n<h3 id=\"3-4-查找指定包建议\"><a href=\"#3-4-查找指定包建议\" class=\"headerlink\" title=\"3.4 查找指定包建议\"></a><strong>3.4 查找指定包建议</strong></h3><p>上面的查找规则整体看起来好像很复杂，但其实我们在安装库的时候都会自动配置安装到对的位置，一般都不会出现问题。如果我们需要指定特定的库，我们也只需要设置优先级最高的几个变量名即可。包括下面两种情况： </p>\n<p>1、如果你明确知道想要查找的库<PackageName>Config.cmake或<lower-case-package-name>-config.cmake文件所在路径，为了能够准确定位到这个包，可以直接设置变量<PackageName>_DIR为具体路径，如： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set(OpenCV_DIR &quot;/home/zhanghm/Softwares/enviroment_config/opencv3_4_4/opencv/build&quot;) </span><br></pre></td></tr></table></figure>\n\n<p>就可以明确需要查找的OpenCV包的路径了。 </p>\n<p>2、如果你有多个包的配置文件需要查找，可以将这些配置文件都统一放在一个命名为cmake的文件夹下，然后设置变量CMAKE_PREFIX_PATH变量指向这个cmake文件夹路径，需要注意根据上述的匹配规则，此时每个包的配置文件需要单独放置在命名为包名的文件夹下（文件夹名不区分大小写），否则会提示找不到。 </p>\n<h2 id=\"4、总结\"><a href=\"#4、总结\" class=\"headerlink\" title=\"4、总结\"></a><strong>4、总结</strong></h2><p>通过前面的描述，我相信大家已经能够基本掌握find_package命令的各种用法了，也能够在出现各种问题时自己进行问题定位。但还有一个我们需要注意的点是我们能够在自己的项目中使用find_package命令便捷进行依赖包配置的前提是这个包的开发者也是用CMake配置好了这个包，并提供了<PackageName>Config.cmake或Find<PackageName>.cmake的配置文件。 </p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"https://blog.csdn.net/zhanghm1995/article/details/105466372\">https://blog.csdn.net/zhanghm1995/article/details/105466372</a> </p>\n<p><a href=\"https://cmake.org/cmake/help/v3.5/command/find_package.html\">https://cmake.org/cmake/help/v3.5/command/find_package.html</a> （官网介绍） </p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/50829542\">https://zhuanlan.zhihu.com/p/50829542</a> </p>\n<p><a href=\"https://seanzhengw.github.io/blog/cmake/2018/04/23/cmake-find-package.html\">https://seanzhengw.github.io/blog/cmake/2018/04/23/cmake-find-package.html</a> </p>\n<p><a href=\"https://blog.csdn.net/bytxl/article/details/50637277\">https://blog.csdn.net/bytxl/article/details/50637277</a> </p>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-7.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Find-package\"><a href=\"#Find-package\" class=\"headerlink\" title=\"Find_package\"></a>Find_package</h1><h2 id=\"1、find-packakge命令基本介绍\"><a href=\"#1、find-packakge命令基本介绍\" class=\"headerlink\" title=\"1、find_packakge命令基本介绍\"></a><strong>1、find_packakge命令基本介绍</strong></h2><blockquote>\n<p>​\t\t在我们实际开发过程中，经常不可避免会使用到第三方开源库，这些开源库可能是通过apt-get install命令自动安装到系统目录中，也可能是由我们自己下载库的源码然后通过编译安装到指令目录下的。</p>\n<p>​\t\t不管哪种方式安装的库文件，如果我们需要自己的项目中使用这些库，首先面临的第一个问题就是如何找到这些库。所谓“找到”这些库，其实是根据我们的需要找到指定版本的库头文件包含路径、链接库路径等，从而能够满足我们开发项目的编译链接需要。</p>\n<p>​\t\t在没有CMake的时代，这种库查找链接的工作都需要借助MakeFile中的各种命令来完成，非常的繁琐，而且不方便移植，到了CMake时代，CMake给我们提供了find_package()命令用来查找依赖包，理想情况下，一句find_package()命令就能把一整个依赖包的头文件包含路径、库路径、库名字、版本号等情况都获取到，后续只管用就好了。但实际使用过程可能会出现这样那样的问题，因此需要我们对find_package这个强大的命令有个大概的理解。 </p>\n</blockquote>\n<h2 id=\"2、一个使用find-package命令的例子\"><a href=\"#2、一个使用find-package命令的例子\" class=\"headerlink\" title=\"2、一个使用find_package命令的例子\"></a><strong>2、一个使用find_package命令的例子</strong></h2><p>为了能够帮助大家理解find_package命令的用法，此处首先用OpenCV库举例子，示范如何通过find_pakcage命令找到OpenCV库并配置，从而能够在我们自己的项目中调用OpenCV库，实现特定的功能。 </p>\n<p><strong>opencv_test.cpp:</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;cstdio&gt; </span><br><span class=\"line\">#include &lt;iostream&gt; </span><br><span class=\"line\">#include &lt;opencv2/opencv.hpp&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">using namespace cv; </span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123; </span><br><span class=\"line\">  Mat image; </span><br><span class=\"line\">  image = imread(&quot;../opencv_test.jpg&quot;); </span><br><span class=\"line\"> </span><br><span class=\"line\">  if (!image.data) &#123; </span><br><span class=\"line\">    printf(&quot;No image data\\n&quot;); </span><br><span class=\"line\">    return -1; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">  namedWindow(&quot;Display Image&quot;, CV_WINDOW_AUTOSIZE); </span><br><span class=\"line\">  imshow(&quot;Display Image&quot;, image); </span><br><span class=\"line\">  waitKey(0); </span><br><span class=\"line\">  return 0; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p><strong>CMakeLists.txt:</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake_minimum_required(VERSION 2.8) </span><br><span class=\"line\">project(find_package_learning) </span><br><span class=\"line\">find_package(OpenCV 3 REQUIRED) </span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">message(STATUS &quot;OpenCV_DIR = $&#123;OpenCV_DIR&#125;&quot;) </span><br><span class=\"line\">message(STATUS &quot;OpenCV_INCLUDE_DIRS = $&#123;OpenCV_INCLUDE_DIRS&#125;&quot;) </span><br><span class=\"line\">message(STATUS &quot;OpenCV_LIBS = $&#123;OpenCV_LIBS&#125;&quot;) </span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">include_directories($&#123;OPENCV_INCLUDE_DIRS&#125;)   </span><br><span class=\"line\">add_executable(opencv_test opencv_test.cpp)   </span><br><span class=\"line\">target_link_libraries(opencv_test $&#123;OpenCV_LIBS&#125;) </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1编译输出与分析\"><a href=\"#2-1编译输出与分析\" class=\"headerlink\" title=\"2.1编译输出与分析\"></a><strong>2.1</strong>编译输出与分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- The C compiler identification is GNU 7.5.0 </span><br><span class=\"line\">-- The CXX compiler identification is GNU 7.5.0 </span><br><span class=\"line\">-- Check for working C compiler: /usr/bin/cc </span><br><span class=\"line\">-- Check for working C compiler: /usr/bin/cc -- works </span><br><span class=\"line\">-- Detecting C compiler ABI info </span><br><span class=\"line\">-- Detecting C compiler ABI info - done </span><br><span class=\"line\">-- Detecting C compile features </span><br><span class=\"line\">-- Detecting C compile features - done </span><br><span class=\"line\">-- Check for working CXX compiler: /usr/bin/c++ </span><br><span class=\"line\">-- Check for working CXX compiler: /usr/bin/c++ -- works </span><br><span class=\"line\">-- Detecting CXX compiler ABI info </span><br><span class=\"line\">-- Detecting CXX compiler ABI info - done </span><br><span class=\"line\">-- Detecting CXX compile features </span><br><span class=\"line\">-- Detecting CXX compile features - done </span><br><span class=\"line\">-- Found OpenCV: /usr/local (found suitable version &quot;3.4.4&quot;, minimum required is &quot;3&quot;)  </span><br><span class=\"line\">-- OpenCV_DIR = /usr/local/share/OpenCV </span><br><span class=\"line\">-- OpenCV_INCLUDE_DIRS = /usr/local/include;/usr/local/include/opencv </span><br><span class=\"line\">-- OpenCV_LIBS = opencv_calib3d;opencv_core;opencv_dnn;opencv_features2d;opencv_flann;opencv_highgui;opencv_imgcodecs;opencv_imgproc;opencv_ml;opencv_objdetect;opencv_photo;opencv_shape;opencv_stitching;opencv_superres;opencv_video;opencv_videoio;opencv_videostab;opencv_viz;opencv_aruco;opencv_bgsegm;opencv_bioinspired;opencv_ccalib;opencv_cvv;opencv_datasets;opencv_dnn_objdetect;opencv_dpm;opencv_face;opencv_freetype;opencv_fuzzy;opencv_hdf;opencv_hfs;opencv_img_hash;opencv_line_descriptor;opencv_optflow;opencv_phase_unwrapping;opencv_plot;opencv_reg;opencv_rgbd;opencv_saliency;opencv_stereo;opencv_structured_light;opencv_surface_matching;opencv_text;opencv_tracking;opencv_xfeatures2d;opencv_ximgproc;opencv_xobjdetect;opencv_xphoto </span><br><span class=\"line\">-- Configuring done </span><br><span class=\"line\">-- Generating done </span><br><span class=\"line\">-- Build files have been written to: /home/zhanghm/Programming/programming-learning-examples/cmake_learning/learn_cmake_easily/find_package_learning/build </span><br></pre></td></tr></table></figure>\n\n<p>重点看下其中OpenCV_DIR、OpenCV_INCLUDE_DIRS和OpenCV_LIBS打印的结果，这是我在CMakeLists.txt中用message命令输出这三个变量的值的结果。 </p>\n<p>可以看到在执行find_package(OpenCV 3 REQUIRED)命令后，CMake找到了我们安装的位于&#x2F;usr&#x2F;local下的OpenCV库，并设置了CMake变量OpenCV_DIR为OpenCV库的配置文件所在路径，正是通过载入这个路径下的OpenCVConfig.cmake配置文件才能配置好OpenCV库，然后在OpenCVConfig.cmake配置文件中定义了变量OpenCV_INCLUDE_DIRS为OpenCV库头文件包含路径，这样我们才能才在代码中使用#include &lt;opencv2&#x2F;opencv.hpp&gt;而不会出现编译错误，同时定义了变量OpenCV_LIBS为OpenCV链接库路径，这样我们才能正确链接到OpenCV中的库文件，而不会出现类似未定义的引用这样的链接错误。 </p>\n<p><img src=\"/media/GetImage.png\"></p>\n<p>通过这个例子就可以看出find_package本质上就是一个搜包的命令，通过一些特定的规则找到<package_name>Config.cmake包配置文件，通过执行该配置文件，从而定义了一系列的变量，通过这些变量就可以准确定位到OpenCV库的头文件和库文件，完成编译。 </p>\n<p>那么关键的问题来了，find_package命令是怎么能够定位并载入指定库的配置文件的呢？这就需要梳理一下find_package命令的搜包过程。 </p>\n<h2 id=\"3、find-package命令搜包过程\"><a href=\"#3、find-package命令搜包过程\" class=\"headerlink\" title=\"3、find_package命令搜包过程\"></a><strong>3、find_package命令搜包过程</strong></h2><p>首先我们需要明确一点，CMake本身不提供任何搜索库的便捷方法，所有搜索库并给变量赋值的操作必须由CMake代码完成，也就是上述中的XXXConfig.cmake以及下面将要提到的FindXXX.cmake配置文件。只不过，库的作者通常会提供这两个文件，以方便使用者调用。</p>\n<h3 id=\"3-1-find-package工作模式\"><a href=\"#3-1-find-package工作模式\" class=\"headerlink\" title=\"3.1 find_package工作模式\"></a><strong>3.1 find_package工作模式</strong></h3><p>find_package命令有两种工作模式，这两种工作模式的不同决定了其搜包路径的不同： </p>\n<p><code>Module模式</code> </p>\n<p>find_package命令基础工作模式(Basic Signature)，也是默认工作模式。 </p>\n<p><code>Config模式</code> </p>\n<p>find_package命令高级工作模式(Full Signature)。 只有在find_package()中指定CONFIG、NO_MODULE等关键字，或者Module模式查找失败后才会进入到Config模式。 </p>\n<p>因此find_package工作模式流程图为： </p>\n<p><img src=\"/media/GetImage(1).png\"></p>\n<h3 id=\"3-2-Module模式用法\"><a href=\"#3-2-Module模式用法\" class=\"headerlink\" title=\"3.2 Module模式用法\"></a><strong>3.2 Module模式用法</strong></h3><p><strong>Module</strong>模式的参数为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find_package(&lt;package&gt; [version] [EXACT] [QUIET] [MODULE] </span><br><span class=\"line\">             [REQUIRED] [[COMPONENTS] [components...]] </span><br><span class=\"line\">             [OPTIONAL_COMPONENTS components...] </span><br><span class=\"line\">             [NO_POLICY_SCOPE]) </span><br></pre></td></tr></table></figure>\n\n<p>参数解释： </p>\n<p><code>package</code>：必填参数。需要查找的包名，注意大小写。 </p>\n<p><code>version</code>和<code>EXACT</code>：可选参数，version指定的是版本，如果指定就必须检查找到的包的版本是否和version兼容。如果指定EXACT则表示必须完全匹配的版本而不是兼容版本就可以。 </p>\n<p><code>QUIET</code>：可选参数，表示如果查找失败，不会在屏幕进行输出（但是如果指定了REQUIRED字段，则QUIET无效，仍然会输出查找失败提示语）。 </p>\n<p><code>MODULE</code>：可选字段。前面提到说“如果Module模式查找失败则回退到Config模式进行查找”，但是假如加入了MODULE选项，那么就只在Module模式查找，如果Module模式下查找失败并不切换到Config模式查找。 </p>\n<p><code>REQUIRED</code>：可选字段。表示一定要找到包，找不到的话就立即停掉整个CMake。而如果不指定REQUIRED则CMake会继续执行。 </p>\n<p><code>COMPONENTS</code>，components：可选字段，表示查找的包中必须要找到的组件(components），如果有任何一个找不到就算失败，类似于REQUIRED，导致CMake停止执行。 </p>\n<p><strong>Module模式查找顺序</strong> </p>\n<p>Module模式下是要查找到名为Find<PackageName>.cmake的配置文件。 </p>\n<p>Module模式只有两个查找路径：<code>CMAKE_MODULE_PATH</code>和<code>CMake安装路径下的Modules目录</code>， </p>\n<p>搜包路径依次为： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMAKE_MODULE_PATH </span><br><span class=\"line\">CMAKE_ROOT</span><br></pre></td></tr></table></figure>\n\n<p>先在CMAKE_MODULE_PATH变量对应的路径中查找。如果路径为空，或者路径中查找失败，则在CMake安装目录（即CMAKE_ROOT变量）下的Modules目录下（通常为&#x2F;usr&#x2F;share&#x2F;cmake-3.10&#x2F;Modules，3.10是我的CMake版本）查找。这两个变量可以在CMakeLists.txt文件中打印查看具体内容： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message(STATUS &quot;CMAKE_MODULE_PATH = $&#123;CMAKE_MODULE_PATH&#125;&quot;) </span><br><span class=\"line\">message(STATUS &quot;CMAKE_ROOT = $&#123;CMAKE_ROOT&#125;&quot;) </span><br></pre></td></tr></table></figure>\n\n<p>其中<strong>CMAKE_MODULE_PATH</strong>默认为空，可以利用set命令赋值。 </p>\n<p>在安装CMake时，CMake为我们提供了很多开发库的FindXXX.cmake模块文件，可以通过命令查询： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake --help-module-list | grep -E ^Find </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-Config模式用法\"><a href=\"#3-3-Config模式用法\" class=\"headerlink\" title=\"3.3 Config模式用法\"></a>3.3 Config模式用法</h3><p>Config模式的完整命令参数为： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find_package(&lt;package&gt; [version] [EXACT] [QUIET] </span><br><span class=\"line\">             [REQUIRED] [[COMPONENTS] [components...]] </span><br><span class=\"line\">             [CONFIG|NO_MODULE] </span><br><span class=\"line\">             [NO_POLICY_SCOPE] </span><br><span class=\"line\">             [NAMES name1 [name2 ...]] </span><br><span class=\"line\">             [CONFIGS config1 [config2 ...]] </span><br><span class=\"line\">             [HINTS path1 [path2 ... ]] </span><br><span class=\"line\">             [PATHS path1 [path2 ... ]] </span><br><span class=\"line\">             [PATH_SUFFIXES suffix1 [suffix2 ...]] </span><br><span class=\"line\">             [NO_DEFAULT_PATH] </span><br><span class=\"line\">             [NO_CMAKE_ENVIRONMENT_PATH] </span><br><span class=\"line\">             [NO_CMAKE_PATH] </span><br><span class=\"line\">             [NO_SYSTEM_ENVIRONMENT_PATH] </span><br><span class=\"line\">             [NO_CMAKE_PACKAGE_REGISTRY] </span><br><span class=\"line\">             [NO_CMAKE_BUILDS_PATH] # Deprecated; does nothing. </span><br><span class=\"line\">             [NO_CMAKE_SYSTEM_PATH] </span><br><span class=\"line\">             [NO_CMAKE_SYSTEM_PACKAGE_REGISTRY] </span><br><span class=\"line\">             [CMAKE_FIND_ROOT_PATH_BOTH | </span><br><span class=\"line\">              ONLY_CMAKE_FIND_ROOT_PATH | </span><br><span class=\"line\">              NO_CMAKE_FIND_ROOT_PATH]) </span><br></pre></td></tr></table></figure>\n\n<p>相比于Module模式，Config模式的参数更多，也更复杂，但实际在使用过程中我们并不会用到所有参数，大部分参数都是可选的，我们只需要掌握基本的参数用法即可。 </p>\n<p>其中具体查找库并给XXX_INCLUDE_DIRS和XXX_LIBRARIES两个变量赋值的操作由XXXConfig.cmake模块完成。 </p>\n<p>两种模式看起来似乎差不多，不过CMake默认采取Module模式，如果Module模式未找到库，才会采取Config模式。如果XXX_DIR路径下找不到XXXConfig.cmake文件，则会找&#x2F;usr&#x2F;local&#x2F;lib&#x2F;cmake&#x2F;XXX&#x2F;中的XXXConfig.cmake文件。总之，Config模式是一个备选策略。通常，库安装时会拷贝一份XXXConfig.cmake到系统目录中，因此在没有显式指定搜索路径时也可以顺利找到。 </p>\n<h4 id=\"Config模式查找顺序\"><a href=\"#Config模式查找顺序\" class=\"headerlink\" title=\"Config模式查找顺序\"></a>Config模式查找顺序</h4><p>Config模式下是要查找名为<PackageName>Config.cmake或<lower-case-package-name>-config.cmake的模块文件。  </p>\n<p>搜包路径依次为： </p>\n<p>与Module模式不同，Config模式需要查找的路径非常多，也要匹配很多的可能性，因此有些路径是首先作为根目录，然后进行子目录的匹配，我会进行说明。  </p>\n<p>具体查找顺序为： </p>\n<p>1、名为<PackageName>_DIR的CMake变量或环境变量路径 </p>\n<p>默认为空。 </p>\n<p>这个路径是非根目录路径，需要指定到<PackageName>Config.cmake或<lower-case-package-name>-config.cmake文件所在目录才能找到。 </p>\n<p>2、名为CMAKE_PREFIX_PATH、CMAKE_FRAMEWORK_PATH、CMAKE_APPBUNDLE_PATH的CMake变量或环境变量路径 </p>\n<p>根目录，默认都为空。 </p>\n<p>注意如果你电脑中安装了ROS并配置好之后，你在终端执行echo $CMAKE_PREFIX_PATH会发现ROS会将CMAKE_PREFIX_PATH这个变量设置为ROS中的库的路径，意思是会首先查找ROS安装的库，如果恰好你在ROS中安装了OpenCV库，就会发现首先找到的是ROS中的OpenCV，而不是你自己安装到系统中的OpenCV。 </p>\n<p>3、PATH环境变量路径 </p>\n<p>根目录，默认为系统环境PATH环境变量值。 </p>\n<p>其实这个路径才是Config模式大部分情况下能够查找到安装到系统中各种库的原因。 </p>\n<p>这个路径的查找规则为： </p>\n<p>遍历PATH环境变量中的各路径，如果该路径如果以bin或sbin结尾，则自动回退到上一级目录得到根目录。例如我的PATH路径包括： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ echo $PATH </span><br><span class=\"line\">/home/zhanghm/.local/bin:/usr/local/cuda-10.1/bin:/opt/ros/melodic/bin:/home/zhanghm/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure>\n\n<p>在上述指明的是根目录路径时，CMake会首先检查这些根目录路径下是否有名为<PackageName>Config.cmake或<lower-case-package-name>-config.cmake的模块文件，如果没有，CMake会继续检查或匹配这些根目录下的以下路径（<PackageName>_DIR路径不是根目录路径）： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;prefix&gt;/(lib/&lt;arch&gt;|lib|share)/cmake/&lt;name&gt;*/ </span><br><span class=\"line\">&lt;prefix&gt;/(lib/&lt;arch&gt;|lib|share)/&lt;name&gt;*/  </span><br><span class=\"line\">&lt;prefix&gt;/(lib/&lt;arch&gt;|lib|share)/&lt;name&gt;*/(cmake|CMake)/</span><br></pre></td></tr></table></figure>\n\n<p>其中为系统架构名，如Ubuntu下一般为：&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu，整个(lib&#x2F;<arch>|lib|share)为可选路径，例如OpenCV库而言会检查或匹配<prefix>&#x2F;OpenCV&#x2F;、<prefix>&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;OpenCV&#x2F;、<prefix>&#x2F;lib&#x2F;share&#x2F;OpenCV&#x2F;、<prefix>&#x2F;share&#x2F;OpenCV&#x2F;等路径；name为包名，不区分大小写<name>*意思是包名后接一些版本后等字符也是合法的，如pcl-1.9也会被找到。</p>\n<h3 id=\"3-4-查找指定包建议\"><a href=\"#3-4-查找指定包建议\" class=\"headerlink\" title=\"3.4 查找指定包建议\"></a><strong>3.4 查找指定包建议</strong></h3><p>上面的查找规则整体看起来好像很复杂，但其实我们在安装库的时候都会自动配置安装到对的位置，一般都不会出现问题。如果我们需要指定特定的库，我们也只需要设置优先级最高的几个变量名即可。包括下面两种情况： </p>\n<p>1、如果你明确知道想要查找的库<PackageName>Config.cmake或<lower-case-package-name>-config.cmake文件所在路径，为了能够准确定位到这个包，可以直接设置变量<PackageName>_DIR为具体路径，如： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set(OpenCV_DIR &quot;/home/zhanghm/Softwares/enviroment_config/opencv3_4_4/opencv/build&quot;) </span><br></pre></td></tr></table></figure>\n\n<p>就可以明确需要查找的OpenCV包的路径了。 </p>\n<p>2、如果你有多个包的配置文件需要查找，可以将这些配置文件都统一放在一个命名为cmake的文件夹下，然后设置变量CMAKE_PREFIX_PATH变量指向这个cmake文件夹路径，需要注意根据上述的匹配规则，此时每个包的配置文件需要单独放置在命名为包名的文件夹下（文件夹名不区分大小写），否则会提示找不到。 </p>\n<h2 id=\"4、总结\"><a href=\"#4、总结\" class=\"headerlink\" title=\"4、总结\"></a><strong>4、总结</strong></h2><p>通过前面的描述，我相信大家已经能够基本掌握find_package命令的各种用法了，也能够在出现各种问题时自己进行问题定位。但还有一个我们需要注意的点是我们能够在自己的项目中使用find_package命令便捷进行依赖包配置的前提是这个包的开发者也是用CMake配置好了这个包，并提供了<PackageName>Config.cmake或Find<PackageName>.cmake的配置文件。 </p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a><strong>参考</strong></h2><p><a href=\"https://blog.csdn.net/zhanghm1995/article/details/105466372\">https://blog.csdn.net/zhanghm1995/article/details/105466372</a> </p>\n<p><a href=\"https://cmake.org/cmake/help/v3.5/command/find_package.html\">https://cmake.org/cmake/help/v3.5/command/find_package.html</a> （官网介绍） </p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/50829542\">https://zhuanlan.zhihu.com/p/50829542</a> </p>\n<p><a href=\"https://seanzhengw.github.io/blog/cmake/2018/04/23/cmake-find-package.html\">https://seanzhengw.github.io/blog/cmake/2018/04/23/cmake-find-package.html</a> </p>\n<p><a href=\"https://blog.csdn.net/bytxl/article/details/50637277\">https://blog.csdn.net/bytxl/article/details/50637277</a> </p>\n"},{"_content":"# GoogleTest\n\n## GoogleTest运行特定的测试用例\n\n通常GoogleTest的单元测试，直接执行，就全跑一遍，很耗时，有时候需要只测试某个case。\n\n先列出所有case：\n\n```\nD:\\my_workspace\\build\\Debug>hello_test.exe --gtest_list_tests\nRunning main() from D:\\my_workspace\\build\\_deps\\googletest-src\\googletest\\src\\gtest_main.cc\nHelloTest.\n  MyTest\n  MyTest2\nFactorialTest.\n  Negative\n  Zero\n  Positive\nIsPrimeTest.\n  Negative\n  Trivial\n```\n\n然后执行特定case：\n\n```\nhello_test.exe --gtest_filter=\"HelloTest*\"\n```\n\n或者：\n\n```\nhello_test.exe --gtest_filter=\"HelloTest.MyTest2\"\n```\n\n如果你的测试程序加这些后缀无效，可能是你的main函数写错了，把main函数删除，GoogleTest默认有main函数的，可以编译过。","source":"_posts/C++/GoogleTest.md","raw":"# GoogleTest\n\n## GoogleTest运行特定的测试用例\n\n通常GoogleTest的单元测试，直接执行，就全跑一遍，很耗时，有时候需要只测试某个case。\n\n先列出所有case：\n\n```\nD:\\my_workspace\\build\\Debug>hello_test.exe --gtest_list_tests\nRunning main() from D:\\my_workspace\\build\\_deps\\googletest-src\\googletest\\src\\gtest_main.cc\nHelloTest.\n  MyTest\n  MyTest2\nFactorialTest.\n  Negative\n  Zero\n  Positive\nIsPrimeTest.\n  Negative\n  Trivial\n```\n\n然后执行特定case：\n\n```\nhello_test.exe --gtest_filter=\"HelloTest*\"\n```\n\n或者：\n\n```\nhello_test.exe --gtest_filter=\"HelloTest.MyTest2\"\n```\n\n如果你的测试程序加这些后缀无效，可能是你的main函数写错了，把main函数删除，GoogleTest默认有main函数的，可以编译过。","slug":"C++/GoogleTest","published":1,"date":"2023-08-24T14:38:18.628Z","updated":"2023-07-10T09:35:01.939Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0ta000bdkr7250g9q1e","content":"<h1 id=\"GoogleTest\"><a href=\"#GoogleTest\" class=\"headerlink\" title=\"GoogleTest\"></a>GoogleTest</h1><h2 id=\"GoogleTest运行特定的测试用例\"><a href=\"#GoogleTest运行特定的测试用例\" class=\"headerlink\" title=\"GoogleTest运行特定的测试用例\"></a>GoogleTest运行特定的测试用例</h2><p>通常GoogleTest的单元测试，直接执行，就全跑一遍，很耗时，有时候需要只测试某个case。</p>\n<p>先列出所有case：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\my_workspace\\build\\Debug&gt;hello_test.exe --gtest_list_tests</span><br><span class=\"line\">Running main() from D:\\my_workspace\\build\\_deps\\googletest-src\\googletest\\src\\gtest_main.cc</span><br><span class=\"line\">HelloTest.</span><br><span class=\"line\">  MyTest</span><br><span class=\"line\">  MyTest2</span><br><span class=\"line\">FactorialTest.</span><br><span class=\"line\">  Negative</span><br><span class=\"line\">  Zero</span><br><span class=\"line\">  Positive</span><br><span class=\"line\">IsPrimeTest.</span><br><span class=\"line\">  Negative</span><br><span class=\"line\">  Trivial</span><br></pre></td></tr></table></figure>\n\n<p>然后执行特定case：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello_test.exe --gtest_filter=&quot;HelloTest*&quot;</span><br></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello_test.exe --gtest_filter=&quot;HelloTest.MyTest2&quot;</span><br></pre></td></tr></table></figure>\n\n<p>如果你的测试程序加这些后缀无效，可能是你的main函数写错了，把main函数删除，GoogleTest默认有main函数的，可以编译过。</p>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-2.png","cover_type":"img","excerpt":"","more":"<h1 id=\"GoogleTest\"><a href=\"#GoogleTest\" class=\"headerlink\" title=\"GoogleTest\"></a>GoogleTest</h1><h2 id=\"GoogleTest运行特定的测试用例\"><a href=\"#GoogleTest运行特定的测试用例\" class=\"headerlink\" title=\"GoogleTest运行特定的测试用例\"></a>GoogleTest运行特定的测试用例</h2><p>通常GoogleTest的单元测试，直接执行，就全跑一遍，很耗时，有时候需要只测试某个case。</p>\n<p>先列出所有case：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\my_workspace\\build\\Debug&gt;hello_test.exe --gtest_list_tests</span><br><span class=\"line\">Running main() from D:\\my_workspace\\build\\_deps\\googletest-src\\googletest\\src\\gtest_main.cc</span><br><span class=\"line\">HelloTest.</span><br><span class=\"line\">  MyTest</span><br><span class=\"line\">  MyTest2</span><br><span class=\"line\">FactorialTest.</span><br><span class=\"line\">  Negative</span><br><span class=\"line\">  Zero</span><br><span class=\"line\">  Positive</span><br><span class=\"line\">IsPrimeTest.</span><br><span class=\"line\">  Negative</span><br><span class=\"line\">  Trivial</span><br></pre></td></tr></table></figure>\n\n<p>然后执行特定case：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello_test.exe --gtest_filter=&quot;HelloTest*&quot;</span><br></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello_test.exe --gtest_filter=&quot;HelloTest.MyTest2&quot;</span><br></pre></td></tr></table></figure>\n\n<p>如果你的测试程序加这些后缀无效，可能是你的main函数写错了，把main函数删除，GoogleTest默认有main函数的，可以编译过。</p>\n"},{"_content":"# EigenGeometry \n\n```c++\n#include<iostream> \n#include<cmath> \n\nusing namespace std; \n\n#include<Eigen/Core> \n#include<Eigen/Geometry> \n\nusing namespace Eigen; \n\n//本程序演示了Eigen几何模块的使用方法 \nint main(intargc,char**argv){ \n    //Eigen/Geometry模块提供了各种旋转和平移的表示 \n    //3D旋转矩阵直接使用Matrix3d或Matrix3f \n    Matrix3drotation_matrix=Matrix3d::Identity();//单位矩阵 \n\n    //旋转向量使用AngleAxis,它底层不直接是Matrix，但运算可以当作矩阵（因为重载了运算符） \n    AngleAxisdrotation_vector(M_PI/4,Vector3d(0,0,1));//沿Z轴旋转45度 \n\n    cout.precision(3); \n    cout<<\"rotationmatrix=\\n\"<<rotation_vector.matrix()<<endl;//用matrix()转换成矩阵 \n\n    //也可以直接赋值 \n    rotation_matrix=rotation_vector.toRotationMatrix(); \n\n    //用AngleAxis可以进行坐标变换 \n    Vector3dv(1,0,0); \n    Vector3dv_rotated=rotation_vector*v; \n    cout<<\"(1,0,0)afterrotation(byangleaxis)=\"<<v_rotated.transpose()<<endl; \n\n    //或者用旋转矩阵 \n    v_rotated=rotation_matrix*v; \n    cout<<\"(1,0,0)afterrotation(bymatrix)=\"<<v_rotated.transpose()<<endl; \n\n    //欧拉角:可以将旋转矩阵直接转换成欧拉角 \n    Vector3deuler_angles=rotation_matrix.eulerAngles(2,1,0);//ZYX顺序，即yaw-pitch-roll顺序 \n    cout<<\"yawpitchroll=\"<<euler_angles.transpose()<<endl; \n    \n    //欧氏变换矩阵使用Eigen::Isometry \n    Isometry3dT=Isometry3d::Identity();//虽然称为3d，实质上是4＊4的矩阵 \n    T.rotate(rotation_vector);//按照rotation_vector进行旋转 \n    T.pretranslate(Vector3d(1,3,4));//把平移向量设成(1,3,4) \n    cout<<\"Transformmatrix=\\n\"<<T.matrix()<<endl; \n\n    //用变换矩阵进行坐标变换 \n    Vector3dv_transformed=T*v;//相当于R*v+t \n    cout<<\"vtranformed=\"<<v_transformed.transpose()<<endl; \n\n    //对于仿射和射影变换，使用Eigen::Affine3d和Eigen::Projective3d即可，略 \n    ##都是调用了有参构造函数 \n    //四元数 \n    //可以直接把AngleAxis赋值给四元数，反之亦然 \n    Quaterniondq=Quaterniond(rotation_vector); \n    cout<<\"quaternionfromrotationvector=\"<<q.coeffs().transpose()<<endl;//请注意coeffs的顺序是(x,y,z,w),w为实部，前三者为虚部 \n\n    //也可以把旋转矩阵赋给它 \n    q=Quaterniond(rotation_matrix); \n    cout<<\"quaternionfromrotationmatrix=\"<<q.coeffs().transpose()<<endl; \n\n    //使用四元数旋转一个向量，使用重载的乘法即可 \n    v_rotated=q*v;//注意数学上是qvq^{-1} \n    cout<<\"(1,0,0)afterrotation=\"<<v_rotated.transpose()<<endl; \n\n    //用常规向量乘法表示，则应该如下计算 \n    cout<<\"shouldbeequalto\"<<(q*Quaterniond(0,1,0,0)*q.inverse()).coeffs().transpose()<<endl; \n\n    return0; \n\n} \n```\n\n","source":"_posts/C++/EigenGeometry.md","raw":"# EigenGeometry \n\n```c++\n#include<iostream> \n#include<cmath> \n\nusing namespace std; \n\n#include<Eigen/Core> \n#include<Eigen/Geometry> \n\nusing namespace Eigen; \n\n//本程序演示了Eigen几何模块的使用方法 \nint main(intargc,char**argv){ \n    //Eigen/Geometry模块提供了各种旋转和平移的表示 \n    //3D旋转矩阵直接使用Matrix3d或Matrix3f \n    Matrix3drotation_matrix=Matrix3d::Identity();//单位矩阵 \n\n    //旋转向量使用AngleAxis,它底层不直接是Matrix，但运算可以当作矩阵（因为重载了运算符） \n    AngleAxisdrotation_vector(M_PI/4,Vector3d(0,0,1));//沿Z轴旋转45度 \n\n    cout.precision(3); \n    cout<<\"rotationmatrix=\\n\"<<rotation_vector.matrix()<<endl;//用matrix()转换成矩阵 \n\n    //也可以直接赋值 \n    rotation_matrix=rotation_vector.toRotationMatrix(); \n\n    //用AngleAxis可以进行坐标变换 \n    Vector3dv(1,0,0); \n    Vector3dv_rotated=rotation_vector*v; \n    cout<<\"(1,0,0)afterrotation(byangleaxis)=\"<<v_rotated.transpose()<<endl; \n\n    //或者用旋转矩阵 \n    v_rotated=rotation_matrix*v; \n    cout<<\"(1,0,0)afterrotation(bymatrix)=\"<<v_rotated.transpose()<<endl; \n\n    //欧拉角:可以将旋转矩阵直接转换成欧拉角 \n    Vector3deuler_angles=rotation_matrix.eulerAngles(2,1,0);//ZYX顺序，即yaw-pitch-roll顺序 \n    cout<<\"yawpitchroll=\"<<euler_angles.transpose()<<endl; \n    \n    //欧氏变换矩阵使用Eigen::Isometry \n    Isometry3dT=Isometry3d::Identity();//虽然称为3d，实质上是4＊4的矩阵 \n    T.rotate(rotation_vector);//按照rotation_vector进行旋转 \n    T.pretranslate(Vector3d(1,3,4));//把平移向量设成(1,3,4) \n    cout<<\"Transformmatrix=\\n\"<<T.matrix()<<endl; \n\n    //用变换矩阵进行坐标变换 \n    Vector3dv_transformed=T*v;//相当于R*v+t \n    cout<<\"vtranformed=\"<<v_transformed.transpose()<<endl; \n\n    //对于仿射和射影变换，使用Eigen::Affine3d和Eigen::Projective3d即可，略 \n    ##都是调用了有参构造函数 \n    //四元数 \n    //可以直接把AngleAxis赋值给四元数，反之亦然 \n    Quaterniondq=Quaterniond(rotation_vector); \n    cout<<\"quaternionfromrotationvector=\"<<q.coeffs().transpose()<<endl;//请注意coeffs的顺序是(x,y,z,w),w为实部，前三者为虚部 \n\n    //也可以把旋转矩阵赋给它 \n    q=Quaterniond(rotation_matrix); \n    cout<<\"quaternionfromrotationmatrix=\"<<q.coeffs().transpose()<<endl; \n\n    //使用四元数旋转一个向量，使用重载的乘法即可 \n    v_rotated=q*v;//注意数学上是qvq^{-1} \n    cout<<\"(1,0,0)afterrotation=\"<<v_rotated.transpose()<<endl; \n\n    //用常规向量乘法表示，则应该如下计算 \n    cout<<\"shouldbeequalto\"<<(q*Quaterniond(0,1,0,0)*q.inverse()).coeffs().transpose()<<endl; \n\n    return0; \n\n} \n```\n\n","slug":"C++/EigenGeometry","published":1,"date":"2023-08-24T14:38:18.618Z","updated":"2022-12-30T03:13:44.815Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0tb000ddkr79q3g8ba3","content":"<h1 id=\"EigenGeometry\"><a href=\"#EigenGeometry\" class=\"headerlink\" title=\"EigenGeometry\"></a>EigenGeometry</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cmath&gt;</span> </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;Eigen/Core&gt;</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;Eigen/Geometry&gt;</span> </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> Eigen; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//本程序演示了Eigen几何模块的使用方法 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(intargc,<span class=\"type\">char</span>**argv)</span></span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//Eigen/Geometry模块提供了各种旋转和平移的表示 </span></span><br><span class=\"line\">    <span class=\"comment\">//3D旋转矩阵直接使用Matrix3d或Matrix3f </span></span><br><span class=\"line\">    Matrix3drotation_matrix=Matrix3d::<span class=\"built_in\">Identity</span>();<span class=\"comment\">//单位矩阵 </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//旋转向量使用AngleAxis,它底层不直接是Matrix，但运算可以当作矩阵（因为重载了运算符） </span></span><br><span class=\"line\">    <span class=\"built_in\">AngleAxisdrotation_vector</span>(M_PI/<span class=\"number\">4</span>,<span class=\"built_in\">Vector3d</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>));<span class=\"comment\">//沿Z轴旋转45度 </span></span><br><span class=\"line\"></span><br><span class=\"line\">    cout.<span class=\"built_in\">precision</span>(<span class=\"number\">3</span>); </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;rotationmatrix=\\n&quot;</span>&lt;&lt;rotation_vector.<span class=\"built_in\">matrix</span>()&lt;&lt;endl;<span class=\"comment\">//用matrix()转换成矩阵 </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//也可以直接赋值 </span></span><br><span class=\"line\">    rotation_matrix=rotation_vector.<span class=\"built_in\">toRotationMatrix</span>(); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用AngleAxis可以进行坐标变换 </span></span><br><span class=\"line\">    <span class=\"built_in\">Vector3dv</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>); </span><br><span class=\"line\">    Vector3dv_rotated=rotation_vector*v; </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;(1,0,0)afterrotation(byangleaxis)=&quot;</span>&lt;&lt;v_rotated.<span class=\"built_in\">transpose</span>()&lt;&lt;endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//或者用旋转矩阵 </span></span><br><span class=\"line\">    v_rotated=rotation_matrix*v; </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;(1,0,0)afterrotation(bymatrix)=&quot;</span>&lt;&lt;v_rotated.<span class=\"built_in\">transpose</span>()&lt;&lt;endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//欧拉角:可以将旋转矩阵直接转换成欧拉角 </span></span><br><span class=\"line\">    Vector3deuler_angles=rotation_matrix.<span class=\"built_in\">eulerAngles</span>(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>);<span class=\"comment\">//ZYX顺序，即yaw-pitch-roll顺序 </span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;yawpitchroll=&quot;</span>&lt;&lt;euler_angles.<span class=\"built_in\">transpose</span>()&lt;&lt;endl; </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//欧氏变换矩阵使用Eigen::Isometry </span></span><br><span class=\"line\">    Isometry3dT=Isometry3d::<span class=\"built_in\">Identity</span>();<span class=\"comment\">//虽然称为3d，实质上是4＊4的矩阵 </span></span><br><span class=\"line\">    T.<span class=\"built_in\">rotate</span>(rotation_vector);<span class=\"comment\">//按照rotation_vector进行旋转 </span></span><br><span class=\"line\">    T.<span class=\"built_in\">pretranslate</span>(<span class=\"built_in\">Vector3d</span>(<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>));<span class=\"comment\">//把平移向量设成(1,3,4) </span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;Transformmatrix=\\n&quot;</span>&lt;&lt;T.<span class=\"built_in\">matrix</span>()&lt;&lt;endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用变换矩阵进行坐标变换 </span></span><br><span class=\"line\">    Vector3dv_transformed=T*v;<span class=\"comment\">//相当于R*v+t </span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;vtranformed=&quot;</span>&lt;&lt;v_transformed.<span class=\"built_in\">transpose</span>()&lt;&lt;endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//对于仿射和射影变换，使用Eigen::Affine3d和Eigen::Projective3d即可，略 </span></span><br><span class=\"line\">    ##都是调用了有参构造函数 </span><br><span class=\"line\">    <span class=\"comment\">//四元数 </span></span><br><span class=\"line\">    <span class=\"comment\">//可以直接把AngleAxis赋值给四元数，反之亦然 </span></span><br><span class=\"line\">    Quaterniondq=<span class=\"built_in\">Quaterniond</span>(rotation_vector); </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;quaternionfromrotationvector=&quot;</span>&lt;&lt;q.<span class=\"built_in\">coeffs</span>().<span class=\"built_in\">transpose</span>()&lt;&lt;endl;<span class=\"comment\">//请注意coeffs的顺序是(x,y,z,w),w为实部，前三者为虚部 </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//也可以把旋转矩阵赋给它 </span></span><br><span class=\"line\">    q=<span class=\"built_in\">Quaterniond</span>(rotation_matrix); </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;quaternionfromrotationmatrix=&quot;</span>&lt;&lt;q.<span class=\"built_in\">coeffs</span>().<span class=\"built_in\">transpose</span>()&lt;&lt;endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//使用四元数旋转一个向量，使用重载的乘法即可 </span></span><br><span class=\"line\">    v_rotated=q*v;<span class=\"comment\">//注意数学上是qvq^&#123;-1&#125; </span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;(1,0,0)afterrotation=&quot;</span>&lt;&lt;v_rotated.<span class=\"built_in\">transpose</span>()&lt;&lt;endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用常规向量乘法表示，则应该如下计算 </span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;shouldbeequalto&quot;</span>&lt;&lt;(q*<span class=\"built_in\">Quaterniond</span>(<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>)*q.<span class=\"built_in\">inverse</span>()).<span class=\"built_in\">coeffs</span>().<span class=\"built_in\">transpose</span>()&lt;&lt;endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    return0; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-8.png","cover_type":"img","excerpt":"","more":"<h1 id=\"EigenGeometry\"><a href=\"#EigenGeometry\" class=\"headerlink\" title=\"EigenGeometry\"></a>EigenGeometry</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cmath&gt;</span> </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;Eigen/Core&gt;</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;Eigen/Geometry&gt;</span> </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> Eigen; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//本程序演示了Eigen几何模块的使用方法 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(intargc,<span class=\"type\">char</span>**argv)</span></span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//Eigen/Geometry模块提供了各种旋转和平移的表示 </span></span><br><span class=\"line\">    <span class=\"comment\">//3D旋转矩阵直接使用Matrix3d或Matrix3f </span></span><br><span class=\"line\">    Matrix3drotation_matrix=Matrix3d::<span class=\"built_in\">Identity</span>();<span class=\"comment\">//单位矩阵 </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//旋转向量使用AngleAxis,它底层不直接是Matrix，但运算可以当作矩阵（因为重载了运算符） </span></span><br><span class=\"line\">    <span class=\"built_in\">AngleAxisdrotation_vector</span>(M_PI/<span class=\"number\">4</span>,<span class=\"built_in\">Vector3d</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>));<span class=\"comment\">//沿Z轴旋转45度 </span></span><br><span class=\"line\"></span><br><span class=\"line\">    cout.<span class=\"built_in\">precision</span>(<span class=\"number\">3</span>); </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;rotationmatrix=\\n&quot;</span>&lt;&lt;rotation_vector.<span class=\"built_in\">matrix</span>()&lt;&lt;endl;<span class=\"comment\">//用matrix()转换成矩阵 </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//也可以直接赋值 </span></span><br><span class=\"line\">    rotation_matrix=rotation_vector.<span class=\"built_in\">toRotationMatrix</span>(); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用AngleAxis可以进行坐标变换 </span></span><br><span class=\"line\">    <span class=\"built_in\">Vector3dv</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>); </span><br><span class=\"line\">    Vector3dv_rotated=rotation_vector*v; </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;(1,0,0)afterrotation(byangleaxis)=&quot;</span>&lt;&lt;v_rotated.<span class=\"built_in\">transpose</span>()&lt;&lt;endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//或者用旋转矩阵 </span></span><br><span class=\"line\">    v_rotated=rotation_matrix*v; </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;(1,0,0)afterrotation(bymatrix)=&quot;</span>&lt;&lt;v_rotated.<span class=\"built_in\">transpose</span>()&lt;&lt;endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//欧拉角:可以将旋转矩阵直接转换成欧拉角 </span></span><br><span class=\"line\">    Vector3deuler_angles=rotation_matrix.<span class=\"built_in\">eulerAngles</span>(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>);<span class=\"comment\">//ZYX顺序，即yaw-pitch-roll顺序 </span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;yawpitchroll=&quot;</span>&lt;&lt;euler_angles.<span class=\"built_in\">transpose</span>()&lt;&lt;endl; </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//欧氏变换矩阵使用Eigen::Isometry </span></span><br><span class=\"line\">    Isometry3dT=Isometry3d::<span class=\"built_in\">Identity</span>();<span class=\"comment\">//虽然称为3d，实质上是4＊4的矩阵 </span></span><br><span class=\"line\">    T.<span class=\"built_in\">rotate</span>(rotation_vector);<span class=\"comment\">//按照rotation_vector进行旋转 </span></span><br><span class=\"line\">    T.<span class=\"built_in\">pretranslate</span>(<span class=\"built_in\">Vector3d</span>(<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>));<span class=\"comment\">//把平移向量设成(1,3,4) </span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;Transformmatrix=\\n&quot;</span>&lt;&lt;T.<span class=\"built_in\">matrix</span>()&lt;&lt;endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用变换矩阵进行坐标变换 </span></span><br><span class=\"line\">    Vector3dv_transformed=T*v;<span class=\"comment\">//相当于R*v+t </span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;vtranformed=&quot;</span>&lt;&lt;v_transformed.<span class=\"built_in\">transpose</span>()&lt;&lt;endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//对于仿射和射影变换，使用Eigen::Affine3d和Eigen::Projective3d即可，略 </span></span><br><span class=\"line\">    ##都是调用了有参构造函数 </span><br><span class=\"line\">    <span class=\"comment\">//四元数 </span></span><br><span class=\"line\">    <span class=\"comment\">//可以直接把AngleAxis赋值给四元数，反之亦然 </span></span><br><span class=\"line\">    Quaterniondq=<span class=\"built_in\">Quaterniond</span>(rotation_vector); </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;quaternionfromrotationvector=&quot;</span>&lt;&lt;q.<span class=\"built_in\">coeffs</span>().<span class=\"built_in\">transpose</span>()&lt;&lt;endl;<span class=\"comment\">//请注意coeffs的顺序是(x,y,z,w),w为实部，前三者为虚部 </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//也可以把旋转矩阵赋给它 </span></span><br><span class=\"line\">    q=<span class=\"built_in\">Quaterniond</span>(rotation_matrix); </span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;quaternionfromrotationmatrix=&quot;</span>&lt;&lt;q.<span class=\"built_in\">coeffs</span>().<span class=\"built_in\">transpose</span>()&lt;&lt;endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//使用四元数旋转一个向量，使用重载的乘法即可 </span></span><br><span class=\"line\">    v_rotated=q*v;<span class=\"comment\">//注意数学上是qvq^&#123;-1&#125; </span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;(1,0,0)afterrotation=&quot;</span>&lt;&lt;v_rotated.<span class=\"built_in\">transpose</span>()&lt;&lt;endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用常规向量乘法表示，则应该如下计算 </span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;shouldbeequalto&quot;</span>&lt;&lt;(q*<span class=\"built_in\">Quaterniond</span>(<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>)*q.<span class=\"built_in\">inverse</span>()).<span class=\"built_in\">coeffs</span>().<span class=\"built_in\">transpose</span>()&lt;&lt;endl; </span><br><span class=\"line\"></span><br><span class=\"line\">    return0; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n"},{"_content":"# Opencv Mat\n\n\n\n## **Mat_\\<\\>()**\n\n```\nMat k = (Mat_<double>(3,3) << 1, 2, 3, 4, 5, 6, 7, 8, 9);\n```\n\n\n\n## **Mat.at\\<\\>()**\n\n```\nk.at<double>(0,0) = 1;\n```\n\n\n\n## **Mat::eye**\n\n返回一个恒等指定大小和类型矩阵。\n\n```\nC++: static MatExpr Mat::eye(int rows, int cols, inttype)\n\nC++: static MatExpr Mat::eye(Size size, int type)\n```\n\n**参数**\n\n**rows** –的行数。\n\n**cols**– 的列数。\n\n**size** –替代矩阵大小规格Size(cols, rows)的方法。\n\n**type** – 创建的矩阵的类型。\n\n该方法返回 Matlab 式恒等矩阵初始值设定项，类似 Mat::zeros()和 Mat::ones()，你可以用缩放操作高效地创建缩放的恒等矩阵：\n\n/ / 创建4 x 4 的对角矩阵并在对角线上以0.1的比率缩小。\n\n```\nMat A = Mat::eye(4, 4, CV_32F) * 0.1;\n```\n\n\n\n## **Mat::create**\n\n分配新的阵列数据 （如果需要）。\n\n```\nC++: void Mat::create(int rows, int cols, int type)\n\nC++: void Mat::create(Size size, int type)\n\nC++: void Mat::create(int ndims, const int\\* sizes, inttype)\n```\n\n**参数**\n\n**ndims** – 新数组的维数。\n\n**rows** –新的行数。\n\n**cols** – 新的列数。\n\n**size** – 替代新矩阵大小规格：Size(cols, rows)。\n\n**sizes** – 指定一个新的阵列形状的整数数组。\n\n**type** – 新矩阵的类型。\n\n这是关键的Mat方法之一。大多数新样式 OpenCV 函数和产生阵列的方法每个输出数组都调用这个方法。此方法使用如下算法：\n\n1.如果当前数组形状和类型匹配新的请立即返回。否则，通过调用 Mat::release()取消引用以前的数据。\n\n2.初始化新矩阵头。\n\n3.分配新的 total()\\*elemSize() 个字节的数据空间。\n\n4.分配新的关联数据的引用计数并将其设置为 1。\n","source":"_posts/C++/Opencv_Mat.md","raw":"# Opencv Mat\n\n\n\n## **Mat_\\<\\>()**\n\n```\nMat k = (Mat_<double>(3,3) << 1, 2, 3, 4, 5, 6, 7, 8, 9);\n```\n\n\n\n## **Mat.at\\<\\>()**\n\n```\nk.at<double>(0,0) = 1;\n```\n\n\n\n## **Mat::eye**\n\n返回一个恒等指定大小和类型矩阵。\n\n```\nC++: static MatExpr Mat::eye(int rows, int cols, inttype)\n\nC++: static MatExpr Mat::eye(Size size, int type)\n```\n\n**参数**\n\n**rows** –的行数。\n\n**cols**– 的列数。\n\n**size** –替代矩阵大小规格Size(cols, rows)的方法。\n\n**type** – 创建的矩阵的类型。\n\n该方法返回 Matlab 式恒等矩阵初始值设定项，类似 Mat::zeros()和 Mat::ones()，你可以用缩放操作高效地创建缩放的恒等矩阵：\n\n/ / 创建4 x 4 的对角矩阵并在对角线上以0.1的比率缩小。\n\n```\nMat A = Mat::eye(4, 4, CV_32F) * 0.1;\n```\n\n\n\n## **Mat::create**\n\n分配新的阵列数据 （如果需要）。\n\n```\nC++: void Mat::create(int rows, int cols, int type)\n\nC++: void Mat::create(Size size, int type)\n\nC++: void Mat::create(int ndims, const int\\* sizes, inttype)\n```\n\n**参数**\n\n**ndims** – 新数组的维数。\n\n**rows** –新的行数。\n\n**cols** – 新的列数。\n\n**size** – 替代新矩阵大小规格：Size(cols, rows)。\n\n**sizes** – 指定一个新的阵列形状的整数数组。\n\n**type** – 新矩阵的类型。\n\n这是关键的Mat方法之一。大多数新样式 OpenCV 函数和产生阵列的方法每个输出数组都调用这个方法。此方法使用如下算法：\n\n1.如果当前数组形状和类型匹配新的请立即返回。否则，通过调用 Mat::release()取消引用以前的数据。\n\n2.初始化新矩阵头。\n\n3.分配新的 total()\\*elemSize() 个字节的数据空间。\n\n4.分配新的关联数据的引用计数并将其设置为 1。\n","slug":"C++/Opencv_Mat","published":1,"date":"2023-08-24T14:38:18.629Z","updated":"2022-12-30T03:13:44.815Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0tb000edkr7a2psdsle","content":"<h1 id=\"Opencv-Mat\"><a href=\"#Opencv-Mat\" class=\"headerlink\" title=\"Opencv Mat\"></a>Opencv Mat</h1><h2 id=\"Mat\"><a href=\"#Mat\" class=\"headerlink\" title=\"Mat_&lt;&gt;()\"></a><strong>Mat_&lt;&gt;()</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mat k = (Mat_&lt;double&gt;(3,3) &lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Mat-at\"><a href=\"#Mat-at\" class=\"headerlink\" title=\"Mat.at&lt;&gt;()\"></a><strong>Mat.at&lt;&gt;()</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k.at&lt;double&gt;(0,0) = 1;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Mat-eye\"><a href=\"#Mat-eye\" class=\"headerlink\" title=\"Mat::eye\"></a><strong>Mat::eye</strong></h2><p>返回一个恒等指定大小和类型矩阵。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C++: static MatExpr Mat::eye(int rows, int cols, inttype)</span><br><span class=\"line\"></span><br><span class=\"line\">C++: static MatExpr Mat::eye(Size size, int type)</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数</strong></p>\n<p><strong>rows</strong> –的行数。</p>\n<p><strong>cols</strong>– 的列数。</p>\n<p><strong>size</strong> –替代矩阵大小规格Size(cols, rows)的方法。</p>\n<p><strong>type</strong> – 创建的矩阵的类型。</p>\n<p>该方法返回 Matlab 式恒等矩阵初始值设定项，类似 Mat::zeros()和 Mat::ones()，你可以用缩放操作高效地创建缩放的恒等矩阵：</p>\n<p>&#x2F; &#x2F; 创建4 x 4 的对角矩阵并在对角线上以0.1的比率缩小。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mat A = Mat::eye(4, 4, CV_32F) * 0.1;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Mat-create\"><a href=\"#Mat-create\" class=\"headerlink\" title=\"Mat::create\"></a><strong>Mat::create</strong></h2><p>分配新的阵列数据 （如果需要）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C++: void Mat::create(int rows, int cols, int type)</span><br><span class=\"line\"></span><br><span class=\"line\">C++: void Mat::create(Size size, int type)</span><br><span class=\"line\"></span><br><span class=\"line\">C++: void Mat::create(int ndims, const int\\* sizes, inttype)</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数</strong></p>\n<p><strong>ndims</strong> – 新数组的维数。</p>\n<p><strong>rows</strong> –新的行数。</p>\n<p><strong>cols</strong> – 新的列数。</p>\n<p><strong>size</strong> – 替代新矩阵大小规格：Size(cols, rows)。</p>\n<p><strong>sizes</strong> – 指定一个新的阵列形状的整数数组。</p>\n<p><strong>type</strong> – 新矩阵的类型。</p>\n<p>这是关键的Mat方法之一。大多数新样式 OpenCV 函数和产生阵列的方法每个输出数组都调用这个方法。此方法使用如下算法：</p>\n<p>1.如果当前数组形状和类型匹配新的请立即返回。否则，通过调用 Mat::release()取消引用以前的数据。</p>\n<p>2.初始化新矩阵头。</p>\n<p>3.分配新的 total()*elemSize() 个字节的数据空间。</p>\n<p>4.分配新的关联数据的引用计数并将其设置为 1。</p>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-8.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Opencv-Mat\"><a href=\"#Opencv-Mat\" class=\"headerlink\" title=\"Opencv Mat\"></a>Opencv Mat</h1><h2 id=\"Mat\"><a href=\"#Mat\" class=\"headerlink\" title=\"Mat_&lt;&gt;()\"></a><strong>Mat_&lt;&gt;()</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mat k = (Mat_&lt;double&gt;(3,3) &lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Mat-at\"><a href=\"#Mat-at\" class=\"headerlink\" title=\"Mat.at&lt;&gt;()\"></a><strong>Mat.at&lt;&gt;()</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k.at&lt;double&gt;(0,0) = 1;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Mat-eye\"><a href=\"#Mat-eye\" class=\"headerlink\" title=\"Mat::eye\"></a><strong>Mat::eye</strong></h2><p>返回一个恒等指定大小和类型矩阵。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C++: static MatExpr Mat::eye(int rows, int cols, inttype)</span><br><span class=\"line\"></span><br><span class=\"line\">C++: static MatExpr Mat::eye(Size size, int type)</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数</strong></p>\n<p><strong>rows</strong> –的行数。</p>\n<p><strong>cols</strong>– 的列数。</p>\n<p><strong>size</strong> –替代矩阵大小规格Size(cols, rows)的方法。</p>\n<p><strong>type</strong> – 创建的矩阵的类型。</p>\n<p>该方法返回 Matlab 式恒等矩阵初始值设定项，类似 Mat::zeros()和 Mat::ones()，你可以用缩放操作高效地创建缩放的恒等矩阵：</p>\n<p>&#x2F; &#x2F; 创建4 x 4 的对角矩阵并在对角线上以0.1的比率缩小。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mat A = Mat::eye(4, 4, CV_32F) * 0.1;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Mat-create\"><a href=\"#Mat-create\" class=\"headerlink\" title=\"Mat::create\"></a><strong>Mat::create</strong></h2><p>分配新的阵列数据 （如果需要）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C++: void Mat::create(int rows, int cols, int type)</span><br><span class=\"line\"></span><br><span class=\"line\">C++: void Mat::create(Size size, int type)</span><br><span class=\"line\"></span><br><span class=\"line\">C++: void Mat::create(int ndims, const int\\* sizes, inttype)</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数</strong></p>\n<p><strong>ndims</strong> – 新数组的维数。</p>\n<p><strong>rows</strong> –新的行数。</p>\n<p><strong>cols</strong> – 新的列数。</p>\n<p><strong>size</strong> – 替代新矩阵大小规格：Size(cols, rows)。</p>\n<p><strong>sizes</strong> – 指定一个新的阵列形状的整数数组。</p>\n<p><strong>type</strong> – 新矩阵的类型。</p>\n<p>这是关键的Mat方法之一。大多数新样式 OpenCV 函数和产生阵列的方法每个输出数组都调用这个方法。此方法使用如下算法：</p>\n<p>1.如果当前数组形状和类型匹配新的请立即返回。否则，通过调用 Mat::release()取消引用以前的数据。</p>\n<p>2.初始化新矩阵头。</p>\n<p>3.分配新的 total()*elemSize() 个字节的数据空间。</p>\n<p>4.分配新的关联数据的引用计数并将其设置为 1。</p>\n"},{"_content":"# CMakelists基础指令 \n\n## （1）include_directories \n\n用于设置头文件的相对路径。全局路径默认是功能包所在目录，一般会放在功能包根目录下的include文件夹中，所以此处需要添加该文件夹。此外，该配置项还包含ROS catkin编译器默认包含的其他头文件路径${catkin_INCLUDE_DIRS}，比如ROS默认安装路径、Linux系统路径等。在本例中，所用的是ROS默认安装路径下的头文件。 \n\n##  （2）add_executable \n\n用于设置需要编译的代码和生成的可执行文件。第一个参数为期望生成的可执行文件的名称，后边的参数为参与编译的源码文件（cpp），如果需要多个代码文件，则可在后面依次列出，中间用空格进行分隔。 \n\n##  （3）target_link_libraries \n\n用于设置链接库。很多功能需要使用系统或者第三方的库函数，通过该选项可以配置 执行文件链接的库文件，第一个参数是可执行文件的名称，后面依次列出需要链接的库。此处编译没有使用其他库，添加默认链接库${catkin_LIBRARIES}即可。 \n\n##  （4）add_dependencies \n\n用于设置依赖。在很多应用中，我们需要定义语言无关的消息类型，消息类型会在编译过程中产生相应语言的代码，如果编译的可执行文件依赖这些动态生成的代码，则需要使用add_dependencies添加${PROJECT_NAME}_generate_messages_cpp 配置，即该功能包动态产生的消息代码。该编译规则也可以添加其他需要依赖的功能包。 ","source":"_posts/C++/CMakelists基础指令.md","raw":"# CMakelists基础指令 \n\n## （1）include_directories \n\n用于设置头文件的相对路径。全局路径默认是功能包所在目录，一般会放在功能包根目录下的include文件夹中，所以此处需要添加该文件夹。此外，该配置项还包含ROS catkin编译器默认包含的其他头文件路径${catkin_INCLUDE_DIRS}，比如ROS默认安装路径、Linux系统路径等。在本例中，所用的是ROS默认安装路径下的头文件。 \n\n##  （2）add_executable \n\n用于设置需要编译的代码和生成的可执行文件。第一个参数为期望生成的可执行文件的名称，后边的参数为参与编译的源码文件（cpp），如果需要多个代码文件，则可在后面依次列出，中间用空格进行分隔。 \n\n##  （3）target_link_libraries \n\n用于设置链接库。很多功能需要使用系统或者第三方的库函数，通过该选项可以配置 执行文件链接的库文件，第一个参数是可执行文件的名称，后面依次列出需要链接的库。此处编译没有使用其他库，添加默认链接库${catkin_LIBRARIES}即可。 \n\n##  （4）add_dependencies \n\n用于设置依赖。在很多应用中，我们需要定义语言无关的消息类型，消息类型会在编译过程中产生相应语言的代码，如果编译的可执行文件依赖这些动态生成的代码，则需要使用add_dependencies添加${PROJECT_NAME}_generate_messages_cpp 配置，即该功能包动态产生的消息代码。该编译规则也可以添加其他需要依赖的功能包。 ","slug":"C++/CMakelists基础指令","published":1,"date":"2023-08-24T14:38:18.612Z","updated":"2022-12-30T03:13:44.814Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0tc000gdkr7cjuv8qyb","content":"<h1 id=\"CMakelists基础指令\"><a href=\"#CMakelists基础指令\" class=\"headerlink\" title=\"CMakelists基础指令\"></a>CMakelists基础指令</h1><h2 id=\"（1）include-directories\"><a href=\"#（1）include-directories\" class=\"headerlink\" title=\"（1）include_directories\"></a>（1）include_directories</h2><p>用于设置头文件的相对路径。全局路径默认是功能包所在目录，一般会放在功能包根目录下的include文件夹中，所以此处需要添加该文件夹。此外，该配置项还包含ROS catkin编译器默认包含的其他头文件路径${catkin_INCLUDE_DIRS}，比如ROS默认安装路径、Linux系统路径等。在本例中，所用的是ROS默认安装路径下的头文件。 </p>\n<h2 id=\"（2）add-executable\"><a href=\"#（2）add-executable\" class=\"headerlink\" title=\"（2）add_executable\"></a>（2）add_executable</h2><p>用于设置需要编译的代码和生成的可执行文件。第一个参数为期望生成的可执行文件的名称，后边的参数为参与编译的源码文件（cpp），如果需要多个代码文件，则可在后面依次列出，中间用空格进行分隔。 </p>\n<h2 id=\"（3）target-link-libraries\"><a href=\"#（3）target-link-libraries\" class=\"headerlink\" title=\"（3）target_link_libraries\"></a>（3）target_link_libraries</h2><p>用于设置链接库。很多功能需要使用系统或者第三方的库函数，通过该选项可以配置 执行文件链接的库文件，第一个参数是可执行文件的名称，后面依次列出需要链接的库。此处编译没有使用其他库，添加默认链接库${catkin_LIBRARIES}即可。 </p>\n<h2 id=\"（4）add-dependencies\"><a href=\"#（4）add-dependencies\" class=\"headerlink\" title=\"（4）add_dependencies\"></a>（4）add_dependencies</h2><p>用于设置依赖。在很多应用中，我们需要定义语言无关的消息类型，消息类型会在编译过程中产生相应语言的代码，如果编译的可执行文件依赖这些动态生成的代码，则需要使用add_dependencies添加${PROJECT_NAME}_generate_messages_cpp 配置，即该功能包动态产生的消息代码。该编译规则也可以添加其他需要依赖的功能包。 </p>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-6.png","cover_type":"img","excerpt":"","more":"<h1 id=\"CMakelists基础指令\"><a href=\"#CMakelists基础指令\" class=\"headerlink\" title=\"CMakelists基础指令\"></a>CMakelists基础指令</h1><h2 id=\"（1）include-directories\"><a href=\"#（1）include-directories\" class=\"headerlink\" title=\"（1）include_directories\"></a>（1）include_directories</h2><p>用于设置头文件的相对路径。全局路径默认是功能包所在目录，一般会放在功能包根目录下的include文件夹中，所以此处需要添加该文件夹。此外，该配置项还包含ROS catkin编译器默认包含的其他头文件路径${catkin_INCLUDE_DIRS}，比如ROS默认安装路径、Linux系统路径等。在本例中，所用的是ROS默认安装路径下的头文件。 </p>\n<h2 id=\"（2）add-executable\"><a href=\"#（2）add-executable\" class=\"headerlink\" title=\"（2）add_executable\"></a>（2）add_executable</h2><p>用于设置需要编译的代码和生成的可执行文件。第一个参数为期望生成的可执行文件的名称，后边的参数为参与编译的源码文件（cpp），如果需要多个代码文件，则可在后面依次列出，中间用空格进行分隔。 </p>\n<h2 id=\"（3）target-link-libraries\"><a href=\"#（3）target-link-libraries\" class=\"headerlink\" title=\"（3）target_link_libraries\"></a>（3）target_link_libraries</h2><p>用于设置链接库。很多功能需要使用系统或者第三方的库函数，通过该选项可以配置 执行文件链接的库文件，第一个参数是可执行文件的名称，后面依次列出需要链接的库。此处编译没有使用其他库，添加默认链接库${catkin_LIBRARIES}即可。 </p>\n<h2 id=\"（4）add-dependencies\"><a href=\"#（4）add-dependencies\" class=\"headerlink\" title=\"（4）add_dependencies\"></a>（4）add_dependencies</h2><p>用于设置依赖。在很多应用中，我们需要定义语言无关的消息类型，消息类型会在编译过程中产生相应语言的代码，如果编译的可执行文件依赖这些动态生成的代码，则需要使用add_dependencies添加${PROJECT_NAME}_generate_messages_cpp 配置，即该功能包动态产生的消息代码。该编译规则也可以添加其他需要依赖的功能包。 </p>\n"},{"_content":"# Protocol Buffers基本使用\n\n> - Protocol Buffer 和 XML、JSON一样都是结构数据序列化的工具，但它们的数据格式有比较大的区别：\n>   - 首先，Protocol Buffer 序列化之后得到的数据不是可读的字符串，而是二进制流\n>   - 其次，XML 和 JSON 格式的数据信息都包含在了序列化之后的数据中，不需要任何其它信息就能还原序列化之后的数据；但使用 Protocol Buffer 需要事先定义数据的格式(.proto 协议文件)，还原一个序列化之后的数据需要使用到这个定义好的数据格式\n>   - 最后，在传输数据量较大的需求场景下，Protocol Buffer 比 XML、JSON 更小（3到10倍）、更快（20到100倍）、使用 & 维护更简单；而且 Protocol Buffer 可以跨平台、跨语音使用\n> - Protobuf 安装：\n>   - 安装 protobuf： apt-get install protobuf-compiler\n>   - 安装 protobuf 的 python 模块：pip3 install protobuf==3.13.0\n>   - 源码方式安装：可参考 Protobuf 安装及使用 && https://github.com/protocolbuffers/protobuf/blob/main/src/README.md\n> - Protobuf 版本查看：\n>   - protoc --version\n>   - import google.protobuf as gp, gp.__version__\n\n## Protocol Buffer 的作用\n\n- 通过将结构化的数据（拥有多种属性）进行序列化，从而实现（内存与硬盘之间）数据存储和交换的功能\n  - 序列化： 按照 `.proto` 协议文件将`数据结构或对象`转换成`二进制流`的过程\n  - 反序列化：将在序列化过程中所生成的`二进制流`转换成`数据结构或对象`的过程\n\n![Protocol Buffer 特点](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1hOWIzZmMyZWQxNmY2MWU1LnBuZw)\n\n## Protocol Buffer 语法\n\n![](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS01NjYzNTk5ZTg0MzNmNWI4LnBuZw.png)\n\n### 关注1：包名\n\n```protobuf\npackage protocobuff_Demo;\n// 关注1：包名\n```\n\n- 作用：防止不同 .proto 项目间命名 发生冲突\n\n- Protocol buffer包的解析过程如下：\n\n  1. Protocol buffer 的类型名称解析与 C++ 一致：从 最内部 开始查找，依次向外进行每个包会被看作是其父类包的内部类\n  2. Protocol buffer 编译器会解析 .proto文件中定义的所有类型名\n  3. 生成器会根据 不同语言 生成 对应语言 的代码文件\n\n  > a. 即对 不同语言 使用了 不同的规则 进行处理\n  >\n  > b. Protoco Buffer提供 C++、Java、Python 三种语言的 API\n\n### 关注2：Option选项\n\n```protobuf\noption java_package = \"com.carson.proto\";\noption java_outer_classname = \"Demo\";\n// 关注2：option选项\n```\n\n- 作用：影响 特定环境下 的处理方式\n\n- 常用Option选项如下：\n\n  ```protobuf\n  option java_package = \"com.carson.proto\";\n  // 定义：Java包名\n  // 作用：指定生成的类应该放在什么Java包名下\n  // 注：如不显式指定，默认包名为：按照应用名称倒序方式进行排序\n  \n  option java_outer_classname = \"Demo\";\n  // 定义：类名\n  // 作用：生成对应.java 文件的类名（不能跟下面message的类名相同）\n  // 注：如不显式指定，则默认为把.proto文件名转换为首字母大写来生成\n  // 如.proto文件名=\"my_proto.proto\"，默认情况下，将使用 \"MyProto\" 做为类名\n  \n  option optimize_for = ***;\n  // 作用：影响 C++  & java 代码的生成\n  // ***参数如下：\n  // 1. SPEED (默认):：protocol buffer编译器将通过在消息类型上执行序列化、语法分析及其他通用的操作。（最优方式）\n  // 2. CODE_SIZE:：编译器将会产生最少量的类，通过共享或基于反射的代码来实现序列化、语法分析及各种其它操作。\n    // 特点：采用该方式产生的代码将比SPEED要少很多， 但是效率较低；\n    // 使用场景：常用在 包含大量.proto文件 但 不追求效率 的应用中。\n  //3.  LITE_RUNTIME:：编译器依赖于运行时 核心类库 来生成代码（即采用libprotobuf-lite 替代libprotobuf）。\n    // 特点：这种核心类库要比全类库小得多（忽略了 一些描述符及反射 ）；编译器采用该模式产生的方法实现与SPEED模式不相上下，产生的类通过实现 MessageLite接口，但它仅仅是Messager接口的一个子集。\n    // 应用场景：移动手机平台应用\n  \n  option cc_generic_services = false;\n  option java_generic_services = false;\n  option py_generic_services = false;\n  // 作用：定义在C++、java、python中，protocol buffer编译器是否应该 基于服务定义 产生 抽象服务代码（2.3.0版本前该值默认 = true）\n  // 自2.3.0版本以来，官方认为通过提供 代码生成器插件 来对 RPC实现 更可取，而不是依赖于“抽象”服务\n  \n  optional repeated int32 samples = 4 [packed=true];\n  // 如果该选项在一个整型基本类型上被设置为真，则采用更紧凑的编码方式（不会对数值造成损失）\n  // 在2.3.0版本前，解析器将会忽略 非期望的包装值。因此，它不可能在 不破坏现有框架的兼容性上 而 改变压缩格式。\n  // 在2.3.0之后，这种改变将是安全的，解析器能够接受上述两种格式。\n  \n  optional int32 old_field = 6 [deprecated=true];\n  // 作用：判断该字段是否已经被弃用\n  // 作用同 在java中的注解@Deprecated\n  ```\n\n### 关注3：消息模型\n\n- 作用：真正用于描述 数据结构\n\n```protobuf\n// 消息对象用message修饰\nmessage Person {\n\n  required string name = 1;\n  required int32 id = 2;\n  optional string email = 3;\n\n  enum PhoneType {\n    MOBILE = 0;\n    HOME = 1;\n    WORK = 2;\n  }\n\n  message PhoneNumber {\n    optional PhoneType type = 2 [default = HOME];\n  }\n\n  repeated PhoneNumber phone = 4;\n}\n\nmessage AddressBook {\n  repeated Person person = 1;\n}\n```\n\n- 组成：在ProtocolBuffers中：\n  1. 一个 `.proto` 消息模型 = 一个 `.proto`文件 = 消息对象 + 字段\n  2. 一个消息对象（`Message`） = 一个 结构化数据\n  3. 消息对象（`Message`）里的 字段 = 结构化数据 里的成员变量\n\n![](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0wM2ViZDRkZjlkZTVkNTU1LnBuZw.png)\n\n下面会详细介绍 `.proto` 消息模型里的 消息对象 & 字段\n\n![](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGJhY2Q4N2Y0NDlkYmI4LnBuZw.png)\n\n#### 1. 消息对象\n\n在 `ProtocolBuffers` 中：\n\n- 一个消息对象（`Message`） = 一个 结构化数据\n- 消息对象用 修饰符 `message` 修饰\n- 消息对象 含有 字段：消息对象（`Message`）里的 字段 = 结构化数据 里的成员变量\n\n![](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0wM2ViZDRkZjlkZTVkNTU1LnBuZw.png)\n\n![](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iNDg4YzYyMDk0NTE2ZTBjLnBuZw.png)\n\n##### a. 添加：在一个 .proto文件 中可定义多个 消息对象\n\n- 应用场景：尽可能将与 某一消息类型 对应的响应消息格式 定义到相同的 `.proto`文件 中\n- 实例：\n\n```protobuf\nmessage SearchRequest {\n\n  required string query = 1;\n  optional int32 page_number = 2;\n  optional int32 result_per_page = 3;\n\n}\n\n// 与SearchRequest消息类型 对应的 响应消息类型SearchResponse\nmessage SearchResponse {\n …\n}\n```\n\n##### b. 一个消息对象 里 可以定义 另外一个消息对象（即嵌套）\n\n```\nmessage Person {\n  required string name = 1;\n  required int32 id = 2;\n  optional string email = 3;\n\n// 该消息类型 定义在 Person消息类型的内部\n// 即Person消息类型 是 PhoneNumber消息类型的父消息类型\n  message PhoneNumber {\n    required string number = 1;\n  }\n}\n\n<-- 多重嵌套 -->\nmessage Outer {   // Level 0\n  message MiddleAA {  // Level 1\n    message Inner {   // Level 2\n      required int64 ival = 1;\n      optional bool  booly = 2;\n    }\n  }\n}\n```\n\n#### 2. 字段\n\n- 消息对象的字段 组成主要是：**字段 = 字段修饰符 + 字段类型 +字段名 +标识号**\n\n![](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGI3ZTczMjExYjRjODliLnBuZw.png)\n\n##### **a. 字段修饰符**\n\n- 作用：设置该字段解析时的规则\n\n- 具体类型如下：\n\n  ![](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iZjE3MjU0NTIwOWI4N2UxLnBuZw.png)\n\n**b. 字段类型**\n字段类型主要有 三 类：\n\n- 基本数据 类型\n- 枚举 类型\n- 消息对象 类型\n\n```protobuf\nmessage Person {\n\n  // 基本数据类型 字段\n  required string name = 1;\n  required int32 id = 2;\n  optional string email = 3;\n\n  enum PhoneType {\n    MOBILE = 0;\n    HOME = 1;\n    WORK = 2;\n  }\n\n  message PhoneNumber {\n    optional PhoneType type = 2 [default = HOME];\n    // 枚举类型 字段\n  }\n\n  repeated PhoneNumber phone = 4;\n  // 消息类型 字段\n}\n```\n\n###### 1.基本数据类型\n\n| .proto中的类型 | 注意                                                         | C++中类型 | java中类型 |\n| -------------- | ------------------------------------------------------------ | --------- | ---------- |\n| double         |                                                              | double    | double     |\n| float          |                                                              | float     | float      |\n| int32          | 自动调整编码长度，如果需要保存负数，请使用sint32             | int32     | int        |\n| int64          | 自动调整编码长度，如果需要保存负数，请使用sint64             | int64     | long       |\n| uint32         | 自动调整编码长度                                             | uint32    | int        |\n| uint64         | 自动调整编码长度                                             | uint64    | long       |\n| sint32         | 自动调整编码长度，表示有符号数，负数的编码效率高于int32      | int32     | int        |\n| sint64         | 自动调整编码长度，表示有符号数，负数的编码效率高于int64      | int64     | long       |\n| fixed32        | 固定使用4bytes编码，在编码大数(228228)的时候比uint32更有效率 | int32     | int        |\n| fixed32        | 固定使用8bytes编码，在编码大数(256256)的时候比uint64更有效率 | int42     | long       |\n| sfixed32       | 固定使用4bytes编码                                           | int32     | int        |\n| sfixed64       | 固定使用8bytes编码                                           | int64     | long       |\n| bool           |                                                              | bool      | boolean    |\n| string         | string只能包含UTF-8和7-bit ASCII文本                         | string    | String     |\n| bytes          | 包含任意长度的bytes                                          | string    | ByteString |\n\n###### 2. 枚举类型\n\n- 作用：为字段指定一个 可能取值的字段集合\n\n> 该字段只能从 该指定的字段集合里 取值\n\n- 说明：如下面例子，电话号码 可能是手机号、家庭电话号或工作电话号的其中一个，那么就将`PhoneType`定义为枚举类型，并将加入电话的集合（ `MOBILE`、 `HOME`、`WORK`）\n\n```protobuf\n// 枚举类型需要先定义才能进行使用\n\n// 枚举类型 定义\n enum PhoneType {\n    MOBILE = 0;\n    HOME = 1;\n    WORK = 2;\n// 电话类型字段 只能从 这个集合里 取值\n  }\n\n// 特别注意：\n// 1. 枚举类型的定义可在一个消息对象的内部或外部\n// 2. 都可以在 同一.proto文件 中的任何消息对象里使用\n// 3. 当枚举类型是在一消息内部定义，希望在 另一个消息中 使用时，需要采用MessageType.EnumType的语法格式\n\n  message PhoneNumber {\n    required string number = 1;\n    optional PhoneType type = 2 [default = HOME];\n    // 使用枚举类型的字段（设置了默认值）\n  }\n\n// 特别注意：\n// 1.  枚举常量必须在32位整型值的范围内\n// 2. 不推荐在enum中使用负数：因为enum值是使用可变编码方式的，对负数不够高\n```\n\n###### 3. 消息对象 类型\n\n一个消息对象 可以将 其他消息对象类型 用作字段类型，情况如下：\n\n![](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS04Nzc5YmMwOWE1M2ViNDBjLnBuZw.png)\n\n- **使用 内部消息类型**\n\n  - 先在 消息类型 中定义 其他消息类型 ，然后再使用\n\n  ```protobuf\n  message Person {\n    required string name = 1;\n    required int32 id = 2;\n    optional string email = 3;\n  \n  // 该消息类型 定义在 Person消息类型的内部\n  // 即Person消息类型 是 PhoneNumber消息类型的父消息类型\n    message PhoneNumber {\n      required string number = 1;\n    }\n  \n    repeated PhoneNumber phone = 4;\n    // 直接使用内部消息类型\n  }\n  ```\n\n- **使用** **外部消息类型**\n\n  - 即外部重用，需要 用作字段类型的消息类型 定义在 该消息类型外部\n\n  ```protobuf\n  message Person {\n    required string name = 1;\n    required int32 id = 2;\n    optional string email = 3;\n  }\n  \n  message AddressBook {\n    repeated Person person = 1;\n    // 直接使用了 Person消息类型作为消息字段\n  }\n  ```\n\n- **使用** **外部消息的内部消息类型**\n\n  ```protobuf\n  message Person {\n    required string name = 1;\n    required int32 id = 2;\n    optional string email = 3;\n  \n  // PhoneNumber消息类型 是 Person消息类型的内部消息类型\n    message PhoneNumber {\n      required string number = 1;\n      optional PhoneType type = 2 [default = HOME];\n    }\n  }\n  \n  // 若父消息类型外部的消息类型需要重用该内部消息类型\n  // 需要以 Parent.Type 的形式去使用\n  // Parent = 需要使用消息类型的父消息类型，Type = 需要使用的消息类型\n  \n  // PhoneNumber父消息类型Person 的外部 OtherMessage消息类型 需要使用 PhoneNumber消息类型\n  message OtherMessage {\n    optional Person.PhoneNumber phonenumber = 1;\n  // 以 Parent.Type = Person.PhoneNumber  的形式去使用\n  \n  }\n  ```\n\n- **使用不同** .**proto** **文件里的消息类型**\n\n  - 目的：需要在 `A.proto`文件 使用 `B.proto`文件里的消息类型\n\n  - 解决方案：在 `A.proto`文件 通过导入（ `import`） `B.proto`文件中来使用 `B.proto`文件 里的消息类型\n\n    ```protobuf\n    import \"myproject/other_protos.proto\"\n    // 在A.proto 文件中添加 B.proto文件路径的导入声明\n    // ProtocolBuffer编译器 会在 该目录中 查找需要被导入的 .proto文件\n    // 如果不提供参数，编译器就在 其调用的目录下 查找\n    ```\n\n    ","source":"_posts/C++/Protocol_Buffers基本使用.md","raw":"# Protocol Buffers基本使用\n\n> - Protocol Buffer 和 XML、JSON一样都是结构数据序列化的工具，但它们的数据格式有比较大的区别：\n>   - 首先，Protocol Buffer 序列化之后得到的数据不是可读的字符串，而是二进制流\n>   - 其次，XML 和 JSON 格式的数据信息都包含在了序列化之后的数据中，不需要任何其它信息就能还原序列化之后的数据；但使用 Protocol Buffer 需要事先定义数据的格式(.proto 协议文件)，还原一个序列化之后的数据需要使用到这个定义好的数据格式\n>   - 最后，在传输数据量较大的需求场景下，Protocol Buffer 比 XML、JSON 更小（3到10倍）、更快（20到100倍）、使用 & 维护更简单；而且 Protocol Buffer 可以跨平台、跨语音使用\n> - Protobuf 安装：\n>   - 安装 protobuf： apt-get install protobuf-compiler\n>   - 安装 protobuf 的 python 模块：pip3 install protobuf==3.13.0\n>   - 源码方式安装：可参考 Protobuf 安装及使用 && https://github.com/protocolbuffers/protobuf/blob/main/src/README.md\n> - Protobuf 版本查看：\n>   - protoc --version\n>   - import google.protobuf as gp, gp.__version__\n\n## Protocol Buffer 的作用\n\n- 通过将结构化的数据（拥有多种属性）进行序列化，从而实现（内存与硬盘之间）数据存储和交换的功能\n  - 序列化： 按照 `.proto` 协议文件将`数据结构或对象`转换成`二进制流`的过程\n  - 反序列化：将在序列化过程中所生成的`二进制流`转换成`数据结构或对象`的过程\n\n![Protocol Buffer 特点](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1hOWIzZmMyZWQxNmY2MWU1LnBuZw)\n\n## Protocol Buffer 语法\n\n![](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS01NjYzNTk5ZTg0MzNmNWI4LnBuZw.png)\n\n### 关注1：包名\n\n```protobuf\npackage protocobuff_Demo;\n// 关注1：包名\n```\n\n- 作用：防止不同 .proto 项目间命名 发生冲突\n\n- Protocol buffer包的解析过程如下：\n\n  1. Protocol buffer 的类型名称解析与 C++ 一致：从 最内部 开始查找，依次向外进行每个包会被看作是其父类包的内部类\n  2. Protocol buffer 编译器会解析 .proto文件中定义的所有类型名\n  3. 生成器会根据 不同语言 生成 对应语言 的代码文件\n\n  > a. 即对 不同语言 使用了 不同的规则 进行处理\n  >\n  > b. Protoco Buffer提供 C++、Java、Python 三种语言的 API\n\n### 关注2：Option选项\n\n```protobuf\noption java_package = \"com.carson.proto\";\noption java_outer_classname = \"Demo\";\n// 关注2：option选项\n```\n\n- 作用：影响 特定环境下 的处理方式\n\n- 常用Option选项如下：\n\n  ```protobuf\n  option java_package = \"com.carson.proto\";\n  // 定义：Java包名\n  // 作用：指定生成的类应该放在什么Java包名下\n  // 注：如不显式指定，默认包名为：按照应用名称倒序方式进行排序\n  \n  option java_outer_classname = \"Demo\";\n  // 定义：类名\n  // 作用：生成对应.java 文件的类名（不能跟下面message的类名相同）\n  // 注：如不显式指定，则默认为把.proto文件名转换为首字母大写来生成\n  // 如.proto文件名=\"my_proto.proto\"，默认情况下，将使用 \"MyProto\" 做为类名\n  \n  option optimize_for = ***;\n  // 作用：影响 C++  & java 代码的生成\n  // ***参数如下：\n  // 1. SPEED (默认):：protocol buffer编译器将通过在消息类型上执行序列化、语法分析及其他通用的操作。（最优方式）\n  // 2. CODE_SIZE:：编译器将会产生最少量的类，通过共享或基于反射的代码来实现序列化、语法分析及各种其它操作。\n    // 特点：采用该方式产生的代码将比SPEED要少很多， 但是效率较低；\n    // 使用场景：常用在 包含大量.proto文件 但 不追求效率 的应用中。\n  //3.  LITE_RUNTIME:：编译器依赖于运行时 核心类库 来生成代码（即采用libprotobuf-lite 替代libprotobuf）。\n    // 特点：这种核心类库要比全类库小得多（忽略了 一些描述符及反射 ）；编译器采用该模式产生的方法实现与SPEED模式不相上下，产生的类通过实现 MessageLite接口，但它仅仅是Messager接口的一个子集。\n    // 应用场景：移动手机平台应用\n  \n  option cc_generic_services = false;\n  option java_generic_services = false;\n  option py_generic_services = false;\n  // 作用：定义在C++、java、python中，protocol buffer编译器是否应该 基于服务定义 产生 抽象服务代码（2.3.0版本前该值默认 = true）\n  // 自2.3.0版本以来，官方认为通过提供 代码生成器插件 来对 RPC实现 更可取，而不是依赖于“抽象”服务\n  \n  optional repeated int32 samples = 4 [packed=true];\n  // 如果该选项在一个整型基本类型上被设置为真，则采用更紧凑的编码方式（不会对数值造成损失）\n  // 在2.3.0版本前，解析器将会忽略 非期望的包装值。因此，它不可能在 不破坏现有框架的兼容性上 而 改变压缩格式。\n  // 在2.3.0之后，这种改变将是安全的，解析器能够接受上述两种格式。\n  \n  optional int32 old_field = 6 [deprecated=true];\n  // 作用：判断该字段是否已经被弃用\n  // 作用同 在java中的注解@Deprecated\n  ```\n\n### 关注3：消息模型\n\n- 作用：真正用于描述 数据结构\n\n```protobuf\n// 消息对象用message修饰\nmessage Person {\n\n  required string name = 1;\n  required int32 id = 2;\n  optional string email = 3;\n\n  enum PhoneType {\n    MOBILE = 0;\n    HOME = 1;\n    WORK = 2;\n  }\n\n  message PhoneNumber {\n    optional PhoneType type = 2 [default = HOME];\n  }\n\n  repeated PhoneNumber phone = 4;\n}\n\nmessage AddressBook {\n  repeated Person person = 1;\n}\n```\n\n- 组成：在ProtocolBuffers中：\n  1. 一个 `.proto` 消息模型 = 一个 `.proto`文件 = 消息对象 + 字段\n  2. 一个消息对象（`Message`） = 一个 结构化数据\n  3. 消息对象（`Message`）里的 字段 = 结构化数据 里的成员变量\n\n![](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0wM2ViZDRkZjlkZTVkNTU1LnBuZw.png)\n\n下面会详细介绍 `.proto` 消息模型里的 消息对象 & 字段\n\n![](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGJhY2Q4N2Y0NDlkYmI4LnBuZw.png)\n\n#### 1. 消息对象\n\n在 `ProtocolBuffers` 中：\n\n- 一个消息对象（`Message`） = 一个 结构化数据\n- 消息对象用 修饰符 `message` 修饰\n- 消息对象 含有 字段：消息对象（`Message`）里的 字段 = 结构化数据 里的成员变量\n\n![](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0wM2ViZDRkZjlkZTVkNTU1LnBuZw.png)\n\n![](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iNDg4YzYyMDk0NTE2ZTBjLnBuZw.png)\n\n##### a. 添加：在一个 .proto文件 中可定义多个 消息对象\n\n- 应用场景：尽可能将与 某一消息类型 对应的响应消息格式 定义到相同的 `.proto`文件 中\n- 实例：\n\n```protobuf\nmessage SearchRequest {\n\n  required string query = 1;\n  optional int32 page_number = 2;\n  optional int32 result_per_page = 3;\n\n}\n\n// 与SearchRequest消息类型 对应的 响应消息类型SearchResponse\nmessage SearchResponse {\n …\n}\n```\n\n##### b. 一个消息对象 里 可以定义 另外一个消息对象（即嵌套）\n\n```\nmessage Person {\n  required string name = 1;\n  required int32 id = 2;\n  optional string email = 3;\n\n// 该消息类型 定义在 Person消息类型的内部\n// 即Person消息类型 是 PhoneNumber消息类型的父消息类型\n  message PhoneNumber {\n    required string number = 1;\n  }\n}\n\n<-- 多重嵌套 -->\nmessage Outer {   // Level 0\n  message MiddleAA {  // Level 1\n    message Inner {   // Level 2\n      required int64 ival = 1;\n      optional bool  booly = 2;\n    }\n  }\n}\n```\n\n#### 2. 字段\n\n- 消息对象的字段 组成主要是：**字段 = 字段修饰符 + 字段类型 +字段名 +标识号**\n\n![](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGI3ZTczMjExYjRjODliLnBuZw.png)\n\n##### **a. 字段修饰符**\n\n- 作用：设置该字段解析时的规则\n\n- 具体类型如下：\n\n  ![](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iZjE3MjU0NTIwOWI4N2UxLnBuZw.png)\n\n**b. 字段类型**\n字段类型主要有 三 类：\n\n- 基本数据 类型\n- 枚举 类型\n- 消息对象 类型\n\n```protobuf\nmessage Person {\n\n  // 基本数据类型 字段\n  required string name = 1;\n  required int32 id = 2;\n  optional string email = 3;\n\n  enum PhoneType {\n    MOBILE = 0;\n    HOME = 1;\n    WORK = 2;\n  }\n\n  message PhoneNumber {\n    optional PhoneType type = 2 [default = HOME];\n    // 枚举类型 字段\n  }\n\n  repeated PhoneNumber phone = 4;\n  // 消息类型 字段\n}\n```\n\n###### 1.基本数据类型\n\n| .proto中的类型 | 注意                                                         | C++中类型 | java中类型 |\n| -------------- | ------------------------------------------------------------ | --------- | ---------- |\n| double         |                                                              | double    | double     |\n| float          |                                                              | float     | float      |\n| int32          | 自动调整编码长度，如果需要保存负数，请使用sint32             | int32     | int        |\n| int64          | 自动调整编码长度，如果需要保存负数，请使用sint64             | int64     | long       |\n| uint32         | 自动调整编码长度                                             | uint32    | int        |\n| uint64         | 自动调整编码长度                                             | uint64    | long       |\n| sint32         | 自动调整编码长度，表示有符号数，负数的编码效率高于int32      | int32     | int        |\n| sint64         | 自动调整编码长度，表示有符号数，负数的编码效率高于int64      | int64     | long       |\n| fixed32        | 固定使用4bytes编码，在编码大数(228228)的时候比uint32更有效率 | int32     | int        |\n| fixed32        | 固定使用8bytes编码，在编码大数(256256)的时候比uint64更有效率 | int42     | long       |\n| sfixed32       | 固定使用4bytes编码                                           | int32     | int        |\n| sfixed64       | 固定使用8bytes编码                                           | int64     | long       |\n| bool           |                                                              | bool      | boolean    |\n| string         | string只能包含UTF-8和7-bit ASCII文本                         | string    | String     |\n| bytes          | 包含任意长度的bytes                                          | string    | ByteString |\n\n###### 2. 枚举类型\n\n- 作用：为字段指定一个 可能取值的字段集合\n\n> 该字段只能从 该指定的字段集合里 取值\n\n- 说明：如下面例子，电话号码 可能是手机号、家庭电话号或工作电话号的其中一个，那么就将`PhoneType`定义为枚举类型，并将加入电话的集合（ `MOBILE`、 `HOME`、`WORK`）\n\n```protobuf\n// 枚举类型需要先定义才能进行使用\n\n// 枚举类型 定义\n enum PhoneType {\n    MOBILE = 0;\n    HOME = 1;\n    WORK = 2;\n// 电话类型字段 只能从 这个集合里 取值\n  }\n\n// 特别注意：\n// 1. 枚举类型的定义可在一个消息对象的内部或外部\n// 2. 都可以在 同一.proto文件 中的任何消息对象里使用\n// 3. 当枚举类型是在一消息内部定义，希望在 另一个消息中 使用时，需要采用MessageType.EnumType的语法格式\n\n  message PhoneNumber {\n    required string number = 1;\n    optional PhoneType type = 2 [default = HOME];\n    // 使用枚举类型的字段（设置了默认值）\n  }\n\n// 特别注意：\n// 1.  枚举常量必须在32位整型值的范围内\n// 2. 不推荐在enum中使用负数：因为enum值是使用可变编码方式的，对负数不够高\n```\n\n###### 3. 消息对象 类型\n\n一个消息对象 可以将 其他消息对象类型 用作字段类型，情况如下：\n\n![](media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS04Nzc5YmMwOWE1M2ViNDBjLnBuZw.png)\n\n- **使用 内部消息类型**\n\n  - 先在 消息类型 中定义 其他消息类型 ，然后再使用\n\n  ```protobuf\n  message Person {\n    required string name = 1;\n    required int32 id = 2;\n    optional string email = 3;\n  \n  // 该消息类型 定义在 Person消息类型的内部\n  // 即Person消息类型 是 PhoneNumber消息类型的父消息类型\n    message PhoneNumber {\n      required string number = 1;\n    }\n  \n    repeated PhoneNumber phone = 4;\n    // 直接使用内部消息类型\n  }\n  ```\n\n- **使用** **外部消息类型**\n\n  - 即外部重用，需要 用作字段类型的消息类型 定义在 该消息类型外部\n\n  ```protobuf\n  message Person {\n    required string name = 1;\n    required int32 id = 2;\n    optional string email = 3;\n  }\n  \n  message AddressBook {\n    repeated Person person = 1;\n    // 直接使用了 Person消息类型作为消息字段\n  }\n  ```\n\n- **使用** **外部消息的内部消息类型**\n\n  ```protobuf\n  message Person {\n    required string name = 1;\n    required int32 id = 2;\n    optional string email = 3;\n  \n  // PhoneNumber消息类型 是 Person消息类型的内部消息类型\n    message PhoneNumber {\n      required string number = 1;\n      optional PhoneType type = 2 [default = HOME];\n    }\n  }\n  \n  // 若父消息类型外部的消息类型需要重用该内部消息类型\n  // 需要以 Parent.Type 的形式去使用\n  // Parent = 需要使用消息类型的父消息类型，Type = 需要使用的消息类型\n  \n  // PhoneNumber父消息类型Person 的外部 OtherMessage消息类型 需要使用 PhoneNumber消息类型\n  message OtherMessage {\n    optional Person.PhoneNumber phonenumber = 1;\n  // 以 Parent.Type = Person.PhoneNumber  的形式去使用\n  \n  }\n  ```\n\n- **使用不同** .**proto** **文件里的消息类型**\n\n  - 目的：需要在 `A.proto`文件 使用 `B.proto`文件里的消息类型\n\n  - 解决方案：在 `A.proto`文件 通过导入（ `import`） `B.proto`文件中来使用 `B.proto`文件 里的消息类型\n\n    ```protobuf\n    import \"myproject/other_protos.proto\"\n    // 在A.proto 文件中添加 B.proto文件路径的导入声明\n    // ProtocolBuffer编译器 会在 该目录中 查找需要被导入的 .proto文件\n    // 如果不提供参数，编译器就在 其调用的目录下 查找\n    ```\n\n    ","slug":"C++/Protocol_Buffers基本使用","published":1,"date":"2023-08-24T14:38:18.633Z","updated":"2022-12-30T03:13:44.815Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0tc000hdkr75ny2d9ft","content":"<h1 id=\"Protocol-Buffers基本使用\"><a href=\"#Protocol-Buffers基本使用\" class=\"headerlink\" title=\"Protocol Buffers基本使用\"></a>Protocol Buffers基本使用</h1><blockquote>\n<ul>\n<li>Protocol Buffer 和 XML、JSON一样都是结构数据序列化的工具，但它们的数据格式有比较大的区别：<ul>\n<li>首先，Protocol Buffer 序列化之后得到的数据不是可读的字符串，而是二进制流</li>\n<li>其次，XML 和 JSON 格式的数据信息都包含在了序列化之后的数据中，不需要任何其它信息就能还原序列化之后的数据；但使用 Protocol Buffer 需要事先定义数据的格式(.proto 协议文件)，还原一个序列化之后的数据需要使用到这个定义好的数据格式</li>\n<li>最后，在传输数据量较大的需求场景下，Protocol Buffer 比 XML、JSON 更小（3到10倍）、更快（20到100倍）、使用 &amp; 维护更简单；而且 Protocol Buffer 可以跨平台、跨语音使用</li>\n</ul>\n</li>\n<li>Protobuf 安装：<ul>\n<li>安装 protobuf： apt-get install protobuf-compiler</li>\n<li>安装 protobuf 的 python 模块：pip3 install protobuf&#x3D;&#x3D;3.13.0</li>\n<li>源码方式安装：可参考 Protobuf 安装及使用 &amp;&amp; <a href=\"https://github.com/protocolbuffers/protobuf/blob/main/src/README.md\">https://github.com/protocolbuffers/protobuf/blob/main/src/README.md</a></li>\n</ul>\n</li>\n<li>Protobuf 版本查看：<ul>\n<li>protoc –version</li>\n<li>import google.protobuf as gp, gp.<strong>version</strong></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"Protocol-Buffer-的作用\"><a href=\"#Protocol-Buffer-的作用\" class=\"headerlink\" title=\"Protocol Buffer 的作用\"></a>Protocol Buffer 的作用</h2><ul>\n<li>通过将结构化的数据（拥有多种属性）进行序列化，从而实现（内存与硬盘之间）数据存储和交换的功能<ul>\n<li>序列化： 按照 <code>.proto</code> 协议文件将<code>数据结构或对象</code>转换成<code>二进制流</code>的过程</li>\n<li>反序列化：将在序列化过程中所生成的<code>二进制流</code>转换成<code>数据结构或对象</code>的过程</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1hOWIzZmMyZWQxNmY2MWU1LnBuZw\" alt=\"Protocol Buffer 特点\"></p>\n<h2 id=\"Protocol-Buffer-语法\"><a href=\"#Protocol-Buffer-语法\" class=\"headerlink\" title=\"Protocol Buffer 语法\"></a>Protocol Buffer 语法</h2><p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS01NjYzNTk5ZTg0MzNmNWI4LnBuZw.png\"></p>\n<h3 id=\"关注1：包名\"><a href=\"#关注1：包名\" class=\"headerlink\" title=\"关注1：包名\"></a>关注1：包名</h3><figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> protocobuff_Demo;</span><br><span class=\"line\"><span class=\"comment\">// 关注1：包名</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>作用：防止不同 .proto 项目间命名 发生冲突</p>\n</li>\n<li><p>Protocol buffer包的解析过程如下：</p>\n<ol>\n<li>Protocol buffer 的类型名称解析与 C++ 一致：从 最内部 开始查找，依次向外进行每个包会被看作是其父类包的内部类</li>\n<li>Protocol buffer 编译器会解析 .proto文件中定义的所有类型名</li>\n<li>生成器会根据 不同语言 生成 对应语言 的代码文件</li>\n</ol>\n<blockquote>\n<p>a. 即对 不同语言 使用了 不同的规则 进行处理</p>\n<p>b. Protoco Buffer提供 C++、Java、Python 三种语言的 API</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"关注2：Option选项\"><a href=\"#关注2：Option选项\" class=\"headerlink\" title=\"关注2：Option选项\"></a>关注2：Option选项</h3><figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">option</span> java_package = <span class=\"string\">&quot;com.carson.proto&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">option</span> java_outer_classname = <span class=\"string\">&quot;Demo&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 关注2：option选项</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>作用：影响 特定环境下 的处理方式</p>\n</li>\n<li><p>常用Option选项如下：</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">option</span> java_package = <span class=\"string\">&quot;com.carson.proto&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 定义：Java包名</span></span><br><span class=\"line\"><span class=\"comment\">// 作用：指定生成的类应该放在什么Java包名下</span></span><br><span class=\"line\"><span class=\"comment\">// 注：如不显式指定，默认包名为：按照应用名称倒序方式进行排序</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">option</span> java_outer_classname = <span class=\"string\">&quot;Demo&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 定义：类名</span></span><br><span class=\"line\"><span class=\"comment\">// 作用：生成对应.java 文件的类名（不能跟下面message的类名相同）</span></span><br><span class=\"line\"><span class=\"comment\">// 注：如不显式指定，则默认为把.proto文件名转换为首字母大写来生成</span></span><br><span class=\"line\"><span class=\"comment\">// 如.proto文件名=&quot;my_proto.proto&quot;，默认情况下，将使用 &quot;MyProto&quot; 做为类名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">option</span> optimize_for = ***;</span><br><span class=\"line\"><span class=\"comment\">// 作用：影响 C++  &amp; java 代码的生成</span></span><br><span class=\"line\"><span class=\"comment\">// ***参数如下：</span></span><br><span class=\"line\"><span class=\"comment\">// 1. SPEED (默认):：protocol buffer编译器将通过在消息类型上执行序列化、语法分析及其他通用的操作。（最优方式）</span></span><br><span class=\"line\"><span class=\"comment\">// 2. CODE_SIZE:：编译器将会产生最少量的类，通过共享或基于反射的代码来实现序列化、语法分析及各种其它操作。</span></span><br><span class=\"line\">  <span class=\"comment\">// 特点：采用该方式产生的代码将比SPEED要少很多， 但是效率较低；</span></span><br><span class=\"line\">  <span class=\"comment\">// 使用场景：常用在 包含大量.proto文件 但 不追求效率 的应用中。</span></span><br><span class=\"line\"><span class=\"comment\">//3.  LITE_RUNTIME:：编译器依赖于运行时 核心类库 来生成代码（即采用libprotobuf-lite 替代libprotobuf）。</span></span><br><span class=\"line\">  <span class=\"comment\">// 特点：这种核心类库要比全类库小得多（忽略了 一些描述符及反射 ）；编译器采用该模式产生的方法实现与SPEED模式不相上下，产生的类通过实现 MessageLite接口，但它仅仅是Messager接口的一个子集。</span></span><br><span class=\"line\">  <span class=\"comment\">// 应用场景：移动手机平台应用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">option</span> cc_generic_services = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">option</span> java_generic_services = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">option</span> py_generic_services = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"comment\">// 作用：定义在C++、java、python中，protocol buffer编译器是否应该 基于服务定义 产生 抽象服务代码（2.3.0版本前该值默认 = true）</span></span><br><span class=\"line\"><span class=\"comment\">// 自2.3.0版本以来，官方认为通过提供 代码生成器插件 来对 RPC实现 更可取，而不是依赖于“抽象”服务</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">optional</span> <span class=\"keyword\">repeated</span> <span class=\"type\">int32</span> samples = <span class=\"number\">4</span> [packed=<span class=\"literal\">true</span>];</span><br><span class=\"line\"><span class=\"comment\">// 如果该选项在一个整型基本类型上被设置为真，则采用更紧凑的编码方式（不会对数值造成损失）</span></span><br><span class=\"line\"><span class=\"comment\">// 在2.3.0版本前，解析器将会忽略 非期望的包装值。因此，它不可能在 不破坏现有框架的兼容性上 而 改变压缩格式。</span></span><br><span class=\"line\"><span class=\"comment\">// 在2.3.0之后，这种改变将是安全的，解析器能够接受上述两种格式。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">optional</span> <span class=\"type\">int32</span> old_field = <span class=\"number\">6</span> [deprecated=<span class=\"literal\">true</span>];</span><br><span class=\"line\"><span class=\"comment\">// 作用：判断该字段是否已经被弃用</span></span><br><span class=\"line\"><span class=\"comment\">// 作用同 在java中的注解@Deprecated</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"关注3：消息模型\"><a href=\"#关注3：消息模型\" class=\"headerlink\" title=\"关注3：消息模型\"></a>关注3：消息模型</h3><ul>\n<li>作用：真正用于描述 数据结构</li>\n</ul>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 消息对象用message修饰</span></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">string</span> name = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">int32</span> id = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">optional</span> <span class=\"type\">string</span> email = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">enum </span><span class=\"title class_\">PhoneType</span> &#123;</span><br><span class=\"line\">    MOBILE = <span class=\"number\">0</span>;</span><br><span class=\"line\">    HOME = <span class=\"number\">1</span>;</span><br><span class=\"line\">    WORK = <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">message </span><span class=\"title class_\">PhoneNumber</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">optional</span> PhoneType type = <span class=\"number\">2</span> [default = HOME];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">repeated</span> PhoneNumber phone = <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">AddressBook</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">repeated</span> Person person = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>组成：在ProtocolBuffers中：<ol>\n<li>一个 <code>.proto</code> 消息模型 &#x3D; 一个 <code>.proto</code>文件 &#x3D; 消息对象 + 字段</li>\n<li>一个消息对象（<code>Message</code>） &#x3D; 一个 结构化数据</li>\n<li>消息对象（<code>Message</code>）里的 字段 &#x3D; 结构化数据 里的成员变量</li>\n</ol>\n</li>\n</ul>\n<p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0wM2ViZDRkZjlkZTVkNTU1LnBuZw.png\"></p>\n<p>下面会详细介绍 <code>.proto</code> 消息模型里的 消息对象 &amp; 字段</p>\n<p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGJhY2Q4N2Y0NDlkYmI4LnBuZw.png\"></p>\n<h4 id=\"1-消息对象\"><a href=\"#1-消息对象\" class=\"headerlink\" title=\"1. 消息对象\"></a>1. 消息对象</h4><p>在 <code>ProtocolBuffers</code> 中：</p>\n<ul>\n<li>一个消息对象（<code>Message</code>） &#x3D; 一个 结构化数据</li>\n<li>消息对象用 修饰符 <code>message</code> 修饰</li>\n<li>消息对象 含有 字段：消息对象（<code>Message</code>）里的 字段 &#x3D; 结构化数据 里的成员变量</li>\n</ul>\n<p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0wM2ViZDRkZjlkZTVkNTU1LnBuZw.png\"></p>\n<p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iNDg4YzYyMDk0NTE2ZTBjLnBuZw.png\"></p>\n<h5 id=\"a-添加：在一个-proto文件-中可定义多个-消息对象\"><a href=\"#a-添加：在一个-proto文件-中可定义多个-消息对象\" class=\"headerlink\" title=\"a. 添加：在一个 .proto文件 中可定义多个 消息对象\"></a>a. 添加：在一个 .proto文件 中可定义多个 消息对象</h5><ul>\n<li>应用场景：尽可能将与 某一消息类型 对应的响应消息格式 定义到相同的 <code>.proto</code>文件 中</li>\n<li>实例：</li>\n</ul>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">SearchRequest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">string</span> query = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">optional</span> <span class=\"type\">int32</span> page_number = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">optional</span> <span class=\"type\">int32</span> result_per_page = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与SearchRequest消息类型 对应的 响应消息类型SearchResponse</span></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">SearchResponse</span> &#123;</span><br><span class=\"line\"> …</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"b-一个消息对象-里-可以定义-另外一个消息对象（即嵌套）\"><a href=\"#b-一个消息对象-里-可以定义-另外一个消息对象（即嵌套）\" class=\"headerlink\" title=\"b. 一个消息对象 里 可以定义 另外一个消息对象（即嵌套）\"></a>b. 一个消息对象 里 可以定义 另外一个消息对象（即嵌套）</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message Person &#123;</span><br><span class=\"line\">  required string name = 1;</span><br><span class=\"line\">  required int32 id = 2;</span><br><span class=\"line\">  optional string email = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">// 该消息类型 定义在 Person消息类型的内部</span><br><span class=\"line\">// 即Person消息类型 是 PhoneNumber消息类型的父消息类型</span><br><span class=\"line\">  message PhoneNumber &#123;</span><br><span class=\"line\">    required string number = 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;-- 多重嵌套 --&gt;</span><br><span class=\"line\">message Outer &#123;   // Level 0</span><br><span class=\"line\">  message MiddleAA &#123;  // Level 1</span><br><span class=\"line\">    message Inner &#123;   // Level 2</span><br><span class=\"line\">      required int64 ival = 1;</span><br><span class=\"line\">      optional bool  booly = 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-字段\"><a href=\"#2-字段\" class=\"headerlink\" title=\"2. 字段\"></a>2. 字段</h4><ul>\n<li>消息对象的字段 组成主要是：<strong>字段 &#x3D; 字段修饰符 + 字段类型 +字段名 +标识号</strong></li>\n</ul>\n<p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGI3ZTczMjExYjRjODliLnBuZw.png\"></p>\n<h5 id=\"a-字段修饰符\"><a href=\"#a-字段修饰符\" class=\"headerlink\" title=\"a. 字段修饰符\"></a><strong>a. 字段修饰符</strong></h5><ul>\n<li><p>作用：设置该字段解析时的规则</p>\n</li>\n<li><p>具体类型如下：</p>\n<p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iZjE3MjU0NTIwOWI4N2UxLnBuZw.png\"></p>\n</li>\n</ul>\n<p><strong>b. 字段类型</strong><br>字段类型主要有 三 类：</p>\n<ul>\n<li>基本数据 类型</li>\n<li>枚举 类型</li>\n<li>消息对象 类型</li>\n</ul>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 基本数据类型 字段</span></span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">string</span> name = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">int32</span> id = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">optional</span> <span class=\"type\">string</span> email = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">enum </span><span class=\"title class_\">PhoneType</span> &#123;</span><br><span class=\"line\">    MOBILE = <span class=\"number\">0</span>;</span><br><span class=\"line\">    HOME = <span class=\"number\">1</span>;</span><br><span class=\"line\">    WORK = <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">message </span><span class=\"title class_\">PhoneNumber</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">optional</span> PhoneType type = <span class=\"number\">2</span> [default = HOME];</span><br><span class=\"line\">    <span class=\"comment\">// 枚举类型 字段</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">repeated</span> PhoneNumber phone = <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 消息类型 字段</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"1-基本数据类型\"><a href=\"#1-基本数据类型\" class=\"headerlink\" title=\"1.基本数据类型\"></a>1.基本数据类型</h6><table>\n<thead>\n<tr>\n<th>.proto中的类型</th>\n<th>注意</th>\n<th>C++中类型</th>\n<th>java中类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>double</td>\n<td></td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr>\n<td>float</td>\n<td></td>\n<td>float</td>\n<td>float</td>\n</tr>\n<tr>\n<td>int32</td>\n<td>自动调整编码长度，如果需要保存负数，请使用sint32</td>\n<td>int32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>int64</td>\n<td>自动调整编码长度，如果需要保存负数，请使用sint64</td>\n<td>int64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>uint32</td>\n<td>自动调整编码长度</td>\n<td>uint32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>uint64</td>\n<td>自动调整编码长度</td>\n<td>uint64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>sint32</td>\n<td>自动调整编码长度，表示有符号数，负数的编码效率高于int32</td>\n<td>int32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>sint64</td>\n<td>自动调整编码长度，表示有符号数，负数的编码效率高于int64</td>\n<td>int64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>fixed32</td>\n<td>固定使用4bytes编码，在编码大数(228228)的时候比uint32更有效率</td>\n<td>int32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>fixed32</td>\n<td>固定使用8bytes编码，在编码大数(256256)的时候比uint64更有效率</td>\n<td>int42</td>\n<td>long</td>\n</tr>\n<tr>\n<td>sfixed32</td>\n<td>固定使用4bytes编码</td>\n<td>int32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>sfixed64</td>\n<td>固定使用8bytes编码</td>\n<td>int64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>bool</td>\n<td></td>\n<td>bool</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td>string</td>\n<td>string只能包含UTF-8和7-bit ASCII文本</td>\n<td>string</td>\n<td>String</td>\n</tr>\n<tr>\n<td>bytes</td>\n<td>包含任意长度的bytes</td>\n<td>string</td>\n<td>ByteString</td>\n</tr>\n</tbody></table>\n<h6 id=\"2-枚举类型\"><a href=\"#2-枚举类型\" class=\"headerlink\" title=\"2. 枚举类型\"></a>2. 枚举类型</h6><ul>\n<li>作用：为字段指定一个 可能取值的字段集合</li>\n</ul>\n<blockquote>\n<p>该字段只能从 该指定的字段集合里 取值</p>\n</blockquote>\n<ul>\n<li>说明：如下面例子，电话号码 可能是手机号、家庭电话号或工作电话号的其中一个，那么就将<code>PhoneType</code>定义为枚举类型，并将加入电话的集合（ <code>MOBILE</code>、 <code>HOME</code>、<code>WORK</code>）</li>\n</ul>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 枚举类型需要先定义才能进行使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 枚举类型 定义</span></span><br><span class=\"line\"> <span class=\"keyword\">enum </span><span class=\"title class_\">PhoneType</span> &#123;</span><br><span class=\"line\">    MOBILE = <span class=\"number\">0</span>;</span><br><span class=\"line\">    HOME = <span class=\"number\">1</span>;</span><br><span class=\"line\">    WORK = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">// 电话类型字段 只能从 这个集合里 取值</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 特别注意：</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 枚举类型的定义可在一个消息对象的内部或外部</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 都可以在 同一.proto文件 中的任何消息对象里使用</span></span><br><span class=\"line\"><span class=\"comment\">// 3. 当枚举类型是在一消息内部定义，希望在 另一个消息中 使用时，需要采用MessageType.EnumType的语法格式</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">message </span><span class=\"title class_\">PhoneNumber</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"type\">string</span> number = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">optional</span> PhoneType type = <span class=\"number\">2</span> [default = HOME];</span><br><span class=\"line\">    <span class=\"comment\">// 使用枚举类型的字段（设置了默认值）</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 特别注意：</span></span><br><span class=\"line\"><span class=\"comment\">// 1.  枚举常量必须在32位整型值的范围内</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 不推荐在enum中使用负数：因为enum值是使用可变编码方式的，对负数不够高</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"3-消息对象-类型\"><a href=\"#3-消息对象-类型\" class=\"headerlink\" title=\"3. 消息对象 类型\"></a>3. 消息对象 类型</h6><p>一个消息对象 可以将 其他消息对象类型 用作字段类型，情况如下：</p>\n<p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS04Nzc5YmMwOWE1M2ViNDBjLnBuZw.png\"></p>\n<ul>\n<li><p><strong>使用 内部消息类型</strong></p>\n<ul>\n<li>先在 消息类型 中定义 其他消息类型 ，然后再使用</li>\n</ul>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">string</span> name = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">int32</span> id = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">optional</span> <span class=\"type\">string</span> email = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 该消息类型 定义在 Person消息类型的内部</span></span><br><span class=\"line\"><span class=\"comment\">// 即Person消息类型 是 PhoneNumber消息类型的父消息类型</span></span><br><span class=\"line\">  <span class=\"keyword\">message </span><span class=\"title class_\">PhoneNumber</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"type\">string</span> number = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">repeated</span> PhoneNumber phone = <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 直接使用内部消息类型</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用</strong> <strong>外部消息类型</strong></p>\n<ul>\n<li>即外部重用，需要 用作字段类型的消息类型 定义在 该消息类型外部</li>\n</ul>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">string</span> name = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">int32</span> id = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">optional</span> <span class=\"type\">string</span> email = <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">AddressBook</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">repeated</span> Person person = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 直接使用了 Person消息类型作为消息字段</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用</strong> <strong>外部消息的内部消息类型</strong></p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">string</span> name = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">int32</span> id = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">optional</span> <span class=\"type\">string</span> email = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PhoneNumber消息类型 是 Person消息类型的内部消息类型</span></span><br><span class=\"line\">  <span class=\"keyword\">message </span><span class=\"title class_\">PhoneNumber</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"type\">string</span> number = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">optional</span> PhoneType type = <span class=\"number\">2</span> [default = HOME];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 若父消息类型外部的消息类型需要重用该内部消息类型</span></span><br><span class=\"line\"><span class=\"comment\">// 需要以 Parent.Type 的形式去使用</span></span><br><span class=\"line\"><span class=\"comment\">// Parent = 需要使用消息类型的父消息类型，Type = 需要使用的消息类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PhoneNumber父消息类型Person 的外部 OtherMessage消息类型 需要使用 PhoneNumber消息类型</span></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">OtherMessage</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">optional</span> Person.PhoneNumber phonenumber = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 以 Parent.Type = Person.PhoneNumber  的形式去使用</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用不同</strong> .<strong>proto</strong> <strong>文件里的消息类型</strong></p>\n<ul>\n<li><p>目的：需要在 <code>A.proto</code>文件 使用 <code>B.proto</code>文件里的消息类型</p>\n</li>\n<li><p>解决方案：在 <code>A.proto</code>文件 通过导入（ <code>import</code>） <code>B.proto</code>文件中来使用 <code>B.proto</code>文件 里的消息类型</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;myproject/other_protos.proto&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 在A.proto 文件中添加 B.proto文件路径的导入声明</span></span><br><span class=\"line\"><span class=\"comment\">// ProtocolBuffer编译器 会在 该目录中 查找需要被导入的 .proto文件</span></span><br><span class=\"line\"><span class=\"comment\">// 如果不提供参数，编译器就在 其调用的目录下 查找</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-2.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Protocol-Buffers基本使用\"><a href=\"#Protocol-Buffers基本使用\" class=\"headerlink\" title=\"Protocol Buffers基本使用\"></a>Protocol Buffers基本使用</h1><blockquote>\n<ul>\n<li>Protocol Buffer 和 XML、JSON一样都是结构数据序列化的工具，但它们的数据格式有比较大的区别：<ul>\n<li>首先，Protocol Buffer 序列化之后得到的数据不是可读的字符串，而是二进制流</li>\n<li>其次，XML 和 JSON 格式的数据信息都包含在了序列化之后的数据中，不需要任何其它信息就能还原序列化之后的数据；但使用 Protocol Buffer 需要事先定义数据的格式(.proto 协议文件)，还原一个序列化之后的数据需要使用到这个定义好的数据格式</li>\n<li>最后，在传输数据量较大的需求场景下，Protocol Buffer 比 XML、JSON 更小（3到10倍）、更快（20到100倍）、使用 &amp; 维护更简单；而且 Protocol Buffer 可以跨平台、跨语音使用</li>\n</ul>\n</li>\n<li>Protobuf 安装：<ul>\n<li>安装 protobuf： apt-get install protobuf-compiler</li>\n<li>安装 protobuf 的 python 模块：pip3 install protobuf&#x3D;&#x3D;3.13.0</li>\n<li>源码方式安装：可参考 Protobuf 安装及使用 &amp;&amp; <a href=\"https://github.com/protocolbuffers/protobuf/blob/main/src/README.md\">https://github.com/protocolbuffers/protobuf/blob/main/src/README.md</a></li>\n</ul>\n</li>\n<li>Protobuf 版本查看：<ul>\n<li>protoc –version</li>\n<li>import google.protobuf as gp, gp.<strong>version</strong></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"Protocol-Buffer-的作用\"><a href=\"#Protocol-Buffer-的作用\" class=\"headerlink\" title=\"Protocol Buffer 的作用\"></a>Protocol Buffer 的作用</h2><ul>\n<li>通过将结构化的数据（拥有多种属性）进行序列化，从而实现（内存与硬盘之间）数据存储和交换的功能<ul>\n<li>序列化： 按照 <code>.proto</code> 协议文件将<code>数据结构或对象</code>转换成<code>二进制流</code>的过程</li>\n<li>反序列化：将在序列化过程中所生成的<code>二进制流</code>转换成<code>数据结构或对象</code>的过程</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1hOWIzZmMyZWQxNmY2MWU1LnBuZw\" alt=\"Protocol Buffer 特点\"></p>\n<h2 id=\"Protocol-Buffer-语法\"><a href=\"#Protocol-Buffer-语法\" class=\"headerlink\" title=\"Protocol Buffer 语法\"></a>Protocol Buffer 语法</h2><p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS01NjYzNTk5ZTg0MzNmNWI4LnBuZw.png\"></p>\n<h3 id=\"关注1：包名\"><a href=\"#关注1：包名\" class=\"headerlink\" title=\"关注1：包名\"></a>关注1：包名</h3><figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> protocobuff_Demo;</span><br><span class=\"line\"><span class=\"comment\">// 关注1：包名</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>作用：防止不同 .proto 项目间命名 发生冲突</p>\n</li>\n<li><p>Protocol buffer包的解析过程如下：</p>\n<ol>\n<li>Protocol buffer 的类型名称解析与 C++ 一致：从 最内部 开始查找，依次向外进行每个包会被看作是其父类包的内部类</li>\n<li>Protocol buffer 编译器会解析 .proto文件中定义的所有类型名</li>\n<li>生成器会根据 不同语言 生成 对应语言 的代码文件</li>\n</ol>\n<blockquote>\n<p>a. 即对 不同语言 使用了 不同的规则 进行处理</p>\n<p>b. Protoco Buffer提供 C++、Java、Python 三种语言的 API</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"关注2：Option选项\"><a href=\"#关注2：Option选项\" class=\"headerlink\" title=\"关注2：Option选项\"></a>关注2：Option选项</h3><figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">option</span> java_package = <span class=\"string\">&quot;com.carson.proto&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">option</span> java_outer_classname = <span class=\"string\">&quot;Demo&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 关注2：option选项</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>作用：影响 特定环境下 的处理方式</p>\n</li>\n<li><p>常用Option选项如下：</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">option</span> java_package = <span class=\"string\">&quot;com.carson.proto&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 定义：Java包名</span></span><br><span class=\"line\"><span class=\"comment\">// 作用：指定生成的类应该放在什么Java包名下</span></span><br><span class=\"line\"><span class=\"comment\">// 注：如不显式指定，默认包名为：按照应用名称倒序方式进行排序</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">option</span> java_outer_classname = <span class=\"string\">&quot;Demo&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 定义：类名</span></span><br><span class=\"line\"><span class=\"comment\">// 作用：生成对应.java 文件的类名（不能跟下面message的类名相同）</span></span><br><span class=\"line\"><span class=\"comment\">// 注：如不显式指定，则默认为把.proto文件名转换为首字母大写来生成</span></span><br><span class=\"line\"><span class=\"comment\">// 如.proto文件名=&quot;my_proto.proto&quot;，默认情况下，将使用 &quot;MyProto&quot; 做为类名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">option</span> optimize_for = ***;</span><br><span class=\"line\"><span class=\"comment\">// 作用：影响 C++  &amp; java 代码的生成</span></span><br><span class=\"line\"><span class=\"comment\">// ***参数如下：</span></span><br><span class=\"line\"><span class=\"comment\">// 1. SPEED (默认):：protocol buffer编译器将通过在消息类型上执行序列化、语法分析及其他通用的操作。（最优方式）</span></span><br><span class=\"line\"><span class=\"comment\">// 2. CODE_SIZE:：编译器将会产生最少量的类，通过共享或基于反射的代码来实现序列化、语法分析及各种其它操作。</span></span><br><span class=\"line\">  <span class=\"comment\">// 特点：采用该方式产生的代码将比SPEED要少很多， 但是效率较低；</span></span><br><span class=\"line\">  <span class=\"comment\">// 使用场景：常用在 包含大量.proto文件 但 不追求效率 的应用中。</span></span><br><span class=\"line\"><span class=\"comment\">//3.  LITE_RUNTIME:：编译器依赖于运行时 核心类库 来生成代码（即采用libprotobuf-lite 替代libprotobuf）。</span></span><br><span class=\"line\">  <span class=\"comment\">// 特点：这种核心类库要比全类库小得多（忽略了 一些描述符及反射 ）；编译器采用该模式产生的方法实现与SPEED模式不相上下，产生的类通过实现 MessageLite接口，但它仅仅是Messager接口的一个子集。</span></span><br><span class=\"line\">  <span class=\"comment\">// 应用场景：移动手机平台应用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">option</span> cc_generic_services = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">option</span> java_generic_services = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">option</span> py_generic_services = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"comment\">// 作用：定义在C++、java、python中，protocol buffer编译器是否应该 基于服务定义 产生 抽象服务代码（2.3.0版本前该值默认 = true）</span></span><br><span class=\"line\"><span class=\"comment\">// 自2.3.0版本以来，官方认为通过提供 代码生成器插件 来对 RPC实现 更可取，而不是依赖于“抽象”服务</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">optional</span> <span class=\"keyword\">repeated</span> <span class=\"type\">int32</span> samples = <span class=\"number\">4</span> [packed=<span class=\"literal\">true</span>];</span><br><span class=\"line\"><span class=\"comment\">// 如果该选项在一个整型基本类型上被设置为真，则采用更紧凑的编码方式（不会对数值造成损失）</span></span><br><span class=\"line\"><span class=\"comment\">// 在2.3.0版本前，解析器将会忽略 非期望的包装值。因此，它不可能在 不破坏现有框架的兼容性上 而 改变压缩格式。</span></span><br><span class=\"line\"><span class=\"comment\">// 在2.3.0之后，这种改变将是安全的，解析器能够接受上述两种格式。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">optional</span> <span class=\"type\">int32</span> old_field = <span class=\"number\">6</span> [deprecated=<span class=\"literal\">true</span>];</span><br><span class=\"line\"><span class=\"comment\">// 作用：判断该字段是否已经被弃用</span></span><br><span class=\"line\"><span class=\"comment\">// 作用同 在java中的注解@Deprecated</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"关注3：消息模型\"><a href=\"#关注3：消息模型\" class=\"headerlink\" title=\"关注3：消息模型\"></a>关注3：消息模型</h3><ul>\n<li>作用：真正用于描述 数据结构</li>\n</ul>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 消息对象用message修饰</span></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">string</span> name = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">int32</span> id = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">optional</span> <span class=\"type\">string</span> email = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">enum </span><span class=\"title class_\">PhoneType</span> &#123;</span><br><span class=\"line\">    MOBILE = <span class=\"number\">0</span>;</span><br><span class=\"line\">    HOME = <span class=\"number\">1</span>;</span><br><span class=\"line\">    WORK = <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">message </span><span class=\"title class_\">PhoneNumber</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">optional</span> PhoneType type = <span class=\"number\">2</span> [default = HOME];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">repeated</span> PhoneNumber phone = <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">AddressBook</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">repeated</span> Person person = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>组成：在ProtocolBuffers中：<ol>\n<li>一个 <code>.proto</code> 消息模型 &#x3D; 一个 <code>.proto</code>文件 &#x3D; 消息对象 + 字段</li>\n<li>一个消息对象（<code>Message</code>） &#x3D; 一个 结构化数据</li>\n<li>消息对象（<code>Message</code>）里的 字段 &#x3D; 结构化数据 里的成员变量</li>\n</ol>\n</li>\n</ul>\n<p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0wM2ViZDRkZjlkZTVkNTU1LnBuZw.png\"></p>\n<p>下面会详细介绍 <code>.proto</code> 消息模型里的 消息对象 &amp; 字段</p>\n<p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGJhY2Q4N2Y0NDlkYmI4LnBuZw.png\"></p>\n<h4 id=\"1-消息对象\"><a href=\"#1-消息对象\" class=\"headerlink\" title=\"1. 消息对象\"></a>1. 消息对象</h4><p>在 <code>ProtocolBuffers</code> 中：</p>\n<ul>\n<li>一个消息对象（<code>Message</code>） &#x3D; 一个 结构化数据</li>\n<li>消息对象用 修饰符 <code>message</code> 修饰</li>\n<li>消息对象 含有 字段：消息对象（<code>Message</code>）里的 字段 &#x3D; 结构化数据 里的成员变量</li>\n</ul>\n<p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0wM2ViZDRkZjlkZTVkNTU1LnBuZw.png\"></p>\n<p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iNDg4YzYyMDk0NTE2ZTBjLnBuZw.png\"></p>\n<h5 id=\"a-添加：在一个-proto文件-中可定义多个-消息对象\"><a href=\"#a-添加：在一个-proto文件-中可定义多个-消息对象\" class=\"headerlink\" title=\"a. 添加：在一个 .proto文件 中可定义多个 消息对象\"></a>a. 添加：在一个 .proto文件 中可定义多个 消息对象</h5><ul>\n<li>应用场景：尽可能将与 某一消息类型 对应的响应消息格式 定义到相同的 <code>.proto</code>文件 中</li>\n<li>实例：</li>\n</ul>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">SearchRequest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">string</span> query = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">optional</span> <span class=\"type\">int32</span> page_number = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">optional</span> <span class=\"type\">int32</span> result_per_page = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与SearchRequest消息类型 对应的 响应消息类型SearchResponse</span></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">SearchResponse</span> &#123;</span><br><span class=\"line\"> …</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"b-一个消息对象-里-可以定义-另外一个消息对象（即嵌套）\"><a href=\"#b-一个消息对象-里-可以定义-另外一个消息对象（即嵌套）\" class=\"headerlink\" title=\"b. 一个消息对象 里 可以定义 另外一个消息对象（即嵌套）\"></a>b. 一个消息对象 里 可以定义 另外一个消息对象（即嵌套）</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">message Person &#123;</span><br><span class=\"line\">  required string name = 1;</span><br><span class=\"line\">  required int32 id = 2;</span><br><span class=\"line\">  optional string email = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">// 该消息类型 定义在 Person消息类型的内部</span><br><span class=\"line\">// 即Person消息类型 是 PhoneNumber消息类型的父消息类型</span><br><span class=\"line\">  message PhoneNumber &#123;</span><br><span class=\"line\">    required string number = 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;-- 多重嵌套 --&gt;</span><br><span class=\"line\">message Outer &#123;   // Level 0</span><br><span class=\"line\">  message MiddleAA &#123;  // Level 1</span><br><span class=\"line\">    message Inner &#123;   // Level 2</span><br><span class=\"line\">      required int64 ival = 1;</span><br><span class=\"line\">      optional bool  booly = 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-字段\"><a href=\"#2-字段\" class=\"headerlink\" title=\"2. 字段\"></a>2. 字段</h4><ul>\n<li>消息对象的字段 组成主要是：<strong>字段 &#x3D; 字段修饰符 + 字段类型 +字段名 +标识号</strong></li>\n</ul>\n<p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS03ZGI3ZTczMjExYjRjODliLnBuZw.png\"></p>\n<h5 id=\"a-字段修饰符\"><a href=\"#a-字段修饰符\" class=\"headerlink\" title=\"a. 字段修饰符\"></a><strong>a. 字段修饰符</strong></h5><ul>\n<li><p>作用：设置该字段解析时的规则</p>\n</li>\n<li><p>具体类型如下：</p>\n<p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1iZjE3MjU0NTIwOWI4N2UxLnBuZw.png\"></p>\n</li>\n</ul>\n<p><strong>b. 字段类型</strong><br>字段类型主要有 三 类：</p>\n<ul>\n<li>基本数据 类型</li>\n<li>枚举 类型</li>\n<li>消息对象 类型</li>\n</ul>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 基本数据类型 字段</span></span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">string</span> name = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">int32</span> id = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">optional</span> <span class=\"type\">string</span> email = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">enum </span><span class=\"title class_\">PhoneType</span> &#123;</span><br><span class=\"line\">    MOBILE = <span class=\"number\">0</span>;</span><br><span class=\"line\">    HOME = <span class=\"number\">1</span>;</span><br><span class=\"line\">    WORK = <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">message </span><span class=\"title class_\">PhoneNumber</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">optional</span> PhoneType type = <span class=\"number\">2</span> [default = HOME];</span><br><span class=\"line\">    <span class=\"comment\">// 枚举类型 字段</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">repeated</span> PhoneNumber phone = <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 消息类型 字段</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"1-基本数据类型\"><a href=\"#1-基本数据类型\" class=\"headerlink\" title=\"1.基本数据类型\"></a>1.基本数据类型</h6><table>\n<thead>\n<tr>\n<th>.proto中的类型</th>\n<th>注意</th>\n<th>C++中类型</th>\n<th>java中类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>double</td>\n<td></td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr>\n<td>float</td>\n<td></td>\n<td>float</td>\n<td>float</td>\n</tr>\n<tr>\n<td>int32</td>\n<td>自动调整编码长度，如果需要保存负数，请使用sint32</td>\n<td>int32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>int64</td>\n<td>自动调整编码长度，如果需要保存负数，请使用sint64</td>\n<td>int64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>uint32</td>\n<td>自动调整编码长度</td>\n<td>uint32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>uint64</td>\n<td>自动调整编码长度</td>\n<td>uint64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>sint32</td>\n<td>自动调整编码长度，表示有符号数，负数的编码效率高于int32</td>\n<td>int32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>sint64</td>\n<td>自动调整编码长度，表示有符号数，负数的编码效率高于int64</td>\n<td>int64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>fixed32</td>\n<td>固定使用4bytes编码，在编码大数(228228)的时候比uint32更有效率</td>\n<td>int32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>fixed32</td>\n<td>固定使用8bytes编码，在编码大数(256256)的时候比uint64更有效率</td>\n<td>int42</td>\n<td>long</td>\n</tr>\n<tr>\n<td>sfixed32</td>\n<td>固定使用4bytes编码</td>\n<td>int32</td>\n<td>int</td>\n</tr>\n<tr>\n<td>sfixed64</td>\n<td>固定使用8bytes编码</td>\n<td>int64</td>\n<td>long</td>\n</tr>\n<tr>\n<td>bool</td>\n<td></td>\n<td>bool</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td>string</td>\n<td>string只能包含UTF-8和7-bit ASCII文本</td>\n<td>string</td>\n<td>String</td>\n</tr>\n<tr>\n<td>bytes</td>\n<td>包含任意长度的bytes</td>\n<td>string</td>\n<td>ByteString</td>\n</tr>\n</tbody></table>\n<h6 id=\"2-枚举类型\"><a href=\"#2-枚举类型\" class=\"headerlink\" title=\"2. 枚举类型\"></a>2. 枚举类型</h6><ul>\n<li>作用：为字段指定一个 可能取值的字段集合</li>\n</ul>\n<blockquote>\n<p>该字段只能从 该指定的字段集合里 取值</p>\n</blockquote>\n<ul>\n<li>说明：如下面例子，电话号码 可能是手机号、家庭电话号或工作电话号的其中一个，那么就将<code>PhoneType</code>定义为枚举类型，并将加入电话的集合（ <code>MOBILE</code>、 <code>HOME</code>、<code>WORK</code>）</li>\n</ul>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 枚举类型需要先定义才能进行使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 枚举类型 定义</span></span><br><span class=\"line\"> <span class=\"keyword\">enum </span><span class=\"title class_\">PhoneType</span> &#123;</span><br><span class=\"line\">    MOBILE = <span class=\"number\">0</span>;</span><br><span class=\"line\">    HOME = <span class=\"number\">1</span>;</span><br><span class=\"line\">    WORK = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">// 电话类型字段 只能从 这个集合里 取值</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 特别注意：</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 枚举类型的定义可在一个消息对象的内部或外部</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 都可以在 同一.proto文件 中的任何消息对象里使用</span></span><br><span class=\"line\"><span class=\"comment\">// 3. 当枚举类型是在一消息内部定义，希望在 另一个消息中 使用时，需要采用MessageType.EnumType的语法格式</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">message </span><span class=\"title class_\">PhoneNumber</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"type\">string</span> number = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">optional</span> PhoneType type = <span class=\"number\">2</span> [default = HOME];</span><br><span class=\"line\">    <span class=\"comment\">// 使用枚举类型的字段（设置了默认值）</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 特别注意：</span></span><br><span class=\"line\"><span class=\"comment\">// 1.  枚举常量必须在32位整型值的范围内</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 不推荐在enum中使用负数：因为enum值是使用可变编码方式的，对负数不够高</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"3-消息对象-类型\"><a href=\"#3-消息对象-类型\" class=\"headerlink\" title=\"3. 消息对象 类型\"></a>3. 消息对象 类型</h6><p>一个消息对象 可以将 其他消息对象类型 用作字段类型，情况如下：</p>\n<p><img src=\"/media/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS04Nzc5YmMwOWE1M2ViNDBjLnBuZw.png\"></p>\n<ul>\n<li><p><strong>使用 内部消息类型</strong></p>\n<ul>\n<li>先在 消息类型 中定义 其他消息类型 ，然后再使用</li>\n</ul>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">string</span> name = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">int32</span> id = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">optional</span> <span class=\"type\">string</span> email = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 该消息类型 定义在 Person消息类型的内部</span></span><br><span class=\"line\"><span class=\"comment\">// 即Person消息类型 是 PhoneNumber消息类型的父消息类型</span></span><br><span class=\"line\">  <span class=\"keyword\">message </span><span class=\"title class_\">PhoneNumber</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"type\">string</span> number = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">repeated</span> PhoneNumber phone = <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 直接使用内部消息类型</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用</strong> <strong>外部消息类型</strong></p>\n<ul>\n<li>即外部重用，需要 用作字段类型的消息类型 定义在 该消息类型外部</li>\n</ul>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">string</span> name = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">int32</span> id = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">optional</span> <span class=\"type\">string</span> email = <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">AddressBook</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">repeated</span> Person person = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 直接使用了 Person消息类型作为消息字段</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用</strong> <strong>外部消息的内部消息类型</strong></p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">string</span> name = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">required</span> <span class=\"type\">int32</span> id = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">optional</span> <span class=\"type\">string</span> email = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PhoneNumber消息类型 是 Person消息类型的内部消息类型</span></span><br><span class=\"line\">  <span class=\"keyword\">message </span><span class=\"title class_\">PhoneNumber</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"type\">string</span> number = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">optional</span> PhoneType type = <span class=\"number\">2</span> [default = HOME];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 若父消息类型外部的消息类型需要重用该内部消息类型</span></span><br><span class=\"line\"><span class=\"comment\">// 需要以 Parent.Type 的形式去使用</span></span><br><span class=\"line\"><span class=\"comment\">// Parent = 需要使用消息类型的父消息类型，Type = 需要使用的消息类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PhoneNumber父消息类型Person 的外部 OtherMessage消息类型 需要使用 PhoneNumber消息类型</span></span><br><span class=\"line\"><span class=\"keyword\">message </span><span class=\"title class_\">OtherMessage</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">optional</span> Person.PhoneNumber phonenumber = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 以 Parent.Type = Person.PhoneNumber  的形式去使用</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用不同</strong> .<strong>proto</strong> <strong>文件里的消息类型</strong></p>\n<ul>\n<li><p>目的：需要在 <code>A.proto</code>文件 使用 <code>B.proto</code>文件里的消息类型</p>\n</li>\n<li><p>解决方案：在 <code>A.proto</code>文件 通过导入（ <code>import</code>） <code>B.proto</code>文件中来使用 <code>B.proto</code>文件 里的消息类型</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;myproject/other_protos.proto&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 在A.proto 文件中添加 B.proto文件路径的导入声明</span></span><br><span class=\"line\"><span class=\"comment\">// ProtocolBuffer编译器 会在 该目录中 查找需要被导入的 .proto文件</span></span><br><span class=\"line\"><span class=\"comment\">// 如果不提供参数，编译器就在 其调用的目录下 查找</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n"},{"_content":"# STL容器使用时机\n\n|              | vector   | deque    | list     | set    | multiset | map             | multimap      |\n|--------------|----------|----------|----------|--------|----------|-----------------|---------------|\n| 典型内存结构 | 单端数组 | 双端数组 | 双向链表 | 二叉树 | 二叉树   | 二叉树          | 二叉树        |\n| 可随机存取   | 是       | 是       | 否       | 否     | 否       | 对key而言：不是 | 否            |\n| 元素搜寻速度 | 慢       | 慢       | 非常慢   | 快     | 快       | 对key而言：快   | 对key而言：快 |\n| 元素安插移除 | 尾端     | 头尾两端 | 任何位置 | -      | -        | -               | -             |\n\n## vector的使用场景：\n\n比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。\n\n\n\n## deque的使用场景：\n\n比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。\n\n\n\n## vector与deque的比较：\n\n1. vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置 却是不固定的。\n2. 如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。\n3. deque支持头部的快速插入与快速移除，这是deque的优点。\n\n\n\n## list的使用场景：\n\n比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。\n\n\n\n## set的使用场景：\n\n比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。\n\n\n\n## map的使用场景：\n\n比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。","source":"_posts/C++/STL容器使用时机.md","raw":"# STL容器使用时机\n\n|              | vector   | deque    | list     | set    | multiset | map             | multimap      |\n|--------------|----------|----------|----------|--------|----------|-----------------|---------------|\n| 典型内存结构 | 单端数组 | 双端数组 | 双向链表 | 二叉树 | 二叉树   | 二叉树          | 二叉树        |\n| 可随机存取   | 是       | 是       | 否       | 否     | 否       | 对key而言：不是 | 否            |\n| 元素搜寻速度 | 慢       | 慢       | 非常慢   | 快     | 快       | 对key而言：快   | 对key而言：快 |\n| 元素安插移除 | 尾端     | 头尾两端 | 任何位置 | -      | -        | -               | -             |\n\n## vector的使用场景：\n\n比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。\n\n\n\n## deque的使用场景：\n\n比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。\n\n\n\n## vector与deque的比较：\n\n1. vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置 却是不固定的。\n2. 如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。\n3. deque支持头部的快速插入与快速移除，这是deque的优点。\n\n\n\n## list的使用场景：\n\n比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。\n\n\n\n## set的使用场景：\n\n比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。\n\n\n\n## map的使用场景：\n\n比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。","slug":"C++/STL容器使用时机","published":1,"date":"2023-08-24T14:38:18.636Z","updated":"2022-12-30T03:13:44.816Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0td000jdkr77pzr3fhi","content":"<h1 id=\"STL容器使用时机\"><a href=\"#STL容器使用时机\" class=\"headerlink\" title=\"STL容器使用时机\"></a>STL容器使用时机</h1><table>\n<thead>\n<tr>\n<th></th>\n<th>vector</th>\n<th>deque</th>\n<th>list</th>\n<th>set</th>\n<th>multiset</th>\n<th>map</th>\n<th>multimap</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>典型内存结构</td>\n<td>单端数组</td>\n<td>双端数组</td>\n<td>双向链表</td>\n<td>二叉树</td>\n<td>二叉树</td>\n<td>二叉树</td>\n<td>二叉树</td>\n</tr>\n<tr>\n<td>可随机存取</td>\n<td>是</td>\n<td>是</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n<td>对key而言：不是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>元素搜寻速度</td>\n<td>慢</td>\n<td>慢</td>\n<td>非常慢</td>\n<td>快</td>\n<td>快</td>\n<td>对key而言：快</td>\n<td>对key而言：快</td>\n</tr>\n<tr>\n<td>元素安插移除</td>\n<td>尾端</td>\n<td>头尾两端</td>\n<td>任何位置</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n</tr>\n</tbody></table>\n<h2 id=\"vector的使用场景：\"><a href=\"#vector的使用场景：\" class=\"headerlink\" title=\"vector的使用场景：\"></a>vector的使用场景：</h2><p>比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。</p>\n<h2 id=\"deque的使用场景：\"><a href=\"#deque的使用场景：\" class=\"headerlink\" title=\"deque的使用场景：\"></a>deque的使用场景：</h2><p>比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</p>\n<h2 id=\"vector与deque的比较：\"><a href=\"#vector与deque的比较：\" class=\"headerlink\" title=\"vector与deque的比较：\"></a>vector与deque的比较：</h2><ol>\n<li>vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置 却是不固定的。</li>\n<li>如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</li>\n<li>deque支持头部的快速插入与快速移除，这是deque的优点。</li>\n</ol>\n<h2 id=\"list的使用场景：\"><a href=\"#list的使用场景：\" class=\"headerlink\" title=\"list的使用场景：\"></a>list的使用场景：</h2><p>比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</p>\n<h2 id=\"set的使用场景：\"><a href=\"#set的使用场景：\" class=\"headerlink\" title=\"set的使用场景：\"></a>set的使用场景：</h2><p>比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。</p>\n<h2 id=\"map的使用场景：\"><a href=\"#map的使用场景：\" class=\"headerlink\" title=\"map的使用场景：\"></a>map的使用场景：</h2><p>比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</p>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-6.png","cover_type":"img","excerpt":"","more":"<h1 id=\"STL容器使用时机\"><a href=\"#STL容器使用时机\" class=\"headerlink\" title=\"STL容器使用时机\"></a>STL容器使用时机</h1><table>\n<thead>\n<tr>\n<th></th>\n<th>vector</th>\n<th>deque</th>\n<th>list</th>\n<th>set</th>\n<th>multiset</th>\n<th>map</th>\n<th>multimap</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>典型内存结构</td>\n<td>单端数组</td>\n<td>双端数组</td>\n<td>双向链表</td>\n<td>二叉树</td>\n<td>二叉树</td>\n<td>二叉树</td>\n<td>二叉树</td>\n</tr>\n<tr>\n<td>可随机存取</td>\n<td>是</td>\n<td>是</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n<td>对key而言：不是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>元素搜寻速度</td>\n<td>慢</td>\n<td>慢</td>\n<td>非常慢</td>\n<td>快</td>\n<td>快</td>\n<td>对key而言：快</td>\n<td>对key而言：快</td>\n</tr>\n<tr>\n<td>元素安插移除</td>\n<td>尾端</td>\n<td>头尾两端</td>\n<td>任何位置</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n</tr>\n</tbody></table>\n<h2 id=\"vector的使用场景：\"><a href=\"#vector的使用场景：\" class=\"headerlink\" title=\"vector的使用场景：\"></a>vector的使用场景：</h2><p>比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。</p>\n<h2 id=\"deque的使用场景：\"><a href=\"#deque的使用场景：\" class=\"headerlink\" title=\"deque的使用场景：\"></a>deque的使用场景：</h2><p>比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</p>\n<h2 id=\"vector与deque的比较：\"><a href=\"#vector与deque的比较：\" class=\"headerlink\" title=\"vector与deque的比较：\"></a>vector与deque的比较：</h2><ol>\n<li>vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置 却是不固定的。</li>\n<li>如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</li>\n<li>deque支持头部的快速插入与快速移除，这是deque的优点。</li>\n</ol>\n<h2 id=\"list的使用场景：\"><a href=\"#list的使用场景：\" class=\"headerlink\" title=\"list的使用场景：\"></a>list的使用场景：</h2><p>比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</p>\n<h2 id=\"set的使用场景：\"><a href=\"#set的使用场景：\" class=\"headerlink\" title=\"set的使用场景：\"></a>set的使用场景：</h2><p>比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。</p>\n<h2 id=\"map的使用场景：\"><a href=\"#map的使用场景：\" class=\"headerlink\" title=\"map的使用场景：\"></a>map的使用场景：</h2><p>比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</p>\n"},{"title":"c++并发与多线程","date":"2023-08-24T14:38:18.609Z","description":null,"top_img":false,"_content":"\n# c++并发与多线程\n\n显示转换在主线程中构造，没有问题，隐式转换在子线程中构造，会出现问题\n\n![/ / 二 ： 互 斥 量 的 用 氵 去  / / （ 2 ． 1) lock() ， unlock()  / / 步 驶 ： 先 1 。 ck() ， 操 作 共 享 据 ， unlock() ：  / 过 。 ck() 和 un ck() 要 成 对 使 用 ， 有 1 。 ck() 必 然 要 有 unl 。 Ck ， 每 调 用 一 次 1 。 ck() ， 必 然 应 该 调 用 一 次 unl 。 Ck 的  ： / 环 应 该 也 不 允 许 调 用 1 次 1 。 ck() 去 卩 调 用 了 2 次 unl 。 Ck 的 也 不 允 许 调 用 2 次 c 轻 卩 调 用 眩 unl 。 ck(), 这 些 菲 对 称 却 量 调 月  / / 有 1 。 Ck ， 忘 记 unl 。 Ck 的 问 题 ， 非 常 睢 排 查 3  / / 为 了 防 止 大 家 忘 记 unl 。 Ck 的 引 入 了 一 个 叫 std ： nock-guard 的 类模栀 ： 你 忘 记 。 Ck 不 要 我 苗 你 unl 。 ck() ，  / / 学 习 过 智 能 指 针 (unique-ptr\\<\\>) ： 你 忘 记 霹 放 内 存 不 要 我 给 你 释 放 3 保 姆 3 ](media/4c410326f68b9c901ae092e6d1bee594.png)\n\n\n\n## std::lock_guard（）\n\nstd::lock_guard\\<std::mutex\\> sbguard(my_mutex);\n\n自动帮你进行lock and unlock\n\n\n\n## std::lock()\n\nstd::lock(my_mutex1,my_mutex2)            #手动unlock\n\n一次性锁住两个或者两个以上的互斥量，至少两个。如果互斥量中有一个没锁住，它就在那里等着，等所有互斥量都锁住，他才能往下走；要么互斥量都锁住，要么两个互斥量都没有锁住。\n\n![std: : lock (my_mutexl, my_mutex2) : lock ( ) :  std: : sbguardl (my_mutexl, std: : adopt_lock) :  std: : :mutex\\> sbguard2 (my_mutex2, std: : adopt \\_ lock) ](media/7186eb58ef60fc61dc55f573da016c01.png)\n\n![4) std: : lock_guardfistd: : adopt \\_  // std: : adopt\\_  std: : lock ard\\<std:  mutex.@i  T ock ](media/b80e022befbbb1f86356f354c265237d.png)\n\n这样也不需要手动unlock（）\n\n\n\n## unique_lock()\n\n![： unique—lockÅR 代 lock—guard  / / un 三 que 一 1 。 Ck 罡 个 类 栀 ， 工 作 中 ， \\*lock-guard （ 推 荐 使 用 ） lock—guard4R 代 了 mutex 的 lock() 和 unlock() ：  //unique-lock 比 lock-guard\\*\\$äffl\\$ 效 粼 上 差 一 点 ， 内 存 占 用 多 一 点 。  ： unique—lockfi% 二 个  / 过 。 Ck 一 guard 可 以 带 第 二 个 孬 数 ： ](media/c48e58454fc351e9fe69d2891a001cae.png)\n\n![彐  //adopt-lock 标 记 作 用 3  /std: :lock_guard\\<std: :mutex 〉 sbguardl (my_mutexl ， std: :adopt_lock):  / / （ 2 ． 0 std: •.adopt-lock ： 表 示 这 个 互 斥 量 已 经 裰 Ck 了 （ 你 必 须 要 把 互 斥 量 提 前 1 。 Ck 了 ， 否 则 会 报 异 常 ）  //std: ： ad 。 pt 过 ock 标 记 的 效 果 就 罡 “ 假 调 用 方 线 程 已 经 拥 有 了 互 斥 的 所 有 椤 （ 已 经 ck() 成 功 了 ）  / / 通 知 1 。 Ck 一 guar 环 需 要 在 构 造 函 中 1 。 Ck 这 个 互 斥 量 了  //unique-lock 也 可 以 ästd: :adopt-lock 标 记 ， 含 义 相 同 ， 就 罡 不 希 望 再 unique 过 。 ck() 的 构 造 函 中 1 。 Ck 这 个 。  / / 用 这 个 ad 。 pt 一 1 。 Ck 前 提 罡 ， 你 需 要 自 己 先 把 “ 先 1 。 Ck 上 3  / / （ 2 ． 2 ） std: :try_to_lock  / / 我 们 会 雲 试 用 的 1 。 ck() 去 锁 定 这 个 ， 但 如 果 没 有 锁 定 成 功 ， 我 也 会 立 即 返 回 ， 不 会 咀 塞 在 那 里  / / 用 这 个 try 一 t 。 一 1 。 Ck 的 前 提 罡 你 自 己 不 能 先 去 1 。 Ck 。  / / （ 2 ． 3 ） std: :defer_lock  / / 用 这 个 defer 一 1 。 Ck 的 前 提 罡 你 不 能 自 己 先 Ck ， 否 则 会 报 异 常 。  //defer-lock 的 意思 就 是 没 有 给 皿 ut 加 锁 ： 初 始 化 了 一 个 没 有 加 锁 的 ex 。  defer lock 、  —unique lock ](media/e3b2ae52a820296728e9a11336313dcd.png)\n\n![： unique-lock 的 成员函颛  / / （ 3 ． 0 lock(), 加 锁  / / （ 3 ． 2 冫 unlock() ， 解 锁 ；  / / （ 3 ． 3 ） try_lock() ， 當 试 结 互 斥 量 加 锁 ， 如 果 蓽 不 到 锁 ， 则 返 回 fa 这 e ， 如 果 蓽 到 了 锁 ， 返 回 true ， 这 个 函 不 咀 塞 的 3  / / （ 3 ， 4 ） release(), 返 回 它 所 管 理 的 对 源 指 针 ， 放 所 有 权 也 就 罡 说 ， 这 个 不 再 有 关 孚 。  / 俨 格 区 分 。 ck() 和 release() 的 区 别 ， 不 要 后 。  / / 如 果 ， 原 来 匚 对 象 处 于 加 锁 状 态 ， 你 有 责 任 接 管 过 来 员 责 解 锁 。 ()e leaseifi 回 的 是 ， 原 始 mute 黑 t 的 指 针 ）  / / 为 什 之 有 时 候 需 要 unlock() ： 因 为 你 1 。 Ck 锁 住 的 代 码 越 少 ， 执 行 越 快 ， 整 个 程 序 运 行 效 率 越 高  07 有 人 也 把 锁 头 锁 住 的 代 码 多 少 称 为 锁 的 粒 廛 ， 粒 廛 一 船 用 粗 細 来 描 述  / / a ） 锁 住 的 代 码 少 ， 这 个 粒 度 叫 细 。 执 行 、 率 高  / / b ） 锁 住 的 代 码 多 ， 粒 度 叫 粗 ， 那 执 行 0 就 低  / / 要 学 会 尽 量 选 择 合 适 粒 度 的 代 码 进 行 保 护 ， 粒 度 太 细 ， 可 能 漏 掉 共 享 据 的 保 护 0 立 廛 太 粗 ， 影 响 效 率 。  / / 选 擇 合 适 的 粒 度 ， 罡 高 程 序 员 的 能 力 和 实 力 的 忭 现 3 ](media/f1a009c02af2e121f29b74a8c7899747.png)\n\n\n","source":"_posts/C++/c++并发与多线程.md","raw":"---\ntitle: c++并发与多线程\ndate:\ntags: \n- C++\ncategories:\n- C++\ndescription:\ntop_img: false\n---\n\n# c++并发与多线程\n\n显示转换在主线程中构造，没有问题，隐式转换在子线程中构造，会出现问题\n\n![/ / 二 ： 互 斥 量 的 用 氵 去  / / （ 2 ． 1) lock() ， unlock()  / / 步 驶 ： 先 1 。 ck() ， 操 作 共 享 据 ， unlock() ：  / 过 。 ck() 和 un ck() 要 成 对 使 用 ， 有 1 。 ck() 必 然 要 有 unl 。 Ck ， 每 调 用 一 次 1 。 ck() ， 必 然 应 该 调 用 一 次 unl 。 Ck 的  ： / 环 应 该 也 不 允 许 调 用 1 次 1 。 ck() 去 卩 调 用 了 2 次 unl 。 Ck 的 也 不 允 许 调 用 2 次 c 轻 卩 调 用 眩 unl 。 ck(), 这 些 菲 对 称 却 量 调 月  / / 有 1 。 Ck ， 忘 记 unl 。 Ck 的 问 题 ， 非 常 睢 排 查 3  / / 为 了 防 止 大 家 忘 记 unl 。 Ck 的 引 入 了 一 个 叫 std ： nock-guard 的 类模栀 ： 你 忘 记 。 Ck 不 要 我 苗 你 unl 。 ck() ，  / / 学 习 过 智 能 指 针 (unique-ptr\\<\\>) ： 你 忘 记 霹 放 内 存 不 要 我 给 你 释 放 3 保 姆 3 ](media/4c410326f68b9c901ae092e6d1bee594.png)\n\n\n\n## std::lock_guard（）\n\nstd::lock_guard\\<std::mutex\\> sbguard(my_mutex);\n\n自动帮你进行lock and unlock\n\n\n\n## std::lock()\n\nstd::lock(my_mutex1,my_mutex2)            #手动unlock\n\n一次性锁住两个或者两个以上的互斥量，至少两个。如果互斥量中有一个没锁住，它就在那里等着，等所有互斥量都锁住，他才能往下走；要么互斥量都锁住，要么两个互斥量都没有锁住。\n\n![std: : lock (my_mutexl, my_mutex2) : lock ( ) :  std: : sbguardl (my_mutexl, std: : adopt_lock) :  std: : :mutex\\> sbguard2 (my_mutex2, std: : adopt \\_ lock) ](media/7186eb58ef60fc61dc55f573da016c01.png)\n\n![4) std: : lock_guardfistd: : adopt \\_  // std: : adopt\\_  std: : lock ard\\<std:  mutex.@i  T ock ](media/b80e022befbbb1f86356f354c265237d.png)\n\n这样也不需要手动unlock（）\n\n\n\n## unique_lock()\n\n![： unique—lockÅR 代 lock—guard  / / un 三 que 一 1 。 Ck 罡 个 类 栀 ， 工 作 中 ， \\*lock-guard （ 推 荐 使 用 ） lock—guard4R 代 了 mutex 的 lock() 和 unlock() ：  //unique-lock 比 lock-guard\\*\\$äffl\\$ 效 粼 上 差 一 点 ， 内 存 占 用 多 一 点 。  ： unique—lockfi% 二 个  / 过 。 Ck 一 guard 可 以 带 第 二 个 孬 数 ： ](media/c48e58454fc351e9fe69d2891a001cae.png)\n\n![彐  //adopt-lock 标 记 作 用 3  /std: :lock_guard\\<std: :mutex 〉 sbguardl (my_mutexl ， std: :adopt_lock):  / / （ 2 ． 0 std: •.adopt-lock ： 表 示 这 个 互 斥 量 已 经 裰 Ck 了 （ 你 必 须 要 把 互 斥 量 提 前 1 。 Ck 了 ， 否 则 会 报 异 常 ）  //std: ： ad 。 pt 过 ock 标 记 的 效 果 就 罡 “ 假 调 用 方 线 程 已 经 拥 有 了 互 斥 的 所 有 椤 （ 已 经 ck() 成 功 了 ）  / / 通 知 1 。 Ck 一 guar 环 需 要 在 构 造 函 中 1 。 Ck 这 个 互 斥 量 了  //unique-lock 也 可 以 ästd: :adopt-lock 标 记 ， 含 义 相 同 ， 就 罡 不 希 望 再 unique 过 。 ck() 的 构 造 函 中 1 。 Ck 这 个 。  / / 用 这 个 ad 。 pt 一 1 。 Ck 前 提 罡 ， 你 需 要 自 己 先 把 “ 先 1 。 Ck 上 3  / / （ 2 ． 2 ） std: :try_to_lock  / / 我 们 会 雲 试 用 的 1 。 ck() 去 锁 定 这 个 ， 但 如 果 没 有 锁 定 成 功 ， 我 也 会 立 即 返 回 ， 不 会 咀 塞 在 那 里  / / 用 这 个 try 一 t 。 一 1 。 Ck 的 前 提 罡 你 自 己 不 能 先 去 1 。 Ck 。  / / （ 2 ． 3 ） std: :defer_lock  / / 用 这 个 defer 一 1 。 Ck 的 前 提 罡 你 不 能 自 己 先 Ck ， 否 则 会 报 异 常 。  //defer-lock 的 意思 就 是 没 有 给 皿 ut 加 锁 ： 初 始 化 了 一 个 没 有 加 锁 的 ex 。  defer lock 、  —unique lock ](media/e3b2ae52a820296728e9a11336313dcd.png)\n\n![： unique-lock 的 成员函颛  / / （ 3 ． 0 lock(), 加 锁  / / （ 3 ． 2 冫 unlock() ， 解 锁 ；  / / （ 3 ． 3 ） try_lock() ， 當 试 结 互 斥 量 加 锁 ， 如 果 蓽 不 到 锁 ， 则 返 回 fa 这 e ， 如 果 蓽 到 了 锁 ， 返 回 true ， 这 个 函 不 咀 塞 的 3  / / （ 3 ， 4 ） release(), 返 回 它 所 管 理 的 对 源 指 针 ， 放 所 有 权 也 就 罡 说 ， 这 个 不 再 有 关 孚 。  / 俨 格 区 分 。 ck() 和 release() 的 区 别 ， 不 要 后 。  / / 如 果 ， 原 来 匚 对 象 处 于 加 锁 状 态 ， 你 有 责 任 接 管 过 来 员 责 解 锁 。 ()e leaseifi 回 的 是 ， 原 始 mute 黑 t 的 指 针 ）  / / 为 什 之 有 时 候 需 要 unlock() ： 因 为 你 1 。 Ck 锁 住 的 代 码 越 少 ， 执 行 越 快 ， 整 个 程 序 运 行 效 率 越 高  07 有 人 也 把 锁 头 锁 住 的 代 码 多 少 称 为 锁 的 粒 廛 ， 粒 廛 一 船 用 粗 細 来 描 述  / / a ） 锁 住 的 代 码 少 ， 这 个 粒 度 叫 细 。 执 行 、 率 高  / / b ） 锁 住 的 代 码 多 ， 粒 度 叫 粗 ， 那 执 行 0 就 低  / / 要 学 会 尽 量 选 择 合 适 粒 度 的 代 码 进 行 保 护 ， 粒 度 太 细 ， 可 能 漏 掉 共 享 据 的 保 护 0 立 廛 太 粗 ， 影 响 效 率 。  / / 选 擇 合 适 的 粒 度 ， 罡 高 程 序 员 的 能 力 和 实 力 的 忭 现 3 ](media/f1a009c02af2e121f29b74a8c7899747.png)\n\n\n","slug":"C++/c++并发与多线程","published":1,"updated":"2023-08-24T15:44:49.073Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0td000kdkr777gkdmr5","content":"<h1 id=\"c-并发与多线程\"><a href=\"#c-并发与多线程\" class=\"headerlink\" title=\"c++并发与多线程\"></a>c++并发与多线程</h1><p>显示转换在主线程中构造，没有问题，隐式转换在子线程中构造，会出现问题</p>\n<p><img src=\"/media/4c410326f68b9c901ae092e6d1bee594.png\" alt=\"/ / 二 ： 互 斥 量 的 用 氵 去  / / （ 2 ． 1) lock() ， unlock()  / / 步 驶 ： 先 1 。 ck() ， 操 作 共 享 据 ， unlock() ：  / 过 。 ck() 和 un ck() 要 成 对 使 用 ， 有 1 。 ck() 必 然 要 有 unl 。 Ck ， 每 调 用 一 次 1 。 ck() ， 必 然 应 该 调 用 一 次 unl 。 Ck 的  ： / 环 应 该 也 不 允 许 调 用 1 次 1 。 ck() 去 卩 调 用 了 2 次 unl 。 Ck 的 也 不 允 许 调 用 2 次 c 轻 卩 调 用 眩 unl 。 ck(), 这 些 菲 对 称 却 量 调 月  / / 有 1 。 Ck ， 忘 记 unl 。 Ck 的 问 题 ， 非 常 睢 排 查 3  / / 为 了 防 止 大 家 忘 记 unl 。 Ck 的 引 入 了 一 个 叫 std ： nock-guard 的 类模栀 ： 你 忘 记 。 Ck 不 要 我 苗 你 unl 。 ck() ，  / / 学 习 过 智 能 指 针 (unique-ptr\\&lt;\\&gt;) ： 你 忘 记 霹 放 内 存 不 要 我 给 你 释 放 3 保 姆 3 \"></p>\n<h2 id=\"std-lock-guard（）\"><a href=\"#std-lock-guard（）\" class=\"headerlink\" title=\"std::lock_guard（）\"></a>std::lock_guard（）</h2><p>std::lock_guard&lt;std::mutex&gt; sbguard(my_mutex);</p>\n<p>自动帮你进行lock and unlock</p>\n<h2 id=\"std-lock\"><a href=\"#std-lock\" class=\"headerlink\" title=\"std::lock()\"></a>std::lock()</h2><p>std::lock(my_mutex1,my_mutex2)            #手动unlock</p>\n<p>一次性锁住两个或者两个以上的互斥量，至少两个。如果互斥量中有一个没锁住，它就在那里等着，等所有互斥量都锁住，他才能往下走；要么互斥量都锁住，要么两个互斥量都没有锁住。</p>\n<p><img src=\"/media/7186eb58ef60fc61dc55f573da016c01.png\" alt=\"std: : lock (my_mutexl, my_mutex2) : lock ( ) :  std: : sbguardl (my_mutexl, std: : adopt_lock) :  std: : :mutex\\&gt; sbguard2 (my_mutex2, std: : adopt \\_ lock) \"></p>\n<p><img src=\"/media/b80e022befbbb1f86356f354c265237d.png\" alt=\"4) std: : lock_guardfistd: : adopt \\_  // std: : adopt\\_  std: : lock ard\\&lt;std:  mutex.@i  T ock \"></p>\n<p>这样也不需要手动unlock（）</p>\n<h2 id=\"unique-lock\"><a href=\"#unique-lock\" class=\"headerlink\" title=\"unique_lock()\"></a>unique_lock()</h2><p><img src=\"/media/c48e58454fc351e9fe69d2891a001cae.png\" alt=\"： unique—lockÅR 代 lock—guard  / / un 三 que 一 1 。 Ck 罡 个 类 栀 ， 工 作 中 ， \\*lock-guard （ 推 荐 使 用 ） lock—guard4R 代 了 mutex 的 lock() 和 unlock() ：  //unique-lock 比 lock-guard\\*\\$äffl\\$ 效 粼 上 差 一 点 ， 内 存 占 用 多 一 点 。  ： unique—lockfi% 二 个  / 过 。 Ck 一 guard 可 以 带 第 二 个 孬 数 ： \"></p>\n<p><img src=\"/media/e3b2ae52a820296728e9a11336313dcd.png\" alt=\"彐  //adopt-lock 标 记 作 用 3  /std: :lock_guard\\&lt;std: :mutex 〉 sbguardl (my_mutexl ， std: :adopt_lock):  / / （ 2 ． 0 std: •.adopt-lock ： 表 示 这 个 互 斥 量 已 经 裰 Ck 了 （ 你 必 须 要 把 互 斥 量 提 前 1 。 Ck 了 ， 否 则 会 报 异 常 ）  //std: ： ad 。 pt 过 ock 标 记 的 效 果 就 罡 “ 假 调 用 方 线 程 已 经 拥 有 了 互 斥 的 所 有 椤 （ 已 经 ck() 成 功 了 ）  / / 通 知 1 。 Ck 一 guar 环 需 要 在 构 造 函 中 1 。 Ck 这 个 互 斥 量 了  //unique-lock 也 可 以 ästd: :adopt-lock 标 记 ， 含 义 相 同 ， 就 罡 不 希 望 再 unique 过 。 ck() 的 构 造 函 中 1 。 Ck 这 个 。  / / 用 这 个 ad 。 pt 一 1 。 Ck 前 提 罡 ， 你 需 要 自 己 先 把 “ 先 1 。 Ck 上 3  / / （ 2 ． 2 ） std: :try_to_lock  / / 我 们 会 雲 试 用 的 1 。 ck() 去 锁 定 这 个 ， 但 如 果 没 有 锁 定 成 功 ， 我 也 会 立 即 返 回 ， 不 会 咀 塞 在 那 里  / / 用 这 个 try 一 t 。 一 1 。 Ck 的 前 提 罡 你 自 己 不 能 先 去 1 。 Ck 。  / / （ 2 ． 3 ） std: :defer_lock  / / 用 这 个 defer 一 1 。 Ck 的 前 提 罡 你 不 能 自 己 先 Ck ， 否 则 会 报 异 常 。  //defer-lock 的 意思 就 是 没 有 给 皿 ut 加 锁 ： 初 始 化 了 一 个 没 有 加 锁 的 ex 。  defer lock 、  —unique lock \"></p>\n<p><img src=\"/media/f1a009c02af2e121f29b74a8c7899747.png\" alt=\"： unique-lock 的 成员函颛  / / （ 3 ． 0 lock(), 加 锁  / / （ 3 ． 2 冫 unlock() ， 解 锁 ；  / / （ 3 ． 3 ） try_lock() ， 當 试 结 互 斥 量 加 锁 ， 如 果 蓽 不 到 锁 ， 则 返 回 fa 这 e ， 如 果 蓽 到 了 锁 ， 返 回 true ， 这 个 函 不 咀 塞 的 3  / / （ 3 ， 4 ） release(), 返 回 它 所 管 理 的 对 源 指 针 ， 放 所 有 权 也 就 罡 说 ， 这 个 不 再 有 关 孚 。  / 俨 格 区 分 。 ck() 和 release() 的 区 别 ， 不 要 后 。  / / 如 果 ， 原 来 匚 对 象 处 于 加 锁 状 态 ， 你 有 责 任 接 管 过 来 员 责 解 锁 。 ()e leaseifi 回 的 是 ， 原 始 mute 黑 t 的 指 针 ）  / / 为 什 之 有 时 候 需 要 unlock() ： 因 为 你 1 。 Ck 锁 住 的 代 码 越 少 ， 执 行 越 快 ， 整 个 程 序 运 行 效 率 越 高  07 有 人 也 把 锁 头 锁 住 的 代 码 多 少 称 为 锁 的 粒 廛 ， 粒 廛 一 船 用 粗 細 来 描 述  / / a ） 锁 住 的 代 码 少 ， 这 个 粒 度 叫 细 。 执 行 、 率 高  / / b ） 锁 住 的 代 码 多 ， 粒 度 叫 粗 ， 那 执 行 0 就 低  / / 要 学 会 尽 量 选 择 合 适 粒 度 的 代 码 进 行 保 护 ， 粒 度 太 细 ， 可 能 漏 掉 共 享 据 的 保 护 0 立 廛 太 粗 ， 影 响 效 率 。  / / 选 擇 合 适 的 粒 度 ， 罡 高 程 序 员 的 能 力 和 实 力 的 忭 现 3 \"></p>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-1.png","cover_type":"img","excerpt":"","more":"<h1 id=\"c-并发与多线程\"><a href=\"#c-并发与多线程\" class=\"headerlink\" title=\"c++并发与多线程\"></a>c++并发与多线程</h1><p>显示转换在主线程中构造，没有问题，隐式转换在子线程中构造，会出现问题</p>\n<p><img src=\"/media/4c410326f68b9c901ae092e6d1bee594.png\" alt=\"/ / 二 ： 互 斥 量 的 用 氵 去  / / （ 2 ． 1) lock() ， unlock()  / / 步 驶 ： 先 1 。 ck() ， 操 作 共 享 据 ， unlock() ：  / 过 。 ck() 和 un ck() 要 成 对 使 用 ， 有 1 。 ck() 必 然 要 有 unl 。 Ck ， 每 调 用 一 次 1 。 ck() ， 必 然 应 该 调 用 一 次 unl 。 Ck 的  ： / 环 应 该 也 不 允 许 调 用 1 次 1 。 ck() 去 卩 调 用 了 2 次 unl 。 Ck 的 也 不 允 许 调 用 2 次 c 轻 卩 调 用 眩 unl 。 ck(), 这 些 菲 对 称 却 量 调 月  / / 有 1 。 Ck ， 忘 记 unl 。 Ck 的 问 题 ， 非 常 睢 排 查 3  / / 为 了 防 止 大 家 忘 记 unl 。 Ck 的 引 入 了 一 个 叫 std ： nock-guard 的 类模栀 ： 你 忘 记 。 Ck 不 要 我 苗 你 unl 。 ck() ，  / / 学 习 过 智 能 指 针 (unique-ptr\\&lt;\\&gt;) ： 你 忘 记 霹 放 内 存 不 要 我 给 你 释 放 3 保 姆 3 \"></p>\n<h2 id=\"std-lock-guard（）\"><a href=\"#std-lock-guard（）\" class=\"headerlink\" title=\"std::lock_guard（）\"></a>std::lock_guard（）</h2><p>std::lock_guard&lt;std::mutex&gt; sbguard(my_mutex);</p>\n<p>自动帮你进行lock and unlock</p>\n<h2 id=\"std-lock\"><a href=\"#std-lock\" class=\"headerlink\" title=\"std::lock()\"></a>std::lock()</h2><p>std::lock(my_mutex1,my_mutex2)            #手动unlock</p>\n<p>一次性锁住两个或者两个以上的互斥量，至少两个。如果互斥量中有一个没锁住，它就在那里等着，等所有互斥量都锁住，他才能往下走；要么互斥量都锁住，要么两个互斥量都没有锁住。</p>\n<p><img src=\"/media/7186eb58ef60fc61dc55f573da016c01.png\" alt=\"std: : lock (my_mutexl, my_mutex2) : lock ( ) :  std: : sbguardl (my_mutexl, std: : adopt_lock) :  std: : :mutex\\&gt; sbguard2 (my_mutex2, std: : adopt \\_ lock) \"></p>\n<p><img src=\"/media/b80e022befbbb1f86356f354c265237d.png\" alt=\"4) std: : lock_guardfistd: : adopt \\_  // std: : adopt\\_  std: : lock ard\\&lt;std:  mutex.@i  T ock \"></p>\n<p>这样也不需要手动unlock（）</p>\n<h2 id=\"unique-lock\"><a href=\"#unique-lock\" class=\"headerlink\" title=\"unique_lock()\"></a>unique_lock()</h2><p><img src=\"/media/c48e58454fc351e9fe69d2891a001cae.png\" alt=\"： unique—lockÅR 代 lock—guard  / / un 三 que 一 1 。 Ck 罡 个 类 栀 ， 工 作 中 ， \\*lock-guard （ 推 荐 使 用 ） lock—guard4R 代 了 mutex 的 lock() 和 unlock() ：  //unique-lock 比 lock-guard\\*\\$äffl\\$ 效 粼 上 差 一 点 ， 内 存 占 用 多 一 点 。  ： unique—lockfi% 二 个  / 过 。 Ck 一 guard 可 以 带 第 二 个 孬 数 ： \"></p>\n<p><img src=\"/media/e3b2ae52a820296728e9a11336313dcd.png\" alt=\"彐  //adopt-lock 标 记 作 用 3  /std: :lock_guard\\&lt;std: :mutex 〉 sbguardl (my_mutexl ， std: :adopt_lock):  / / （ 2 ． 0 std: •.adopt-lock ： 表 示 这 个 互 斥 量 已 经 裰 Ck 了 （ 你 必 须 要 把 互 斥 量 提 前 1 。 Ck 了 ， 否 则 会 报 异 常 ）  //std: ： ad 。 pt 过 ock 标 记 的 效 果 就 罡 “ 假 调 用 方 线 程 已 经 拥 有 了 互 斥 的 所 有 椤 （ 已 经 ck() 成 功 了 ）  / / 通 知 1 。 Ck 一 guar 环 需 要 在 构 造 函 中 1 。 Ck 这 个 互 斥 量 了  //unique-lock 也 可 以 ästd: :adopt-lock 标 记 ， 含 义 相 同 ， 就 罡 不 希 望 再 unique 过 。 ck() 的 构 造 函 中 1 。 Ck 这 个 。  / / 用 这 个 ad 。 pt 一 1 。 Ck 前 提 罡 ， 你 需 要 自 己 先 把 “ 先 1 。 Ck 上 3  / / （ 2 ． 2 ） std: :try_to_lock  / / 我 们 会 雲 试 用 的 1 。 ck() 去 锁 定 这 个 ， 但 如 果 没 有 锁 定 成 功 ， 我 也 会 立 即 返 回 ， 不 会 咀 塞 在 那 里  / / 用 这 个 try 一 t 。 一 1 。 Ck 的 前 提 罡 你 自 己 不 能 先 去 1 。 Ck 。  / / （ 2 ． 3 ） std: :defer_lock  / / 用 这 个 defer 一 1 。 Ck 的 前 提 罡 你 不 能 自 己 先 Ck ， 否 则 会 报 异 常 。  //defer-lock 的 意思 就 是 没 有 给 皿 ut 加 锁 ： 初 始 化 了 一 个 没 有 加 锁 的 ex 。  defer lock 、  —unique lock \"></p>\n<p><img src=\"/media/f1a009c02af2e121f29b74a8c7899747.png\" alt=\"： unique-lock 的 成员函颛  / / （ 3 ． 0 lock(), 加 锁  / / （ 3 ． 2 冫 unlock() ， 解 锁 ；  / / （ 3 ． 3 ） try_lock() ， 當 试 结 互 斥 量 加 锁 ， 如 果 蓽 不 到 锁 ， 则 返 回 fa 这 e ， 如 果 蓽 到 了 锁 ， 返 回 true ， 这 个 函 不 咀 塞 的 3  / / （ 3 ， 4 ） release(), 返 回 它 所 管 理 的 对 源 指 针 ， 放 所 有 权 也 就 罡 说 ， 这 个 不 再 有 关 孚 。  / 俨 格 区 分 。 ck() 和 release() 的 区 别 ， 不 要 后 。  / / 如 果 ， 原 来 匚 对 象 处 于 加 锁 状 态 ， 你 有 责 任 接 管 过 来 员 责 解 锁 。 ()e leaseifi 回 的 是 ， 原 始 mute 黑 t 的 指 针 ）  / / 为 什 之 有 时 候 需 要 unlock() ： 因 为 你 1 。 Ck 锁 住 的 代 码 越 少 ， 执 行 越 快 ， 整 个 程 序 运 行 效 率 越 高  07 有 人 也 把 锁 头 锁 住 的 代 码 多 少 称 为 锁 的 粒 廛 ， 粒 廛 一 船 用 粗 細 来 描 述  / / a ） 锁 住 的 代 码 少 ， 这 个 粒 度 叫 细 。 执 行 、 率 高  / / b ） 锁 住 的 代 码 多 ， 粒 度 叫 粗 ， 那 执 行 0 就 低  / / 要 学 会 尽 量 选 择 合 适 粒 度 的 代 码 进 行 保 护 ， 粒 度 太 细 ， 可 能 漏 掉 共 享 据 的 保 护 0 立 廛 太 粗 ， 影 响 效 率 。  / / 选 擇 合 适 的 粒 度 ， 罡 高 程 序 员 的 能 力 和 实 力 的 忭 现 3 \"></p>\n"},{"_content":"# const成员函数\n\nconst成员函数，只要类方法不修改调用对象，就应该将其声明为const\n\n```\nvoid show（）const \n```\n\n\n","source":"_posts/C++/const成员函数.md","raw":"# const成员函数\n\nconst成员函数，只要类方法不修改调用对象，就应该将其声明为const\n\n```\nvoid show（）const \n```\n\n\n","slug":"C++/const成员函数","published":1,"date":"2023-08-24T14:38:18.616Z","updated":"2022-12-30T03:13:44.816Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0td000ldkr75d8jc5cy","content":"<h1 id=\"const成员函数\"><a href=\"#const成员函数\" class=\"headerlink\" title=\"const成员函数\"></a>const成员函数</h1><p>const成员函数，只要类方法不修改调用对象，就应该将其声明为const</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void show（）const </span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-1.png","cover_type":"img","excerpt":"","more":"<h1 id=\"const成员函数\"><a href=\"#const成员函数\" class=\"headerlink\" title=\"const成员函数\"></a>const成员函数</h1><p>const成员函数，只要类方法不修改调用对象，就应该将其声明为const</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void show（）const </span><br></pre></td></tr></table></figure>\n\n\n"},{"_content":"# ROS指令\n\n## ROS Shell命令\n\n| 命令               | 功能                                                |\n| ------------------ | --------------------------------------------------- |\n| roscd              | 移动到指定的ROS软件包目录                           |\n| rosls              | 显示ROS软件包的文件与目录                           |\n| rosed              | 编辑ROS软件包的文件                                 |\n| roscp              | 复制ROS软件包的文件                                 |\n| rospd              | 添加目录至ROS目录索引                               |\n| rosd               | 显示ROS目录索引中的目录                             |\n| roscd [功能包名称] | 使用它，无需再使用cd一层层到查找，进入功能包里      |\n| rosls [功能包名称] | 等价与roscd+ls。查看ROS功能包的文件列表更方便，快捷 |\n| rosed [功能包名称] | 用于编辑功能包中的特定文件，优点也是快捷，修改容易  |\n\n## ROS执行命令\n\n| 命令                                  | 功能                                                         |\n| ------------------------------------- | ------------------------------------------------------------ |\n| roscore                               | 开启Master(ROS名称服务)                                      |\n| rosrun                                | 运行单个节点                                                 |\n| roslaunch                             | 运行多个节点及设置运行选项                                   |\n| rosclean                              | 检查或删除ROS日志文件                                        |\n| roscore [选项]。                      | 运行主节点，主节点管理节点之间的消息通信中的连接信息。关于主节点的具体作用就不累述了 |\n| rosrun [功能包名称] [节点名称]。      | 执行指定的功能包中的一个节点的命令(rosrun rqt_graph rqt_graph 可查看当前系统的运行情况) |\n| roslaunch [功能包名称] [launch文件名] | 类似dat批命令，是运行指定功能包中一个或设置执行选项的命令    |\n| rosclean [选项]                       | 运行roscore时，对所有节点的记录都会写入日志文件，随着时间的推移，需要定期使用rosclean命令删除这些记录 |\n\n## ROS信息命令 \n\n| 命令       | 功能                    |\n| ---------- | ----------------------- |\n| rostopic   | 查看ROS话题信息         |\n| rosservice | 查看ROS服务信息         |\n| rosnode    | 查看ROS节点信息         |\n| rosparam   | 确认和修改ROS参数信息   |\n| rosbag     | 记录和回放ROS消息       |\n| rosmsg     | 显示ROS消息类型         |\n| rossrv     | 显示ROS服务类型         |\n| rosversion | 显示ROS功能包的版本信息 |\n| roswtf     | 检查ROS系统             |\n\n### **rostopic [选项]** \n\nlist - 列出活动话题 \n\necho [话题名称] - 实时显示指定话题的消息内容 \n\nfind [类型名称] - 显示使用指定类型的消息的话题 \n\ntype [话题名称] - 显示指定话题的消息类型 \n\nbw [话题名称] - 显示指定话题的消息类型 \n\nhz [话题名称] - 显示指定话题的消息数据发布周期 \n\ninfo [话题名称] - 显示指定话题的消息 \n\npub [话题名称] [消息类型] [参数] - 用指定的话题名称发布消息，许多时候另开一个终端操作 例：rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist – ‘[2.0, 0.0, 0.0]”[0.0, 0.0, 0.0]’ \n\n\n\n### **rosservice [选项]** \n\nlist - 显示活动的服务信息 \n\ninfo [服务名称] - 显示指定服务的信息 \n\ntype [服务名称] - 显示服务类型 \n\nfind [服务类型] - 查找指定服务类型的服务 \n\nuri [服务名称] - 显示ROSRPC URI服务 \n\nargs [服务名称] - 显示服务参数 \n\ncall [服务名称] [参数] - 用输入的参数请求服务，通常用于测试服务 \n\n \n\n### **rosnode [选项]** \n\nlist - 查看活动的节点列表 \n\nping [节点名称] - 与指定的节点进行连接测试 \n\ninfo [节点名称] - 查看指定节点的信息 \n\nmachine [PC名称或IP] - 查看该PC中运行的节点列表 \n\nkill [节点名称] - 停止指定节点的运行 \n\ncleanup - 删除失连节点的注册信息 \n\n\n\n### **rosparam [参数]** \n\nlist - 查看参数列表 \n\nget [参数名称] - 获取参数值 \n\nset [参数名称] - 设置参数值 \n\ndump [文件名称] - 将参数保存到指定文件 \n\nload [文件名称] - 获取保存在指定文件中的参数，经常使用。 \n\ndelete [参数名称] - 删除参数 \n\n \n\n### **rosmsg [参数]** \n\nlist - 显示所有消息 \n\nshow [消息名称] - 显示指定消息 \n\nmd5 [消息名称] - 显示md5sum \n\npackage [功能包名称] - 显示用于指定功能包的所有消息 \n\npackages - 显示使用消息的所有功能包 \n\n \n\n### **rossrv [参数]** \n\nlist -显示所以服务 \n\nshow [服务名称] - 显示指定的服务信息 \n\nmd5 [服务名称] - 显示md5sum \n\npackage [功能包名称] - 显示指定的功能包中用到的所有服务 \n\npackages - 显示使用服务的所有功能包 \n\n \n\n### rosbag [参数] \n\nrecord [选项] [话题名称] - 将指定话题的消息记录到bag文件 \n\ninfo [文件名称] - 查看bag文件的信息 \n\nplay [文件名称] - 回放指定的bag文件，这个使用玩的也多。 \n\ncompress [文件名称] - 压缩指定的bag文件 \n\ndecompress [文件名称] - 解压指定的bag文件 \n\nfilter [输入文件] [输出文件] [选项] - 生成一个删除了指定内容的新的bag文件 \n\nreindex bag [文件名称] - 刷新索引 \n\ncheck bag [文件名称] - 检查指定的bag文件是否能在当前系统中回放 \n\nfix [输入文件] [输出文件] [选项] - 将由于版本不同而无法回放的bag文件修改可以回放的文件 \n\n## ROS catkin命令\n\ncatkin_create_pkg - 自动生成功能包（示例命令：catkin_create_pkg [功能包名称] [依赖性功能包1] [依赖性功能包2]….）。 \n\ncatkin_make - 基于catkin构建系统的构建 （示例：catkin_make –pkg [包名] 只构建一部分功能包）。 \n\ncatkin_eclipse - 对于用catkin构建系统生成的功能包进行修改，使其能在Eclipse环境中使用。 \n\ncatkin_prepare_release - 在发布时用到的日志整理和版本标记。 \n\ncatkin_generate_changelog - 在发布时生成或更新CHANGLOG.rst文件。 \n\ncatkin_init_workspace - 初始化catkin构建统的工作目录。 \n\ncatkin_find - 搜素catkin，找到并显示工作空间。 \n\n## ROS功能包命令 \n\nrospack [选项] [功能包名称] - 查看与ROS功能包相关的信息(可以使用find, list, depend-on, depends和profile等选项)。 \n\nrosinstall - 安装ROS附加功能包。 \n\nrosdep [选项] - 安装该功能包的依赖性文件（check, install, init, update）。 \n\nroslocate [选项] [功能包名称] - ROS功能包信息相关命令（可用的选项是info, vcs, type, uri和repo等）。 \n\n## 常用的一些指令\n\n| 指令                                  |        含义        |\n| :------------------------------------ | :----------------: |\n| rosrun map_server map_saver           | rviz保存生成的地图 |\n| rosrun map_server map_server map.yaml | rviz加载生成的地图 |\n| rostopic echo <topic> --noarr         |  详细显示话题信息  |\n\n","source":"_posts/C++/ROS指令.md","raw":"# ROS指令\n\n## ROS Shell命令\n\n| 命令               | 功能                                                |\n| ------------------ | --------------------------------------------------- |\n| roscd              | 移动到指定的ROS软件包目录                           |\n| rosls              | 显示ROS软件包的文件与目录                           |\n| rosed              | 编辑ROS软件包的文件                                 |\n| roscp              | 复制ROS软件包的文件                                 |\n| rospd              | 添加目录至ROS目录索引                               |\n| rosd               | 显示ROS目录索引中的目录                             |\n| roscd [功能包名称] | 使用它，无需再使用cd一层层到查找，进入功能包里      |\n| rosls [功能包名称] | 等价与roscd+ls。查看ROS功能包的文件列表更方便，快捷 |\n| rosed [功能包名称] | 用于编辑功能包中的特定文件，优点也是快捷，修改容易  |\n\n## ROS执行命令\n\n| 命令                                  | 功能                                                         |\n| ------------------------------------- | ------------------------------------------------------------ |\n| roscore                               | 开启Master(ROS名称服务)                                      |\n| rosrun                                | 运行单个节点                                                 |\n| roslaunch                             | 运行多个节点及设置运行选项                                   |\n| rosclean                              | 检查或删除ROS日志文件                                        |\n| roscore [选项]。                      | 运行主节点，主节点管理节点之间的消息通信中的连接信息。关于主节点的具体作用就不累述了 |\n| rosrun [功能包名称] [节点名称]。      | 执行指定的功能包中的一个节点的命令(rosrun rqt_graph rqt_graph 可查看当前系统的运行情况) |\n| roslaunch [功能包名称] [launch文件名] | 类似dat批命令，是运行指定功能包中一个或设置执行选项的命令    |\n| rosclean [选项]                       | 运行roscore时，对所有节点的记录都会写入日志文件，随着时间的推移，需要定期使用rosclean命令删除这些记录 |\n\n## ROS信息命令 \n\n| 命令       | 功能                    |\n| ---------- | ----------------------- |\n| rostopic   | 查看ROS话题信息         |\n| rosservice | 查看ROS服务信息         |\n| rosnode    | 查看ROS节点信息         |\n| rosparam   | 确认和修改ROS参数信息   |\n| rosbag     | 记录和回放ROS消息       |\n| rosmsg     | 显示ROS消息类型         |\n| rossrv     | 显示ROS服务类型         |\n| rosversion | 显示ROS功能包的版本信息 |\n| roswtf     | 检查ROS系统             |\n\n### **rostopic [选项]** \n\nlist - 列出活动话题 \n\necho [话题名称] - 实时显示指定话题的消息内容 \n\nfind [类型名称] - 显示使用指定类型的消息的话题 \n\ntype [话题名称] - 显示指定话题的消息类型 \n\nbw [话题名称] - 显示指定话题的消息类型 \n\nhz [话题名称] - 显示指定话题的消息数据发布周期 \n\ninfo [话题名称] - 显示指定话题的消息 \n\npub [话题名称] [消息类型] [参数] - 用指定的话题名称发布消息，许多时候另开一个终端操作 例：rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist – ‘[2.0, 0.0, 0.0]”[0.0, 0.0, 0.0]’ \n\n\n\n### **rosservice [选项]** \n\nlist - 显示活动的服务信息 \n\ninfo [服务名称] - 显示指定服务的信息 \n\ntype [服务名称] - 显示服务类型 \n\nfind [服务类型] - 查找指定服务类型的服务 \n\nuri [服务名称] - 显示ROSRPC URI服务 \n\nargs [服务名称] - 显示服务参数 \n\ncall [服务名称] [参数] - 用输入的参数请求服务，通常用于测试服务 \n\n \n\n### **rosnode [选项]** \n\nlist - 查看活动的节点列表 \n\nping [节点名称] - 与指定的节点进行连接测试 \n\ninfo [节点名称] - 查看指定节点的信息 \n\nmachine [PC名称或IP] - 查看该PC中运行的节点列表 \n\nkill [节点名称] - 停止指定节点的运行 \n\ncleanup - 删除失连节点的注册信息 \n\n\n\n### **rosparam [参数]** \n\nlist - 查看参数列表 \n\nget [参数名称] - 获取参数值 \n\nset [参数名称] - 设置参数值 \n\ndump [文件名称] - 将参数保存到指定文件 \n\nload [文件名称] - 获取保存在指定文件中的参数，经常使用。 \n\ndelete [参数名称] - 删除参数 \n\n \n\n### **rosmsg [参数]** \n\nlist - 显示所有消息 \n\nshow [消息名称] - 显示指定消息 \n\nmd5 [消息名称] - 显示md5sum \n\npackage [功能包名称] - 显示用于指定功能包的所有消息 \n\npackages - 显示使用消息的所有功能包 \n\n \n\n### **rossrv [参数]** \n\nlist -显示所以服务 \n\nshow [服务名称] - 显示指定的服务信息 \n\nmd5 [服务名称] - 显示md5sum \n\npackage [功能包名称] - 显示指定的功能包中用到的所有服务 \n\npackages - 显示使用服务的所有功能包 \n\n \n\n### rosbag [参数] \n\nrecord [选项] [话题名称] - 将指定话题的消息记录到bag文件 \n\ninfo [文件名称] - 查看bag文件的信息 \n\nplay [文件名称] - 回放指定的bag文件，这个使用玩的也多。 \n\ncompress [文件名称] - 压缩指定的bag文件 \n\ndecompress [文件名称] - 解压指定的bag文件 \n\nfilter [输入文件] [输出文件] [选项] - 生成一个删除了指定内容的新的bag文件 \n\nreindex bag [文件名称] - 刷新索引 \n\ncheck bag [文件名称] - 检查指定的bag文件是否能在当前系统中回放 \n\nfix [输入文件] [输出文件] [选项] - 将由于版本不同而无法回放的bag文件修改可以回放的文件 \n\n## ROS catkin命令\n\ncatkin_create_pkg - 自动生成功能包（示例命令：catkin_create_pkg [功能包名称] [依赖性功能包1] [依赖性功能包2]….）。 \n\ncatkin_make - 基于catkin构建系统的构建 （示例：catkin_make –pkg [包名] 只构建一部分功能包）。 \n\ncatkin_eclipse - 对于用catkin构建系统生成的功能包进行修改，使其能在Eclipse环境中使用。 \n\ncatkin_prepare_release - 在发布时用到的日志整理和版本标记。 \n\ncatkin_generate_changelog - 在发布时生成或更新CHANGLOG.rst文件。 \n\ncatkin_init_workspace - 初始化catkin构建统的工作目录。 \n\ncatkin_find - 搜素catkin，找到并显示工作空间。 \n\n## ROS功能包命令 \n\nrospack [选项] [功能包名称] - 查看与ROS功能包相关的信息(可以使用find, list, depend-on, depends和profile等选项)。 \n\nrosinstall - 安装ROS附加功能包。 \n\nrosdep [选项] - 安装该功能包的依赖性文件（check, install, init, update）。 \n\nroslocate [选项] [功能包名称] - ROS功能包信息相关命令（可用的选项是info, vcs, type, uri和repo等）。 \n\n## 常用的一些指令\n\n| 指令                                  |        含义        |\n| :------------------------------------ | :----------------: |\n| rosrun map_server map_saver           | rviz保存生成的地图 |\n| rosrun map_server map_server map.yaml | rviz加载生成的地图 |\n| rostopic echo <topic> --noarr         |  详细显示话题信息  |\n\n","slug":"C++/ROS指令","published":1,"date":"2023-08-24T14:38:18.634Z","updated":"2022-12-30T03:13:44.816Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0te000ndkr7cg16go8m","content":"<h1 id=\"ROS指令\"><a href=\"#ROS指令\" class=\"headerlink\" title=\"ROS指令\"></a>ROS指令</h1><h2 id=\"ROS-Shell命令\"><a href=\"#ROS-Shell命令\" class=\"headerlink\" title=\"ROS Shell命令\"></a>ROS Shell命令</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>roscd</td>\n<td>移动到指定的ROS软件包目录</td>\n</tr>\n<tr>\n<td>rosls</td>\n<td>显示ROS软件包的文件与目录</td>\n</tr>\n<tr>\n<td>rosed</td>\n<td>编辑ROS软件包的文件</td>\n</tr>\n<tr>\n<td>roscp</td>\n<td>复制ROS软件包的文件</td>\n</tr>\n<tr>\n<td>rospd</td>\n<td>添加目录至ROS目录索引</td>\n</tr>\n<tr>\n<td>rosd</td>\n<td>显示ROS目录索引中的目录</td>\n</tr>\n<tr>\n<td>roscd [功能包名称]</td>\n<td>使用它，无需再使用cd一层层到查找，进入功能包里</td>\n</tr>\n<tr>\n<td>rosls [功能包名称]</td>\n<td>等价与roscd+ls。查看ROS功能包的文件列表更方便，快捷</td>\n</tr>\n<tr>\n<td>rosed [功能包名称]</td>\n<td>用于编辑功能包中的特定文件，优点也是快捷，修改容易</td>\n</tr>\n</tbody></table>\n<h2 id=\"ROS执行命令\"><a href=\"#ROS执行命令\" class=\"headerlink\" title=\"ROS执行命令\"></a>ROS执行命令</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>roscore</td>\n<td>开启Master(ROS名称服务)</td>\n</tr>\n<tr>\n<td>rosrun</td>\n<td>运行单个节点</td>\n</tr>\n<tr>\n<td>roslaunch</td>\n<td>运行多个节点及设置运行选项</td>\n</tr>\n<tr>\n<td>rosclean</td>\n<td>检查或删除ROS日志文件</td>\n</tr>\n<tr>\n<td>roscore [选项]。</td>\n<td>运行主节点，主节点管理节点之间的消息通信中的连接信息。关于主节点的具体作用就不累述了</td>\n</tr>\n<tr>\n<td>rosrun [功能包名称] [节点名称]。</td>\n<td>执行指定的功能包中的一个节点的命令(rosrun rqt_graph rqt_graph 可查看当前系统的运行情况)</td>\n</tr>\n<tr>\n<td>roslaunch [功能包名称] [launch文件名]</td>\n<td>类似dat批命令，是运行指定功能包中一个或设置执行选项的命令</td>\n</tr>\n<tr>\n<td>rosclean [选项]</td>\n<td>运行roscore时，对所有节点的记录都会写入日志文件，随着时间的推移，需要定期使用rosclean命令删除这些记录</td>\n</tr>\n</tbody></table>\n<h2 id=\"ROS信息命令\"><a href=\"#ROS信息命令\" class=\"headerlink\" title=\"ROS信息命令\"></a>ROS信息命令</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>rostopic</td>\n<td>查看ROS话题信息</td>\n</tr>\n<tr>\n<td>rosservice</td>\n<td>查看ROS服务信息</td>\n</tr>\n<tr>\n<td>rosnode</td>\n<td>查看ROS节点信息</td>\n</tr>\n<tr>\n<td>rosparam</td>\n<td>确认和修改ROS参数信息</td>\n</tr>\n<tr>\n<td>rosbag</td>\n<td>记录和回放ROS消息</td>\n</tr>\n<tr>\n<td>rosmsg</td>\n<td>显示ROS消息类型</td>\n</tr>\n<tr>\n<td>rossrv</td>\n<td>显示ROS服务类型</td>\n</tr>\n<tr>\n<td>rosversion</td>\n<td>显示ROS功能包的版本信息</td>\n</tr>\n<tr>\n<td>roswtf</td>\n<td>检查ROS系统</td>\n</tr>\n</tbody></table>\n<h3 id=\"rostopic-选项\"><a href=\"#rostopic-选项\" class=\"headerlink\" title=\"rostopic [选项]\"></a><strong>rostopic [选项]</strong></h3><p>list - 列出活动话题 </p>\n<p>echo [话题名称] - 实时显示指定话题的消息内容 </p>\n<p>find [类型名称] - 显示使用指定类型的消息的话题 </p>\n<p>type [话题名称] - 显示指定话题的消息类型 </p>\n<p>bw [话题名称] - 显示指定话题的消息类型 </p>\n<p>hz [话题名称] - 显示指定话题的消息数据发布周期 </p>\n<p>info [话题名称] - 显示指定话题的消息 </p>\n<p>pub [话题名称] [消息类型] [参数] - 用指定的话题名称发布消息，许多时候另开一个终端操作 例：rostopic pub -1 &#x2F;turtle1&#x2F;cmd_vel geometry_msgs&#x2F;Twist – ‘[2.0, 0.0, 0.0]”[0.0, 0.0, 0.0]’ </p>\n<h3 id=\"rosservice-选项\"><a href=\"#rosservice-选项\" class=\"headerlink\" title=\"rosservice [选项]\"></a><strong>rosservice [选项]</strong></h3><p>list - 显示活动的服务信息 </p>\n<p>info [服务名称] - 显示指定服务的信息 </p>\n<p>type [服务名称] - 显示服务类型 </p>\n<p>find [服务类型] - 查找指定服务类型的服务 </p>\n<p>uri [服务名称] - 显示ROSRPC URI服务 </p>\n<p>args [服务名称] - 显示服务参数 </p>\n<p>call [服务名称] [参数] - 用输入的参数请求服务，通常用于测试服务 </p>\n<h3 id=\"rosnode-选项\"><a href=\"#rosnode-选项\" class=\"headerlink\" title=\"rosnode [选项]\"></a><strong>rosnode [选项]</strong></h3><p>list - 查看活动的节点列表 </p>\n<p>ping [节点名称] - 与指定的节点进行连接测试 </p>\n<p>info [节点名称] - 查看指定节点的信息 </p>\n<p>machine [PC名称或IP] - 查看该PC中运行的节点列表 </p>\n<p>kill [节点名称] - 停止指定节点的运行 </p>\n<p>cleanup - 删除失连节点的注册信息 </p>\n<h3 id=\"rosparam-参数\"><a href=\"#rosparam-参数\" class=\"headerlink\" title=\"rosparam [参数]\"></a><strong>rosparam [参数]</strong></h3><p>list - 查看参数列表 </p>\n<p>get [参数名称] - 获取参数值 </p>\n<p>set [参数名称] - 设置参数值 </p>\n<p>dump [文件名称] - 将参数保存到指定文件 </p>\n<p>load [文件名称] - 获取保存在指定文件中的参数，经常使用。 </p>\n<p>delete [参数名称] - 删除参数 </p>\n<h3 id=\"rosmsg-参数\"><a href=\"#rosmsg-参数\" class=\"headerlink\" title=\"rosmsg [参数]\"></a><strong>rosmsg [参数]</strong></h3><p>list - 显示所有消息 </p>\n<p>show [消息名称] - 显示指定消息 </p>\n<p>md5 [消息名称] - 显示md5sum </p>\n<p>package [功能包名称] - 显示用于指定功能包的所有消息 </p>\n<p>packages - 显示使用消息的所有功能包 </p>\n<h3 id=\"rossrv-参数\"><a href=\"#rossrv-参数\" class=\"headerlink\" title=\"rossrv [参数]\"></a><strong>rossrv [参数]</strong></h3><p>list -显示所以服务 </p>\n<p>show [服务名称] - 显示指定的服务信息 </p>\n<p>md5 [服务名称] - 显示md5sum </p>\n<p>package [功能包名称] - 显示指定的功能包中用到的所有服务 </p>\n<p>packages - 显示使用服务的所有功能包 </p>\n<h3 id=\"rosbag-参数\"><a href=\"#rosbag-参数\" class=\"headerlink\" title=\"rosbag [参数]\"></a>rosbag [参数]</h3><p>record [选项] [话题名称] - 将指定话题的消息记录到bag文件 </p>\n<p>info [文件名称] - 查看bag文件的信息 </p>\n<p>play [文件名称] - 回放指定的bag文件，这个使用玩的也多。 </p>\n<p>compress [文件名称] - 压缩指定的bag文件 </p>\n<p>decompress [文件名称] - 解压指定的bag文件 </p>\n<p>filter [输入文件] [输出文件] [选项] - 生成一个删除了指定内容的新的bag文件 </p>\n<p>reindex bag [文件名称] - 刷新索引 </p>\n<p>check bag [文件名称] - 检查指定的bag文件是否能在当前系统中回放 </p>\n<p>fix [输入文件] [输出文件] [选项] - 将由于版本不同而无法回放的bag文件修改可以回放的文件 </p>\n<h2 id=\"ROS-catkin命令\"><a href=\"#ROS-catkin命令\" class=\"headerlink\" title=\"ROS catkin命令\"></a>ROS catkin命令</h2><p>catkin_create_pkg - 自动生成功能包（示例命令：catkin_create_pkg [功能包名称] [依赖性功能包1] [依赖性功能包2]….）。 </p>\n<p>catkin_make - 基于catkin构建系统的构建 （示例：catkin_make –pkg [包名] 只构建一部分功能包）。 </p>\n<p>catkin_eclipse - 对于用catkin构建系统生成的功能包进行修改，使其能在Eclipse环境中使用。 </p>\n<p>catkin_prepare_release - 在发布时用到的日志整理和版本标记。 </p>\n<p>catkin_generate_changelog - 在发布时生成或更新CHANGLOG.rst文件。 </p>\n<p>catkin_init_workspace - 初始化catkin构建统的工作目录。 </p>\n<p>catkin_find - 搜素catkin，找到并显示工作空间。 </p>\n<h2 id=\"ROS功能包命令\"><a href=\"#ROS功能包命令\" class=\"headerlink\" title=\"ROS功能包命令\"></a>ROS功能包命令</h2><p>rospack [选项] [功能包名称] - 查看与ROS功能包相关的信息(可以使用find, list, depend-on, depends和profile等选项)。 </p>\n<p>rosinstall - 安装ROS附加功能包。 </p>\n<p>rosdep [选项] - 安装该功能包的依赖性文件（check, install, init, update）。 </p>\n<p>roslocate [选项] [功能包名称] - ROS功能包信息相关命令（可用的选项是info, vcs, type, uri和repo等）。 </p>\n<h2 id=\"常用的一些指令\"><a href=\"#常用的一些指令\" class=\"headerlink\" title=\"常用的一些指令\"></a>常用的一些指令</h2><table>\n<thead>\n<tr>\n<th align=\"left\">指令</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">rosrun map_server map_saver</td>\n<td align=\"center\">rviz保存生成的地图</td>\n</tr>\n<tr>\n<td align=\"left\">rosrun map_server map_server map.yaml</td>\n<td align=\"center\">rviz加载生成的地图</td>\n</tr>\n<tr>\n<td align=\"left\">rostopic echo <topic> –noarr</td>\n<td align=\"center\">详细显示话题信息</td>\n</tr>\n</tbody></table>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-8.png","cover_type":"img","excerpt":"","more":"<h1 id=\"ROS指令\"><a href=\"#ROS指令\" class=\"headerlink\" title=\"ROS指令\"></a>ROS指令</h1><h2 id=\"ROS-Shell命令\"><a href=\"#ROS-Shell命令\" class=\"headerlink\" title=\"ROS Shell命令\"></a>ROS Shell命令</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>roscd</td>\n<td>移动到指定的ROS软件包目录</td>\n</tr>\n<tr>\n<td>rosls</td>\n<td>显示ROS软件包的文件与目录</td>\n</tr>\n<tr>\n<td>rosed</td>\n<td>编辑ROS软件包的文件</td>\n</tr>\n<tr>\n<td>roscp</td>\n<td>复制ROS软件包的文件</td>\n</tr>\n<tr>\n<td>rospd</td>\n<td>添加目录至ROS目录索引</td>\n</tr>\n<tr>\n<td>rosd</td>\n<td>显示ROS目录索引中的目录</td>\n</tr>\n<tr>\n<td>roscd [功能包名称]</td>\n<td>使用它，无需再使用cd一层层到查找，进入功能包里</td>\n</tr>\n<tr>\n<td>rosls [功能包名称]</td>\n<td>等价与roscd+ls。查看ROS功能包的文件列表更方便，快捷</td>\n</tr>\n<tr>\n<td>rosed [功能包名称]</td>\n<td>用于编辑功能包中的特定文件，优点也是快捷，修改容易</td>\n</tr>\n</tbody></table>\n<h2 id=\"ROS执行命令\"><a href=\"#ROS执行命令\" class=\"headerlink\" title=\"ROS执行命令\"></a>ROS执行命令</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>roscore</td>\n<td>开启Master(ROS名称服务)</td>\n</tr>\n<tr>\n<td>rosrun</td>\n<td>运行单个节点</td>\n</tr>\n<tr>\n<td>roslaunch</td>\n<td>运行多个节点及设置运行选项</td>\n</tr>\n<tr>\n<td>rosclean</td>\n<td>检查或删除ROS日志文件</td>\n</tr>\n<tr>\n<td>roscore [选项]。</td>\n<td>运行主节点，主节点管理节点之间的消息通信中的连接信息。关于主节点的具体作用就不累述了</td>\n</tr>\n<tr>\n<td>rosrun [功能包名称] [节点名称]。</td>\n<td>执行指定的功能包中的一个节点的命令(rosrun rqt_graph rqt_graph 可查看当前系统的运行情况)</td>\n</tr>\n<tr>\n<td>roslaunch [功能包名称] [launch文件名]</td>\n<td>类似dat批命令，是运行指定功能包中一个或设置执行选项的命令</td>\n</tr>\n<tr>\n<td>rosclean [选项]</td>\n<td>运行roscore时，对所有节点的记录都会写入日志文件，随着时间的推移，需要定期使用rosclean命令删除这些记录</td>\n</tr>\n</tbody></table>\n<h2 id=\"ROS信息命令\"><a href=\"#ROS信息命令\" class=\"headerlink\" title=\"ROS信息命令\"></a>ROS信息命令</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>rostopic</td>\n<td>查看ROS话题信息</td>\n</tr>\n<tr>\n<td>rosservice</td>\n<td>查看ROS服务信息</td>\n</tr>\n<tr>\n<td>rosnode</td>\n<td>查看ROS节点信息</td>\n</tr>\n<tr>\n<td>rosparam</td>\n<td>确认和修改ROS参数信息</td>\n</tr>\n<tr>\n<td>rosbag</td>\n<td>记录和回放ROS消息</td>\n</tr>\n<tr>\n<td>rosmsg</td>\n<td>显示ROS消息类型</td>\n</tr>\n<tr>\n<td>rossrv</td>\n<td>显示ROS服务类型</td>\n</tr>\n<tr>\n<td>rosversion</td>\n<td>显示ROS功能包的版本信息</td>\n</tr>\n<tr>\n<td>roswtf</td>\n<td>检查ROS系统</td>\n</tr>\n</tbody></table>\n<h3 id=\"rostopic-选项\"><a href=\"#rostopic-选项\" class=\"headerlink\" title=\"rostopic [选项]\"></a><strong>rostopic [选项]</strong></h3><p>list - 列出活动话题 </p>\n<p>echo [话题名称] - 实时显示指定话题的消息内容 </p>\n<p>find [类型名称] - 显示使用指定类型的消息的话题 </p>\n<p>type [话题名称] - 显示指定话题的消息类型 </p>\n<p>bw [话题名称] - 显示指定话题的消息类型 </p>\n<p>hz [话题名称] - 显示指定话题的消息数据发布周期 </p>\n<p>info [话题名称] - 显示指定话题的消息 </p>\n<p>pub [话题名称] [消息类型] [参数] - 用指定的话题名称发布消息，许多时候另开一个终端操作 例：rostopic pub -1 &#x2F;turtle1&#x2F;cmd_vel geometry_msgs&#x2F;Twist – ‘[2.0, 0.0, 0.0]”[0.0, 0.0, 0.0]’ </p>\n<h3 id=\"rosservice-选项\"><a href=\"#rosservice-选项\" class=\"headerlink\" title=\"rosservice [选项]\"></a><strong>rosservice [选项]</strong></h3><p>list - 显示活动的服务信息 </p>\n<p>info [服务名称] - 显示指定服务的信息 </p>\n<p>type [服务名称] - 显示服务类型 </p>\n<p>find [服务类型] - 查找指定服务类型的服务 </p>\n<p>uri [服务名称] - 显示ROSRPC URI服务 </p>\n<p>args [服务名称] - 显示服务参数 </p>\n<p>call [服务名称] [参数] - 用输入的参数请求服务，通常用于测试服务 </p>\n<h3 id=\"rosnode-选项\"><a href=\"#rosnode-选项\" class=\"headerlink\" title=\"rosnode [选项]\"></a><strong>rosnode [选项]</strong></h3><p>list - 查看活动的节点列表 </p>\n<p>ping [节点名称] - 与指定的节点进行连接测试 </p>\n<p>info [节点名称] - 查看指定节点的信息 </p>\n<p>machine [PC名称或IP] - 查看该PC中运行的节点列表 </p>\n<p>kill [节点名称] - 停止指定节点的运行 </p>\n<p>cleanup - 删除失连节点的注册信息 </p>\n<h3 id=\"rosparam-参数\"><a href=\"#rosparam-参数\" class=\"headerlink\" title=\"rosparam [参数]\"></a><strong>rosparam [参数]</strong></h3><p>list - 查看参数列表 </p>\n<p>get [参数名称] - 获取参数值 </p>\n<p>set [参数名称] - 设置参数值 </p>\n<p>dump [文件名称] - 将参数保存到指定文件 </p>\n<p>load [文件名称] - 获取保存在指定文件中的参数，经常使用。 </p>\n<p>delete [参数名称] - 删除参数 </p>\n<h3 id=\"rosmsg-参数\"><a href=\"#rosmsg-参数\" class=\"headerlink\" title=\"rosmsg [参数]\"></a><strong>rosmsg [参数]</strong></h3><p>list - 显示所有消息 </p>\n<p>show [消息名称] - 显示指定消息 </p>\n<p>md5 [消息名称] - 显示md5sum </p>\n<p>package [功能包名称] - 显示用于指定功能包的所有消息 </p>\n<p>packages - 显示使用消息的所有功能包 </p>\n<h3 id=\"rossrv-参数\"><a href=\"#rossrv-参数\" class=\"headerlink\" title=\"rossrv [参数]\"></a><strong>rossrv [参数]</strong></h3><p>list -显示所以服务 </p>\n<p>show [服务名称] - 显示指定的服务信息 </p>\n<p>md5 [服务名称] - 显示md5sum </p>\n<p>package [功能包名称] - 显示指定的功能包中用到的所有服务 </p>\n<p>packages - 显示使用服务的所有功能包 </p>\n<h3 id=\"rosbag-参数\"><a href=\"#rosbag-参数\" class=\"headerlink\" title=\"rosbag [参数]\"></a>rosbag [参数]</h3><p>record [选项] [话题名称] - 将指定话题的消息记录到bag文件 </p>\n<p>info [文件名称] - 查看bag文件的信息 </p>\n<p>play [文件名称] - 回放指定的bag文件，这个使用玩的也多。 </p>\n<p>compress [文件名称] - 压缩指定的bag文件 </p>\n<p>decompress [文件名称] - 解压指定的bag文件 </p>\n<p>filter [输入文件] [输出文件] [选项] - 生成一个删除了指定内容的新的bag文件 </p>\n<p>reindex bag [文件名称] - 刷新索引 </p>\n<p>check bag [文件名称] - 检查指定的bag文件是否能在当前系统中回放 </p>\n<p>fix [输入文件] [输出文件] [选项] - 将由于版本不同而无法回放的bag文件修改可以回放的文件 </p>\n<h2 id=\"ROS-catkin命令\"><a href=\"#ROS-catkin命令\" class=\"headerlink\" title=\"ROS catkin命令\"></a>ROS catkin命令</h2><p>catkin_create_pkg - 自动生成功能包（示例命令：catkin_create_pkg [功能包名称] [依赖性功能包1] [依赖性功能包2]….）。 </p>\n<p>catkin_make - 基于catkin构建系统的构建 （示例：catkin_make –pkg [包名] 只构建一部分功能包）。 </p>\n<p>catkin_eclipse - 对于用catkin构建系统生成的功能包进行修改，使其能在Eclipse环境中使用。 </p>\n<p>catkin_prepare_release - 在发布时用到的日志整理和版本标记。 </p>\n<p>catkin_generate_changelog - 在发布时生成或更新CHANGLOG.rst文件。 </p>\n<p>catkin_init_workspace - 初始化catkin构建统的工作目录。 </p>\n<p>catkin_find - 搜素catkin，找到并显示工作空间。 </p>\n<h2 id=\"ROS功能包命令\"><a href=\"#ROS功能包命令\" class=\"headerlink\" title=\"ROS功能包命令\"></a>ROS功能包命令</h2><p>rospack [选项] [功能包名称] - 查看与ROS功能包相关的信息(可以使用find, list, depend-on, depends和profile等选项)。 </p>\n<p>rosinstall - 安装ROS附加功能包。 </p>\n<p>rosdep [选项] - 安装该功能包的依赖性文件（check, install, init, update）。 </p>\n<p>roslocate [选项] [功能包名称] - ROS功能包信息相关命令（可用的选项是info, vcs, type, uri和repo等）。 </p>\n<h2 id=\"常用的一些指令\"><a href=\"#常用的一些指令\" class=\"headerlink\" title=\"常用的一些指令\"></a>常用的一些指令</h2><table>\n<thead>\n<tr>\n<th align=\"left\">指令</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">rosrun map_server map_saver</td>\n<td align=\"center\">rviz保存生成的地图</td>\n</tr>\n<tr>\n<td align=\"left\">rosrun map_server map_server map.yaml</td>\n<td align=\"center\">rviz加载生成的地图</td>\n</tr>\n<tr>\n<td align=\"left\">rostopic echo <topic> –noarr</td>\n<td align=\"center\">详细显示话题信息</td>\n</tr>\n</tbody></table>\n"},{"_content":"# gflags使用\n\n## 简单用法\n\n### 1.加上 `gflags` 头文件\n\n```\n#include <gflags/gflags.h>\n```\n\n### 2.将需要命令行参数变量进行定义\n\n用法如下：\n\n```\nDEFINE_string(变量名，默认值，描述);\n```\n\n`DEFINE_string` 只是其中一种类型，其他类型还有：\n\n| gflags 定义类型 | 描述             |\n| --------------- | ---------------- |\n| DEFINE_bool     | 布尔类型         |\n| DEFINE_int32    | 32 位整数        |\n| EFINE_int64     | 64 位整数        |\n| DEFINE_uint64   | 无符号 64 位整数 |\n| EFINE_double    | 浮点类型 double  |\n| DEFINE_string   | C++ string 类型  |\n\n### 3.在main函数加入如下解析命令行参数，一般都放在 main 开始位置\n\n```\ngflags::ParseCommandLineFlags(&argc, &argv, true);\n```\n\n### 4.访问参数\n\n```\nstd::cout << \"MYSTR is: \" << FLAGS_mystr << endl;\n```\n\n**注意使用`FLAGS_` + `DEFINE_string` 中申明的变量名即可调用**\n\n### 5.使用\n\n```\ng++ gflags_test.cc -o gflags_test -lgflags -lpthread \t\t#-l 链接库进行编译\n./gflags_test -mystr=\"this is a value of gflags' member \"\t# 使用\nMYSTR is: this is a value of gflags' member  \t\t\t\t# 输出\n```\n\n\n每一种类型的定义和使用都跟上面我们的例子相似，有所不同的是 bool 参数，bool 参数在命令行可以不指定值也可以指定值，假如我们定义了一个 bool 参数 debug_bool，可以在命令行这样指定2：\n\n```\n./gflags_test -debug_bool \t\t# 这样就是 true\n./gflags_test -debug_bool=true\t# 这样也是 true\n./gflags_test -debug_bool=1 \t\t# 这样也是 true\n./gflags_test -debug_bool=false \t# 0是false\n```\n\n## 简单使用实例\n\n```\n#include <iostream>\n#include <gflags/gflags.h>\n\nDEFINE_string(name, \"zhang san\", \"your name\");\nDEFINE_int32(age, 18, \"your age\");\n\nint main(int argc, char** argv) {\n\tgflags::ParseCommandLineFlags(&argc, &argv, true);\n\tstd::cout << \"your name is : \" << FLAGS_name\n        << \", your age is: \" << FLAGS_name << std::endl;\n    return 0;\n}\n```\n\n## 进阶使用\n\n### 1.跨文件调用\n\n如果你想要访问在另一个文件定义的 gflags 变量呢？使用 DECLARE_，它的作用就相当于用 extern 声明变量。为了方便的管理变量，我们推荐在 .cc 或者 .cpp文件中DEFINE 变量，然后只在对应.h 中或者单元测试中 DECLARE 变量。\n\n例如，在foo.cc 定义了一个 gflags 变量 DEFINE_string(name, 'bob', '')，假如你需要在其他文件中使用该变量，那么在 foo.h 中声明 DECLARE_string(name)，然后在使用该变量的文件中 include \"foo.h\" 就可以。当然，这只是为了更好地管理文件关联，如果你不想遵循也是可以的。\n\n## 2.参数检查\n\n使用方法如下：\n\n#### 定义校验函数：\n\n```\nstatic bool ValidatePort(const char* flagname, int32 value) {\n\tif (value > 0 && value < 200)   \n     \treturn true;\n   \tprintf(\"Invalid value for --%s: %d\\n\", flagname, (int)value);\n   \treturn false;\n}\n```\n\n### 使用全局 static 变量来注册函数，static 变量会在 main 函数开始时就调用, 在DEFINE下定义\n\n```\nDEFINE_int32(age, 18, \"your age\");\nstatic const bool port_dummy = gflags::RegisterFlagValidator(&FLAGS_port, &ValidatePort);\n```\n\n### 在输入不合法是就会报错\n\n### 3.flagfile 使用配置文件\n\n在一个配置文件中写上，在此将其命名为 user.flags:\n\n```\n--name=\"zhangsan\"\n--age=18\n```\n\n使用\n\n```\n./gflags_test --flagfile  user.flags \n```\n\n","source":"_posts/C++/gflags使用.md","raw":"# gflags使用\n\n## 简单用法\n\n### 1.加上 `gflags` 头文件\n\n```\n#include <gflags/gflags.h>\n```\n\n### 2.将需要命令行参数变量进行定义\n\n用法如下：\n\n```\nDEFINE_string(变量名，默认值，描述);\n```\n\n`DEFINE_string` 只是其中一种类型，其他类型还有：\n\n| gflags 定义类型 | 描述             |\n| --------------- | ---------------- |\n| DEFINE_bool     | 布尔类型         |\n| DEFINE_int32    | 32 位整数        |\n| EFINE_int64     | 64 位整数        |\n| DEFINE_uint64   | 无符号 64 位整数 |\n| EFINE_double    | 浮点类型 double  |\n| DEFINE_string   | C++ string 类型  |\n\n### 3.在main函数加入如下解析命令行参数，一般都放在 main 开始位置\n\n```\ngflags::ParseCommandLineFlags(&argc, &argv, true);\n```\n\n### 4.访问参数\n\n```\nstd::cout << \"MYSTR is: \" << FLAGS_mystr << endl;\n```\n\n**注意使用`FLAGS_` + `DEFINE_string` 中申明的变量名即可调用**\n\n### 5.使用\n\n```\ng++ gflags_test.cc -o gflags_test -lgflags -lpthread \t\t#-l 链接库进行编译\n./gflags_test -mystr=\"this is a value of gflags' member \"\t# 使用\nMYSTR is: this is a value of gflags' member  \t\t\t\t# 输出\n```\n\n\n每一种类型的定义和使用都跟上面我们的例子相似，有所不同的是 bool 参数，bool 参数在命令行可以不指定值也可以指定值，假如我们定义了一个 bool 参数 debug_bool，可以在命令行这样指定2：\n\n```\n./gflags_test -debug_bool \t\t# 这样就是 true\n./gflags_test -debug_bool=true\t# 这样也是 true\n./gflags_test -debug_bool=1 \t\t# 这样也是 true\n./gflags_test -debug_bool=false \t# 0是false\n```\n\n## 简单使用实例\n\n```\n#include <iostream>\n#include <gflags/gflags.h>\n\nDEFINE_string(name, \"zhang san\", \"your name\");\nDEFINE_int32(age, 18, \"your age\");\n\nint main(int argc, char** argv) {\n\tgflags::ParseCommandLineFlags(&argc, &argv, true);\n\tstd::cout << \"your name is : \" << FLAGS_name\n        << \", your age is: \" << FLAGS_name << std::endl;\n    return 0;\n}\n```\n\n## 进阶使用\n\n### 1.跨文件调用\n\n如果你想要访问在另一个文件定义的 gflags 变量呢？使用 DECLARE_，它的作用就相当于用 extern 声明变量。为了方便的管理变量，我们推荐在 .cc 或者 .cpp文件中DEFINE 变量，然后只在对应.h 中或者单元测试中 DECLARE 变量。\n\n例如，在foo.cc 定义了一个 gflags 变量 DEFINE_string(name, 'bob', '')，假如你需要在其他文件中使用该变量，那么在 foo.h 中声明 DECLARE_string(name)，然后在使用该变量的文件中 include \"foo.h\" 就可以。当然，这只是为了更好地管理文件关联，如果你不想遵循也是可以的。\n\n## 2.参数检查\n\n使用方法如下：\n\n#### 定义校验函数：\n\n```\nstatic bool ValidatePort(const char* flagname, int32 value) {\n\tif (value > 0 && value < 200)   \n     \treturn true;\n   \tprintf(\"Invalid value for --%s: %d\\n\", flagname, (int)value);\n   \treturn false;\n}\n```\n\n### 使用全局 static 变量来注册函数，static 变量会在 main 函数开始时就调用, 在DEFINE下定义\n\n```\nDEFINE_int32(age, 18, \"your age\");\nstatic const bool port_dummy = gflags::RegisterFlagValidator(&FLAGS_port, &ValidatePort);\n```\n\n### 在输入不合法是就会报错\n\n### 3.flagfile 使用配置文件\n\n在一个配置文件中写上，在此将其命名为 user.flags:\n\n```\n--name=\"zhangsan\"\n--age=18\n```\n\n使用\n\n```\n./gflags_test --flagfile  user.flags \n```\n\n","slug":"C++/gflags使用","published":1,"date":"2023-08-24T14:38:18.625Z","updated":"2022-12-30T03:13:44.816Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0te000odkr72hg83jo1","content":"<h1 id=\"gflags使用\"><a href=\"#gflags使用\" class=\"headerlink\" title=\"gflags使用\"></a>gflags使用</h1><h2 id=\"简单用法\"><a href=\"#简单用法\" class=\"headerlink\" title=\"简单用法\"></a>简单用法</h2><h3 id=\"1-加上-gflags-头文件\"><a href=\"#1-加上-gflags-头文件\" class=\"headerlink\" title=\"1.加上 gflags 头文件\"></a>1.加上 <code>gflags</code> 头文件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;gflags/gflags.h&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-将需要命令行参数变量进行定义\"><a href=\"#2-将需要命令行参数变量进行定义\" class=\"headerlink\" title=\"2.将需要命令行参数变量进行定义\"></a>2.将需要命令行参数变量进行定义</h3><p>用法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEFINE_string(变量名，默认值，描述);</span><br></pre></td></tr></table></figure>\n\n<p><code>DEFINE_string</code> 只是其中一种类型，其他类型还有：</p>\n<table>\n<thead>\n<tr>\n<th>gflags 定义类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DEFINE_bool</td>\n<td>布尔类型</td>\n</tr>\n<tr>\n<td>DEFINE_int32</td>\n<td>32 位整数</td>\n</tr>\n<tr>\n<td>EFINE_int64</td>\n<td>64 位整数</td>\n</tr>\n<tr>\n<td>DEFINE_uint64</td>\n<td>无符号 64 位整数</td>\n</tr>\n<tr>\n<td>EFINE_double</td>\n<td>浮点类型 double</td>\n</tr>\n<tr>\n<td>DEFINE_string</td>\n<td>C++ string 类型</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-在main函数加入如下解析命令行参数，一般都放在-main-开始位置\"><a href=\"#3-在main函数加入如下解析命令行参数，一般都放在-main-开始位置\" class=\"headerlink\" title=\"3.在main函数加入如下解析命令行参数，一般都放在 main 开始位置\"></a>3.在main函数加入如下解析命令行参数，一般都放在 main 开始位置</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gflags::ParseCommandLineFlags(&amp;argc, &amp;argv, true);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-访问参数\"><a href=\"#4-访问参数\" class=\"headerlink\" title=\"4.访问参数\"></a>4.访问参数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::cout &lt;&lt; &quot;MYSTR is: &quot; &lt;&lt; FLAGS_mystr &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意使用<code>FLAGS_</code> + <code>DEFINE_string</code> 中申明的变量名即可调用</strong></p>\n<h3 id=\"5-使用\"><a href=\"#5-使用\" class=\"headerlink\" title=\"5.使用\"></a>5.使用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ gflags_test.cc -o gflags_test -lgflags -lpthread \t\t#-l 链接库进行编译</span><br><span class=\"line\">./gflags_test -mystr=&quot;this is a value of gflags&#x27; member &quot;\t# 使用</span><br><span class=\"line\">MYSTR is: this is a value of gflags&#x27; member  \t\t\t\t# 输出</span><br></pre></td></tr></table></figure>\n\n\n<p>每一种类型的定义和使用都跟上面我们的例子相似，有所不同的是 bool 参数，bool 参数在命令行可以不指定值也可以指定值，假如我们定义了一个 bool 参数 debug_bool，可以在命令行这样指定2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./gflags_test -debug_bool \t\t# 这样就是 true</span><br><span class=\"line\">./gflags_test -debug_bool=true\t# 这样也是 true</span><br><span class=\"line\">./gflags_test -debug_bool=1 \t\t# 这样也是 true</span><br><span class=\"line\">./gflags_test -debug_bool=false \t# 0是false</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"简单使用实例\"><a href=\"#简单使用实例\" class=\"headerlink\" title=\"简单使用实例\"></a>简单使用实例</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;gflags/gflags.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">DEFINE_string(name, &quot;zhang san&quot;, &quot;your name&quot;);</span><br><span class=\"line\">DEFINE_int32(age, 18, &quot;your age&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char** argv) &#123;</span><br><span class=\"line\">\tgflags::ParseCommandLineFlags(&amp;argc, &amp;argv, true);</span><br><span class=\"line\">\tstd::cout &lt;&lt; &quot;your name is : &quot; &lt;&lt; FLAGS_name</span><br><span class=\"line\">        &lt;&lt; &quot;, your age is: &quot; &lt;&lt; FLAGS_name &lt;&lt; std::endl;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进阶使用\"><a href=\"#进阶使用\" class=\"headerlink\" title=\"进阶使用\"></a>进阶使用</h2><h3 id=\"1-跨文件调用\"><a href=\"#1-跨文件调用\" class=\"headerlink\" title=\"1.跨文件调用\"></a>1.跨文件调用</h3><p>如果你想要访问在另一个文件定义的 gflags 变量呢？使用 DECLARE_，它的作用就相当于用 extern 声明变量。为了方便的管理变量，我们推荐在 .cc 或者 .cpp文件中DEFINE 变量，然后只在对应.h 中或者单元测试中 DECLARE 变量。</p>\n<p>例如，在foo.cc 定义了一个 gflags 变量 DEFINE_string(name, ‘bob’, ‘’)，假如你需要在其他文件中使用该变量，那么在 foo.h 中声明 DECLARE_string(name)，然后在使用该变量的文件中 include “foo.h” 就可以。当然，这只是为了更好地管理文件关联，如果你不想遵循也是可以的。</p>\n<h2 id=\"2-参数检查\"><a href=\"#2-参数检查\" class=\"headerlink\" title=\"2.参数检查\"></a>2.参数检查</h2><p>使用方法如下：</p>\n<h4 id=\"定义校验函数：\"><a href=\"#定义校验函数：\" class=\"headerlink\" title=\"定义校验函数：\"></a>定义校验函数：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static bool ValidatePort(const char* flagname, int32 value) &#123;</span><br><span class=\"line\">\tif (value &gt; 0 &amp;&amp; value &lt; 200)   </span><br><span class=\"line\">     \treturn true;</span><br><span class=\"line\">   \tprintf(&quot;Invalid value for --%s: %d\\n&quot;, flagname, (int)value);</span><br><span class=\"line\">   \treturn false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用全局-static-变量来注册函数，static-变量会在-main-函数开始时就调用-在DEFINE下定义\"><a href=\"#使用全局-static-变量来注册函数，static-变量会在-main-函数开始时就调用-在DEFINE下定义\" class=\"headerlink\" title=\"使用全局 static 变量来注册函数，static 变量会在 main 函数开始时就调用, 在DEFINE下定义\"></a>使用全局 static 变量来注册函数，static 变量会在 main 函数开始时就调用, 在DEFINE下定义</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEFINE_int32(age, 18, &quot;your age&quot;);</span><br><span class=\"line\">static const bool port_dummy = gflags::RegisterFlagValidator(&amp;FLAGS_port, &amp;ValidatePort);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在输入不合法是就会报错\"><a href=\"#在输入不合法是就会报错\" class=\"headerlink\" title=\"在输入不合法是就会报错\"></a>在输入不合法是就会报错</h3><h3 id=\"3-flagfile-使用配置文件\"><a href=\"#3-flagfile-使用配置文件\" class=\"headerlink\" title=\"3.flagfile 使用配置文件\"></a>3.flagfile 使用配置文件</h3><p>在一个配置文件中写上，在此将其命名为 user.flags:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--name=&quot;zhangsan&quot;</span><br><span class=\"line\">--age=18</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./gflags_test --flagfile  user.flags </span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-1.png","cover_type":"img","excerpt":"","more":"<h1 id=\"gflags使用\"><a href=\"#gflags使用\" class=\"headerlink\" title=\"gflags使用\"></a>gflags使用</h1><h2 id=\"简单用法\"><a href=\"#简单用法\" class=\"headerlink\" title=\"简单用法\"></a>简单用法</h2><h3 id=\"1-加上-gflags-头文件\"><a href=\"#1-加上-gflags-头文件\" class=\"headerlink\" title=\"1.加上 gflags 头文件\"></a>1.加上 <code>gflags</code> 头文件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;gflags/gflags.h&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-将需要命令行参数变量进行定义\"><a href=\"#2-将需要命令行参数变量进行定义\" class=\"headerlink\" title=\"2.将需要命令行参数变量进行定义\"></a>2.将需要命令行参数变量进行定义</h3><p>用法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEFINE_string(变量名，默认值，描述);</span><br></pre></td></tr></table></figure>\n\n<p><code>DEFINE_string</code> 只是其中一种类型，其他类型还有：</p>\n<table>\n<thead>\n<tr>\n<th>gflags 定义类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DEFINE_bool</td>\n<td>布尔类型</td>\n</tr>\n<tr>\n<td>DEFINE_int32</td>\n<td>32 位整数</td>\n</tr>\n<tr>\n<td>EFINE_int64</td>\n<td>64 位整数</td>\n</tr>\n<tr>\n<td>DEFINE_uint64</td>\n<td>无符号 64 位整数</td>\n</tr>\n<tr>\n<td>EFINE_double</td>\n<td>浮点类型 double</td>\n</tr>\n<tr>\n<td>DEFINE_string</td>\n<td>C++ string 类型</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-在main函数加入如下解析命令行参数，一般都放在-main-开始位置\"><a href=\"#3-在main函数加入如下解析命令行参数，一般都放在-main-开始位置\" class=\"headerlink\" title=\"3.在main函数加入如下解析命令行参数，一般都放在 main 开始位置\"></a>3.在main函数加入如下解析命令行参数，一般都放在 main 开始位置</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gflags::ParseCommandLineFlags(&amp;argc, &amp;argv, true);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-访问参数\"><a href=\"#4-访问参数\" class=\"headerlink\" title=\"4.访问参数\"></a>4.访问参数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::cout &lt;&lt; &quot;MYSTR is: &quot; &lt;&lt; FLAGS_mystr &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意使用<code>FLAGS_</code> + <code>DEFINE_string</code> 中申明的变量名即可调用</strong></p>\n<h3 id=\"5-使用\"><a href=\"#5-使用\" class=\"headerlink\" title=\"5.使用\"></a>5.使用</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ gflags_test.cc -o gflags_test -lgflags -lpthread \t\t#-l 链接库进行编译</span><br><span class=\"line\">./gflags_test -mystr=&quot;this is a value of gflags&#x27; member &quot;\t# 使用</span><br><span class=\"line\">MYSTR is: this is a value of gflags&#x27; member  \t\t\t\t# 输出</span><br></pre></td></tr></table></figure>\n\n\n<p>每一种类型的定义和使用都跟上面我们的例子相似，有所不同的是 bool 参数，bool 参数在命令行可以不指定值也可以指定值，假如我们定义了一个 bool 参数 debug_bool，可以在命令行这样指定2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./gflags_test -debug_bool \t\t# 这样就是 true</span><br><span class=\"line\">./gflags_test -debug_bool=true\t# 这样也是 true</span><br><span class=\"line\">./gflags_test -debug_bool=1 \t\t# 这样也是 true</span><br><span class=\"line\">./gflags_test -debug_bool=false \t# 0是false</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"简单使用实例\"><a href=\"#简单使用实例\" class=\"headerlink\" title=\"简单使用实例\"></a>简单使用实例</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;gflags/gflags.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">DEFINE_string(name, &quot;zhang san&quot;, &quot;your name&quot;);</span><br><span class=\"line\">DEFINE_int32(age, 18, &quot;your age&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char** argv) &#123;</span><br><span class=\"line\">\tgflags::ParseCommandLineFlags(&amp;argc, &amp;argv, true);</span><br><span class=\"line\">\tstd::cout &lt;&lt; &quot;your name is : &quot; &lt;&lt; FLAGS_name</span><br><span class=\"line\">        &lt;&lt; &quot;, your age is: &quot; &lt;&lt; FLAGS_name &lt;&lt; std::endl;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进阶使用\"><a href=\"#进阶使用\" class=\"headerlink\" title=\"进阶使用\"></a>进阶使用</h2><h3 id=\"1-跨文件调用\"><a href=\"#1-跨文件调用\" class=\"headerlink\" title=\"1.跨文件调用\"></a>1.跨文件调用</h3><p>如果你想要访问在另一个文件定义的 gflags 变量呢？使用 DECLARE_，它的作用就相当于用 extern 声明变量。为了方便的管理变量，我们推荐在 .cc 或者 .cpp文件中DEFINE 变量，然后只在对应.h 中或者单元测试中 DECLARE 变量。</p>\n<p>例如，在foo.cc 定义了一个 gflags 变量 DEFINE_string(name, ‘bob’, ‘’)，假如你需要在其他文件中使用该变量，那么在 foo.h 中声明 DECLARE_string(name)，然后在使用该变量的文件中 include “foo.h” 就可以。当然，这只是为了更好地管理文件关联，如果你不想遵循也是可以的。</p>\n<h2 id=\"2-参数检查\"><a href=\"#2-参数检查\" class=\"headerlink\" title=\"2.参数检查\"></a>2.参数检查</h2><p>使用方法如下：</p>\n<h4 id=\"定义校验函数：\"><a href=\"#定义校验函数：\" class=\"headerlink\" title=\"定义校验函数：\"></a>定义校验函数：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static bool ValidatePort(const char* flagname, int32 value) &#123;</span><br><span class=\"line\">\tif (value &gt; 0 &amp;&amp; value &lt; 200)   </span><br><span class=\"line\">     \treturn true;</span><br><span class=\"line\">   \tprintf(&quot;Invalid value for --%s: %d\\n&quot;, flagname, (int)value);</span><br><span class=\"line\">   \treturn false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用全局-static-变量来注册函数，static-变量会在-main-函数开始时就调用-在DEFINE下定义\"><a href=\"#使用全局-static-变量来注册函数，static-变量会在-main-函数开始时就调用-在DEFINE下定义\" class=\"headerlink\" title=\"使用全局 static 变量来注册函数，static 变量会在 main 函数开始时就调用, 在DEFINE下定义\"></a>使用全局 static 变量来注册函数，static 变量会在 main 函数开始时就调用, 在DEFINE下定义</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEFINE_int32(age, 18, &quot;your age&quot;);</span><br><span class=\"line\">static const bool port_dummy = gflags::RegisterFlagValidator(&amp;FLAGS_port, &amp;ValidatePort);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在输入不合法是就会报错\"><a href=\"#在输入不合法是就会报错\" class=\"headerlink\" title=\"在输入不合法是就会报错\"></a>在输入不合法是就会报错</h3><h3 id=\"3-flagfile-使用配置文件\"><a href=\"#3-flagfile-使用配置文件\" class=\"headerlink\" title=\"3.flagfile 使用配置文件\"></a>3.flagfile 使用配置文件</h3><p>在一个配置文件中写上，在此将其命名为 user.flags:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--name=&quot;zhangsan&quot;</span><br><span class=\"line\">--age=18</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./gflags_test --flagfile  user.flags </span><br></pre></td></tr></table></figure>\n\n"},{"_content":"\n\n# cin与get（）getline（）输入问题\n\n\n\ngetline和get这两个函数都读取一行输入直到到达换行符，然而不同的是getline丢弃换行符，而get将换行符保留在输入流中。\n\n```c++\n#include <string> \n#include <iostream>\nusing namespace std;\n \nint main() {\nchar a;\nint b;\nfloat c;\nstring str;\ncin>>a>>b>>c>>str;\ncout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<str<<endl;\n \nstring test;\ngetline(cin,test);        //不阻塞\ncout<<\"test:\"<<test<<endl;\nreturn 0;\n}\n\n```\n\n输出：\n\n![这里写图片描述](media/1dc08fc545592a16bdd4e69456f7603f.png)\n\n\n\n输入：\n\n```c++\nString a;\ncin >> a;\ncout << a << endl;\nstring h;\ncin >> h;\ncout << h << endl;\n \nstring b;\nchar g;\ngetline(cin, b, ':');\ncout << b << endl;\n//cin.get();\ncin.get(g);\ncout << \"g=\" << g << endl;\n\n```\n\n输出：\n\n```\nasd zxc\nasd\nzxc\nasd:zxc\n \nasd\ng=z\n```\n\n当 cin\\>\\> 从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin\\>\\> 会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin\\>\\> 不做处理。\n\n从结果可以看出，cin\\>\\> 对缓冲区中的第一个换行符视而不见，采取的措施是忽略清除，继续阻塞等待缓冲区有效数据的到来。但是，getline() 读取数据时，并非像 cin\\>\\> 那样忽略第一个换行符，getline() 发现 cin 的缓冲区中有一个残留的换行符，不阻塞请求键盘输入，直接读取，送入目标字符串后，因为读取的内容为空，所以程序中的变量 test 为空串。\n\n当getline（）采用特定字符作为标识符时，标识符后面的回车和其他输入字符串会保留在输入流中。\n\n\n","source":"_posts/C++/cin与get()getline()输入问题.md","raw":"\n\n# cin与get（）getline（）输入问题\n\n\n\ngetline和get这两个函数都读取一行输入直到到达换行符，然而不同的是getline丢弃换行符，而get将换行符保留在输入流中。\n\n```c++\n#include <string> \n#include <iostream>\nusing namespace std;\n \nint main() {\nchar a;\nint b;\nfloat c;\nstring str;\ncin>>a>>b>>c>>str;\ncout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<str<<endl;\n \nstring test;\ngetline(cin,test);        //不阻塞\ncout<<\"test:\"<<test<<endl;\nreturn 0;\n}\n\n```\n\n输出：\n\n![这里写图片描述](media/1dc08fc545592a16bdd4e69456f7603f.png)\n\n\n\n输入：\n\n```c++\nString a;\ncin >> a;\ncout << a << endl;\nstring h;\ncin >> h;\ncout << h << endl;\n \nstring b;\nchar g;\ngetline(cin, b, ':');\ncout << b << endl;\n//cin.get();\ncin.get(g);\ncout << \"g=\" << g << endl;\n\n```\n\n输出：\n\n```\nasd zxc\nasd\nzxc\nasd:zxc\n \nasd\ng=z\n```\n\n当 cin\\>\\> 从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin\\>\\> 会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin\\>\\> 不做处理。\n\n从结果可以看出，cin\\>\\> 对缓冲区中的第一个换行符视而不见，采取的措施是忽略清除，继续阻塞等待缓冲区有效数据的到来。但是，getline() 读取数据时，并非像 cin\\>\\> 那样忽略第一个换行符，getline() 发现 cin 的缓冲区中有一个残留的换行符，不阻塞请求键盘输入，直接读取，送入目标字符串后，因为读取的内容为空，所以程序中的变量 test 为空串。\n\n当getline（）采用特定字符作为标识符时，标识符后面的回车和其他输入字符串会保留在输入流中。\n\n\n","slug":"C++/cin与get()getline()输入问题","published":1,"date":"2023-08-24T14:38:18.611Z","updated":"2022-12-30T03:13:44.816Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0ti000qdkr7dv4g8748","content":"<h1 id=\"cin与get（）getline（）输入问题\"><a href=\"#cin与get（）getline（）输入问题\" class=\"headerlink\" title=\"cin与get（）getline（）输入问题\"></a>cin与get（）getline（）输入问题</h1><p>getline和get这两个函数都读取一行输入直到到达换行符，然而不同的是getline丢弃换行符，而get将换行符保留在输入流中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"type\">char</span> a;</span><br><span class=\"line\"><span class=\"type\">int</span> b;</span><br><span class=\"line\"><span class=\"type\">float</span> c;</span><br><span class=\"line\">string str;</span><br><span class=\"line\">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;str;</span><br><span class=\"line\">cout&lt;&lt;a&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;c&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">string test;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(cin,test);        <span class=\"comment\">//不阻塞</span></span><br><span class=\"line\">cout&lt;&lt;<span class=\"string\">&quot;test:&quot;</span>&lt;&lt;test&lt;&lt;endl;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<p><img src=\"/media/1dc08fc545592a16bdd4e69456f7603f.png\" alt=\"这里写图片描述\"></p>\n<p>输入：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a;</span><br><span class=\"line\">cin &gt;&gt; a;</span><br><span class=\"line\">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">string h;</span><br><span class=\"line\">cin &gt;&gt; h;</span><br><span class=\"line\">cout &lt;&lt; h &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">string b;</span><br><span class=\"line\"><span class=\"type\">char</span> g;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(cin, b, <span class=\"string\">&#x27;:&#x27;</span>);</span><br><span class=\"line\">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">//cin.get();</span></span><br><span class=\"line\">cin.<span class=\"built_in\">get</span>(g);</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;g=&quot;</span> &lt;&lt; g &lt;&lt; endl;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asd zxc</span><br><span class=\"line\">asd</span><br><span class=\"line\">zxc</span><br><span class=\"line\">asd:zxc</span><br><span class=\"line\"> </span><br><span class=\"line\">asd</span><br><span class=\"line\">g=z</span><br></pre></td></tr></table></figure>\n\n<p>当 cin&gt;&gt; 从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin&gt;&gt; 会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin&gt;&gt; 不做处理。</p>\n<p>从结果可以看出，cin&gt;&gt; 对缓冲区中的第一个换行符视而不见，采取的措施是忽略清除，继续阻塞等待缓冲区有效数据的到来。但是，getline() 读取数据时，并非像 cin&gt;&gt; 那样忽略第一个换行符，getline() 发现 cin 的缓冲区中有一个残留的换行符，不阻塞请求键盘输入，直接读取，送入目标字符串后，因为读取的内容为空，所以程序中的变量 test 为空串。</p>\n<p>当getline（）采用特定字符作为标识符时，标识符后面的回车和其他输入字符串会保留在输入流中。</p>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-4.png","cover_type":"img","excerpt":"","more":"<h1 id=\"cin与get（）getline（）输入问题\"><a href=\"#cin与get（）getline（）输入问题\" class=\"headerlink\" title=\"cin与get（）getline（）输入问题\"></a>cin与get（）getline（）输入问题</h1><p>getline和get这两个函数都读取一行输入直到到达换行符，然而不同的是getline丢弃换行符，而get将换行符保留在输入流中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"type\">char</span> a;</span><br><span class=\"line\"><span class=\"type\">int</span> b;</span><br><span class=\"line\"><span class=\"type\">float</span> c;</span><br><span class=\"line\">string str;</span><br><span class=\"line\">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;str;</span><br><span class=\"line\">cout&lt;&lt;a&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;c&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">string test;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(cin,test);        <span class=\"comment\">//不阻塞</span></span><br><span class=\"line\">cout&lt;&lt;<span class=\"string\">&quot;test:&quot;</span>&lt;&lt;test&lt;&lt;endl;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<p><img src=\"/media/1dc08fc545592a16bdd4e69456f7603f.png\" alt=\"这里写图片描述\"></p>\n<p>输入：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String a;</span><br><span class=\"line\">cin &gt;&gt; a;</span><br><span class=\"line\">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">string h;</span><br><span class=\"line\">cin &gt;&gt; h;</span><br><span class=\"line\">cout &lt;&lt; h &lt;&lt; endl;</span><br><span class=\"line\"> </span><br><span class=\"line\">string b;</span><br><span class=\"line\"><span class=\"type\">char</span> g;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(cin, b, <span class=\"string\">&#x27;:&#x27;</span>);</span><br><span class=\"line\">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">//cin.get();</span></span><br><span class=\"line\">cin.<span class=\"built_in\">get</span>(g);</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;g=&quot;</span> &lt;&lt; g &lt;&lt; endl;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asd zxc</span><br><span class=\"line\">asd</span><br><span class=\"line\">zxc</span><br><span class=\"line\">asd:zxc</span><br><span class=\"line\"> </span><br><span class=\"line\">asd</span><br><span class=\"line\">g=z</span><br></pre></td></tr></table></figure>\n\n<p>当 cin&gt;&gt; 从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin&gt;&gt; 会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin&gt;&gt; 不做处理。</p>\n<p>从结果可以看出，cin&gt;&gt; 对缓冲区中的第一个换行符视而不见，采取的措施是忽略清除，继续阻塞等待缓冲区有效数据的到来。但是，getline() 读取数据时，并非像 cin&gt;&gt; 那样忽略第一个换行符，getline() 发现 cin 的缓冲区中有一个残留的换行符，不阻塞请求键盘输入，直接读取，送入目标字符串后，因为读取的内容为空，所以程序中的变量 test 为空串。</p>\n<p>当getline（）采用特定字符作为标识符时，标识符后面的回车和其他输入字符串会保留在输入流中。</p>\n"},{"_content":"# opencv常用api\n\n\n\n## **cvFloor：**\n\n返回不大于参数的最大整数值\n\n\n\n## **cvCeil：**\n\n返回不小于参数的最小整数值\n\n\n\n## **cvRound：**\n\n四舍五入\n\n\n\n## **Range类：**\n\n表示从start到end但是不包含end\n\n\n\n## **Mat::rowRange** and **Mat::colRange:** \n\n返回某些行或者列（只取左边界而不取右边界）\n\nexp:img1.rowRange(10,10);\n\n\n\n## **Rect(int x, int y, int width, int height)**;\n\n裁剪图片\n\n参数含义：\n\nRect（左上角x坐标 ， 左上角y坐标，矩形的宽，矩形的高）\n\nexp:img2 = img1(Rect(10,19,20,29);\n\n\n\n## **Mat::reshape(int cn, int rows)**:\n\ncn表示通道数，如果设置值为0则表示拖到不变，rows表示行数，如果设置为0则表示行数不变。 函数对原有矩阵进行序列化\n\n\n\n## **Mat::resize() ：**\n\n```\nvoid cv::resize(InputArray src,OutputArray dst,Size dsize,double fx = 0,double fy = 0,int interpolation = INTER_LINEAR)\n```\n\n![s rc  dsize  dst  fx , fy  interpolation  numpy. ndarray  tuple\\<int\\>  int  None  int ZÄ,  opencv ](media/84e9d962295b753134094e778499e2a0.png)\n\nexp：resize(img1, img2, Size(100, 100));\n\n\n\n## **copyTo：**\n\nimg1.copyTo(img2);\n\n\n\n## **clone():** \n\nimg2 = img1.clone();","source":"_posts/C++/opencv常用api.md","raw":"# opencv常用api\n\n\n\n## **cvFloor：**\n\n返回不大于参数的最大整数值\n\n\n\n## **cvCeil：**\n\n返回不小于参数的最小整数值\n\n\n\n## **cvRound：**\n\n四舍五入\n\n\n\n## **Range类：**\n\n表示从start到end但是不包含end\n\n\n\n## **Mat::rowRange** and **Mat::colRange:** \n\n返回某些行或者列（只取左边界而不取右边界）\n\nexp:img1.rowRange(10,10);\n\n\n\n## **Rect(int x, int y, int width, int height)**;\n\n裁剪图片\n\n参数含义：\n\nRect（左上角x坐标 ， 左上角y坐标，矩形的宽，矩形的高）\n\nexp:img2 = img1(Rect(10,19,20,29);\n\n\n\n## **Mat::reshape(int cn, int rows)**:\n\ncn表示通道数，如果设置值为0则表示拖到不变，rows表示行数，如果设置为0则表示行数不变。 函数对原有矩阵进行序列化\n\n\n\n## **Mat::resize() ：**\n\n```\nvoid cv::resize(InputArray src,OutputArray dst,Size dsize,double fx = 0,double fy = 0,int interpolation = INTER_LINEAR)\n```\n\n![s rc  dsize  dst  fx , fy  interpolation  numpy. ndarray  tuple\\<int\\>  int  None  int ZÄ,  opencv ](media/84e9d962295b753134094e778499e2a0.png)\n\nexp：resize(img1, img2, Size(100, 100));\n\n\n\n## **copyTo：**\n\nimg1.copyTo(img2);\n\n\n\n## **clone():** \n\nimg2 = img1.clone();","slug":"C++/opencv常用api","published":1,"date":"2023-08-24T14:38:18.631Z","updated":"2022-12-30T03:13:44.833Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0ti000rdkr7f0jqb11p","content":"<h1 id=\"opencv常用api\"><a href=\"#opencv常用api\" class=\"headerlink\" title=\"opencv常用api\"></a>opencv常用api</h1><h2 id=\"cvFloor：\"><a href=\"#cvFloor：\" class=\"headerlink\" title=\"cvFloor：\"></a><strong>cvFloor：</strong></h2><p>返回不大于参数的最大整数值</p>\n<h2 id=\"cvCeil：\"><a href=\"#cvCeil：\" class=\"headerlink\" title=\"cvCeil：\"></a><strong>cvCeil：</strong></h2><p>返回不小于参数的最小整数值</p>\n<h2 id=\"cvRound：\"><a href=\"#cvRound：\" class=\"headerlink\" title=\"cvRound：\"></a><strong>cvRound：</strong></h2><p>四舍五入</p>\n<h2 id=\"Range类：\"><a href=\"#Range类：\" class=\"headerlink\" title=\"Range类：\"></a><strong>Range类：</strong></h2><p>表示从start到end但是不包含end</p>\n<h2 id=\"Mat-rowRange-and-Mat-colRange\"><a href=\"#Mat-rowRange-and-Mat-colRange\" class=\"headerlink\" title=\"Mat::rowRange and Mat::colRange:\"></a><strong>Mat::rowRange</strong> and <strong>Mat::colRange:</strong></h2><p>返回某些行或者列（只取左边界而不取右边界）</p>\n<p>exp:img1.rowRange(10,10);</p>\n<h2 id=\"Rect-int-x-int-y-int-width-int-height\"><a href=\"#Rect-int-x-int-y-int-width-int-height\" class=\"headerlink\" title=\"Rect(int x, int y, int width, int height);\"></a><strong>Rect(int x, int y, int width, int height)</strong>;</h2><p>裁剪图片</p>\n<p>参数含义：</p>\n<p>Rect（左上角x坐标 ， 左上角y坐标，矩形的宽，矩形的高）</p>\n<p>exp:img2 &#x3D; img1(Rect(10,19,20,29);</p>\n<h2 id=\"Mat-reshape-int-cn-int-rows\"><a href=\"#Mat-reshape-int-cn-int-rows\" class=\"headerlink\" title=\"Mat::reshape(int cn, int rows):\"></a><strong>Mat::reshape(int cn, int rows)</strong>:</h2><p>cn表示通道数，如果设置值为0则表示拖到不变，rows表示行数，如果设置为0则表示行数不变。 函数对原有矩阵进行序列化</p>\n<h2 id=\"Mat-resize-：\"><a href=\"#Mat-resize-：\" class=\"headerlink\" title=\"Mat::resize() ：\"></a><strong>Mat::resize() ：</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cv::resize(InputArray src,OutputArray dst,Size dsize,double fx = 0,double fy = 0,int interpolation = INTER_LINEAR)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/media/84e9d962295b753134094e778499e2a0.png\" alt=\"s rc  dsize  dst  fx , fy  interpolation  numpy. ndarray  tuple\\&lt;int\\&gt;  int  None  int ZÄ,  opencv \"></p>\n<p>exp：resize(img1, img2, Size(100, 100));</p>\n<h2 id=\"copyTo：\"><a href=\"#copyTo：\" class=\"headerlink\" title=\"copyTo：\"></a><strong>copyTo：</strong></h2><p>img1.copyTo(img2);</p>\n<h2 id=\"clone\"><a href=\"#clone\" class=\"headerlink\" title=\"clone():\"></a><strong>clone():</strong></h2><p>img2 &#x3D; img1.clone();</p>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-1.png","cover_type":"img","excerpt":"","more":"<h1 id=\"opencv常用api\"><a href=\"#opencv常用api\" class=\"headerlink\" title=\"opencv常用api\"></a>opencv常用api</h1><h2 id=\"cvFloor：\"><a href=\"#cvFloor：\" class=\"headerlink\" title=\"cvFloor：\"></a><strong>cvFloor：</strong></h2><p>返回不大于参数的最大整数值</p>\n<h2 id=\"cvCeil：\"><a href=\"#cvCeil：\" class=\"headerlink\" title=\"cvCeil：\"></a><strong>cvCeil：</strong></h2><p>返回不小于参数的最小整数值</p>\n<h2 id=\"cvRound：\"><a href=\"#cvRound：\" class=\"headerlink\" title=\"cvRound：\"></a><strong>cvRound：</strong></h2><p>四舍五入</p>\n<h2 id=\"Range类：\"><a href=\"#Range类：\" class=\"headerlink\" title=\"Range类：\"></a><strong>Range类：</strong></h2><p>表示从start到end但是不包含end</p>\n<h2 id=\"Mat-rowRange-and-Mat-colRange\"><a href=\"#Mat-rowRange-and-Mat-colRange\" class=\"headerlink\" title=\"Mat::rowRange and Mat::colRange:\"></a><strong>Mat::rowRange</strong> and <strong>Mat::colRange:</strong></h2><p>返回某些行或者列（只取左边界而不取右边界）</p>\n<p>exp:img1.rowRange(10,10);</p>\n<h2 id=\"Rect-int-x-int-y-int-width-int-height\"><a href=\"#Rect-int-x-int-y-int-width-int-height\" class=\"headerlink\" title=\"Rect(int x, int y, int width, int height);\"></a><strong>Rect(int x, int y, int width, int height)</strong>;</h2><p>裁剪图片</p>\n<p>参数含义：</p>\n<p>Rect（左上角x坐标 ， 左上角y坐标，矩形的宽，矩形的高）</p>\n<p>exp:img2 &#x3D; img1(Rect(10,19,20,29);</p>\n<h2 id=\"Mat-reshape-int-cn-int-rows\"><a href=\"#Mat-reshape-int-cn-int-rows\" class=\"headerlink\" title=\"Mat::reshape(int cn, int rows):\"></a><strong>Mat::reshape(int cn, int rows)</strong>:</h2><p>cn表示通道数，如果设置值为0则表示拖到不变，rows表示行数，如果设置为0则表示行数不变。 函数对原有矩阵进行序列化</p>\n<h2 id=\"Mat-resize-：\"><a href=\"#Mat-resize-：\" class=\"headerlink\" title=\"Mat::resize() ：\"></a><strong>Mat::resize() ：</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cv::resize(InputArray src,OutputArray dst,Size dsize,double fx = 0,double fy = 0,int interpolation = INTER_LINEAR)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/media/84e9d962295b753134094e778499e2a0.png\" alt=\"s rc  dsize  dst  fx , fy  interpolation  numpy. ndarray  tuple\\&lt;int\\&gt;  int  None  int ZÄ,  opencv \"></p>\n<p>exp：resize(img1, img2, Size(100, 100));</p>\n<h2 id=\"copyTo：\"><a href=\"#copyTo：\" class=\"headerlink\" title=\"copyTo：\"></a><strong>copyTo：</strong></h2><p>img1.copyTo(img2);</p>\n<h2 id=\"clone\"><a href=\"#clone\" class=\"headerlink\" title=\"clone():\"></a><strong>clone():</strong></h2><p>img2 &#x3D; img1.clone();</p>\n"},{"_content":"# string和cstring头文件的区别\n\n\n\n-   \\<**string.h**\\> 是C语言标准库的头文件之一，包含了一些字符串/内存处理相关的函数（如 strcpy，memcpy 等）。\n-   **\\<cstring\\>** 是C++语言标准库的头文件之一，基本上就是 \\<string.h\\> 的C++版本，当编写C++程序时如果需要使用 \\<string.h\\>，则应当用 \\<cstring\\> 代替，并加上 std:: 前缀（如 std::strcpy，std::memcpy 等）。\n-   **\\<string\\>** 是C++语言标准库的头文件之一，主要包含了 std::basic_string 模板及其相关函数\n","source":"_posts/C++/string和cstring头文件的区别.md","raw":"# string和cstring头文件的区别\n\n\n\n-   \\<**string.h**\\> 是C语言标准库的头文件之一，包含了一些字符串/内存处理相关的函数（如 strcpy，memcpy 等）。\n-   **\\<cstring\\>** 是C++语言标准库的头文件之一，基本上就是 \\<string.h\\> 的C++版本，当编写C++程序时如果需要使用 \\<string.h\\>，则应当用 \\<cstring\\> 代替，并加上 std:: 前缀（如 std::strcpy，std::memcpy 等）。\n-   **\\<string\\>** 是C++语言标准库的头文件之一，主要包含了 std::basic_string 模板及其相关函数\n","slug":"C++/string和cstring头文件的区别","published":1,"date":"2023-08-24T14:38:18.637Z","updated":"2022-12-30T03:13:44.834Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0ti000sdkr7ee0ob7j5","content":"<h1 id=\"string和cstring头文件的区别\"><a href=\"#string和cstring头文件的区别\" class=\"headerlink\" title=\"string和cstring头文件的区别\"></a>string和cstring头文件的区别</h1><ul>\n<li>&lt;**string.h**&gt; 是C语言标准库的头文件之一，包含了一些字符串&#x2F;内存处理相关的函数（如 strcpy，memcpy 等）。</li>\n<li><strong>&lt;cstring&gt;</strong> 是C++语言标准库的头文件之一，基本上就是 &lt;string.h&gt; 的C++版本，当编写C++程序时如果需要使用 &lt;string.h&gt;，则应当用 &lt;cstring&gt; 代替，并加上 std:: 前缀（如 std::strcpy，std::memcpy 等）。</li>\n<li><strong>&lt;string&gt;</strong> 是C++语言标准库的头文件之一，主要包含了 std::basic_string 模板及其相关函数</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-4.png","cover_type":"img","excerpt":"","more":"<h1 id=\"string和cstring头文件的区别\"><a href=\"#string和cstring头文件的区别\" class=\"headerlink\" title=\"string和cstring头文件的区别\"></a>string和cstring头文件的区别</h1><ul>\n<li>&lt;**string.h**&gt; 是C语言标准库的头文件之一，包含了一些字符串&#x2F;内存处理相关的函数（如 strcpy，memcpy 等）。</li>\n<li><strong>&lt;cstring&gt;</strong> 是C++语言标准库的头文件之一，基本上就是 &lt;string.h&gt; 的C++版本，当编写C++程序时如果需要使用 &lt;string.h&gt;，则应当用 &lt;cstring&gt; 代替，并加上 std:: 前缀（如 std::strcpy，std::memcpy 等）。</li>\n<li><strong>&lt;string&gt;</strong> 是C++语言标准库的头文件之一，主要包含了 std::basic_string 模板及其相关函数</li>\n</ul>\n"},{"_content":"# 内联函数\n\n\n\n**内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。**","source":"_posts/C++/内联函数.md","raw":"# 内联函数\n\n\n\n**内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。**","slug":"C++/内联函数","published":1,"date":"2023-08-24T14:38:18.640Z","updated":"2022-12-30T03:13:44.834Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0tj000tdkr71hqx1703","content":"<h1 id=\"内联函数\"><a href=\"#内联函数\" class=\"headerlink\" title=\"内联函数\"></a>内联函数</h1><p><strong>内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。</strong></p>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-1.png","cover_type":"img","excerpt":"","more":"<h1 id=\"内联函数\"><a href=\"#内联函数\" class=\"headerlink\" title=\"内联函数\"></a>内联函数</h1><p><strong>内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。</strong></p>\n"},{"_content":"# 函数指针的定义方式\n\n```c++\nvoid func(inta,charc)\n{\n\tprintf(\"helloworld\\n\");\n}\n \nvoid test01()\n{\n\t//1、先定义出函数类型，再通过类型定义函数指针\n\ttypedef void(FUNC_TYPE)(int,char);\n \n\tFUNC_TYPE * pFunc = func;\n\t//pFunc(10,'a');\n \n\t//2、定义出函数指针类型，通过类型定义函数指针变量\n\ttypedefvoid( * FUNC_TYPE2)(int,char);\n \n\tFUNC_TYPE2p Func2 = func;\n\t//pFunc2(20,'b');\n \n \n\t//3、直接定义函数指针变量\n\tvoid( * pFunc3)(int,char) = func;\n\tpFunc3(30,'c');\n \n\t//函数指针和指针函数区别？\n\t//函数指针指向了函数的指针\n\t//指针函数函数返回值是指针的函数\n}\n\n```\n\n\n","source":"_posts/C++/函数指针的定义方式.md","raw":"# 函数指针的定义方式\n\n```c++\nvoid func(inta,charc)\n{\n\tprintf(\"helloworld\\n\");\n}\n \nvoid test01()\n{\n\t//1、先定义出函数类型，再通过类型定义函数指针\n\ttypedef void(FUNC_TYPE)(int,char);\n \n\tFUNC_TYPE * pFunc = func;\n\t//pFunc(10,'a');\n \n\t//2、定义出函数指针类型，通过类型定义函数指针变量\n\ttypedefvoid( * FUNC_TYPE2)(int,char);\n \n\tFUNC_TYPE2p Func2 = func;\n\t//pFunc2(20,'b');\n \n \n\t//3、直接定义函数指针变量\n\tvoid( * pFunc3)(int,char) = func;\n\tpFunc3(30,'c');\n \n\t//函数指针和指针函数区别？\n\t//函数指针指向了函数的指针\n\t//指针函数函数返回值是指针的函数\n}\n\n```\n\n\n","slug":"C++/函数指针的定义方式","published":1,"date":"2023-08-24T14:38:18.641Z","updated":"2022-12-30T03:13:44.834Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0tj000udkr7ca4tghyd","content":"<h1 id=\"函数指针的定义方式\"><a href=\"#函数指针的定义方式\" class=\"headerlink\" title=\"函数指针的定义方式\"></a>函数指针的定义方式</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(inta,charc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;helloworld\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//1、先定义出函数类型，再通过类型定义函数指针</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span><span class=\"params\">(FUNC_TYPE)</span><span class=\"params\">(<span class=\"type\">int</span>,<span class=\"type\">char</span>)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tFUNC_TYPE * pFunc = func;</span><br><span class=\"line\">\t<span class=\"comment\">//pFunc(10,&#x27;a&#x27;);</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">//2、定义出函数指针类型，通过类型定义函数指针变量</span></span><br><span class=\"line\">\t<span class=\"built_in\">typedefvoid</span>( * FUNC_TYPE2)(<span class=\"type\">int</span>,<span class=\"type\">char</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">\tFUNC_TYPE2p Func2 = func;</span><br><span class=\"line\">\t<span class=\"comment\">//pFunc2(20,&#x27;b&#x27;);</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">//3、直接定义函数指针变量</span></span><br><span class=\"line\">\t<span class=\"built_in\">void</span>( * pFunc3)(<span class=\"type\">int</span>,<span class=\"type\">char</span>) = func;</span><br><span class=\"line\">\t<span class=\"built_in\">pFunc3</span>(<span class=\"number\">30</span>,<span class=\"string\">&#x27;c&#x27;</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">//函数指针和指针函数区别？</span></span><br><span class=\"line\">\t<span class=\"comment\">//函数指针指向了函数的指针</span></span><br><span class=\"line\">\t<span class=\"comment\">//指针函数函数返回值是指针的函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-9.png","cover_type":"img","excerpt":"","more":"<h1 id=\"函数指针的定义方式\"><a href=\"#函数指针的定义方式\" class=\"headerlink\" title=\"函数指针的定义方式\"></a>函数指针的定义方式</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(inta,charc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;helloworld\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//1、先定义出函数类型，再通过类型定义函数指针</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span><span class=\"params\">(FUNC_TYPE)</span><span class=\"params\">(<span class=\"type\">int</span>,<span class=\"type\">char</span>)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">\tFUNC_TYPE * pFunc = func;</span><br><span class=\"line\">\t<span class=\"comment\">//pFunc(10,&#x27;a&#x27;);</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">//2、定义出函数指针类型，通过类型定义函数指针变量</span></span><br><span class=\"line\">\t<span class=\"built_in\">typedefvoid</span>( * FUNC_TYPE2)(<span class=\"type\">int</span>,<span class=\"type\">char</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">\tFUNC_TYPE2p Func2 = func;</span><br><span class=\"line\">\t<span class=\"comment\">//pFunc2(20,&#x27;b&#x27;);</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">//3、直接定义函数指针变量</span></span><br><span class=\"line\">\t<span class=\"built_in\">void</span>( * pFunc3)(<span class=\"type\">int</span>,<span class=\"type\">char</span>) = func;</span><br><span class=\"line\">\t<span class=\"built_in\">pFunc3</span>(<span class=\"number\">30</span>,<span class=\"string\">&#x27;c&#x27;</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">//函数指针和指针函数区别？</span></span><br><span class=\"line\">\t<span class=\"comment\">//函数指针指向了函数的指针</span></span><br><span class=\"line\">\t<span class=\"comment\">//指针函数函数返回值是指针的函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"_content":"# 一、左值与右值\n\n- 啥是左值和右值呢？\n\n  左值：在[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)有确定存储地址、有变量名，表达式结束依然存在的值，简单来说左值就是非临时对象。\n  右值：就是在内存没有确定存储地址、没有变量名，[表达式](https://so.csdn.net/so/search?q=表达式&spm=1001.2101.3001.7020)结束就会销毁的值，简单来说右值就是临时对象。\n\n  ```\n  int a = 0;  // 在这条语句中，a 是左值，0 是临时值，就是右值。\n  ```\n\n- 左值可以分为两类：非常量左值和常量左值；\n\n  ```\n  int a=10;              \t// a 为非常量左值（有确定存储地址，也有变量名）\n  const int a1=10;      //a1 为常量左值（有确定存储地址，也有变量名）\n  const int a2=20;      //a2 为常量左值（有确定存储地址，也有变量名）\n  ```\n\n- 同理，右值也可以分为两类：非常量右值和常量右值。\n\n  ```\n   int a=10;              \t// 10 为非常量右值\n  const int a1=10;      \n  const int a2=20;      \n  a1+a2               \t// (a1+a2) 为常量右值\n  ```\n\n# 二、左值引用于右值引用\n\n- **知道了左值与右值了，那啥是左值引用与右值引用呢？**\n\n  左值引用：其实就是绑定到左值的引用，通过&来获得左值引用。\n\n  - 左值引用举例：\n\n    ```\n    int a=10;              //非常量左值（有确定存储地址，也有变量名）\n    const int a1=10;       //常量左值（有确定存储地址，也有变量名）\n    const int a2=20;       //常量左值（有确定存储地址，也有变量名）\n     \n    //非常量左值引用\n    int &b1=a;            //正确，a是一个非常量左值，可以被非常量左值引用绑定\n    int &b2=a1;           //错误,a1是一个常量左值，不可以被非常量左值引用绑定\n    int &b3=10;           //错误，10是一个非常量右值，不可以被非常量左值引用绑定\n    int &b4=a1+a2;        //错误,（a1+a2）是一个常量右值，不可以被非常量左值引用绑定\n    \n    //常量左值引用\n    const int &c1=a;      //正确，a是一个非常量左值，可以被非常量右值引用绑定\n    const int &c2=a1;     //正确,a1是一个常量左值，可以被非常量右值引用绑定\n    const int &c3=a+a1;   //正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定\n    const int &c4=a1+a2;  //正确,（a1+a2）是一个常量右值，可以被非常量右值引用绑定\n    ```\n\n  - 总结归纳：非常量左值引用只能绑定到非常量左值上；常量左值引用可以绑定到非常量左值、常量左值、非常量右值、常量右值等所有的值类型。\n\n  右值引用：其实也是绑定到右值的引用，通过&&来获得右值引用。\n\n  - 右值引用举例：\n\n    ```\n    int a=10;             //非常量左值（有确定存储地址，也有变量名）\n    const int a1=20;      //常量左值（有确定存储地址，也有变量名）\n    const int a2=20;      //常量左值（有确定存储地址，也有变量名）\n    \n    //非常量右值引用\n    int &&b1=a;            //错误，a是一个非常量左值，不可以被非常量右值引用绑定\n    int &&b2=a1;           //错误,a1是一个常量左值，不可以被非常量右值引用绑定\n    int &&b3=10;           //正确，10是一个非常量右值，可以被非常量右值引用绑定\n    int &&b4=a1+a2;        //错误,（a1+a2）是一个常量右值，不可以被非常量右值引用绑定\n    \n    //常量右值引用\n    const int &&c1=a;      //错误，a是一个非常量左值，不可以被常量右值引用绑定\n    const int &&c2=a1;     //错误,a1是一个常量左值，不可以被常量右值引用绑定\n    const int &&c3=a+a1;   //正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定\n    const int &&c4=a1+a2;  //正确,（a1+a2）是一个常量右值，不可以被常量右值引用绑定\n    ```\n\n  - 总结归纳：非常量右值引用只能绑定到非常量右值上；常量右值引用可以绑定到非常量右值、常量右值上。\n\n    ![](./media/3d9e381b93fe4df790357680b15d4635.png)\n\n    **从上述可以发现，常量左值引用可以绑定到右值上，但右值引用不能绑定任何类型的左值，若想利用右值引用绑定左值该怎么办呢？**\n\n- C++11中提供了一个标准库move函数获得绑定到左值上的右值引用，即直接调用std::move告诉编译器将左值像对待同类型右值一样处理，但是被调用后的左值将不能再被使用。\n\n  - **std::move()函数举例**\n\n    ```\n    int a=10;                 //非常量左值（有确定存储地址，也有变量名）\n    const int a1=20;          //常量左值（有确定存储地址，也有变量名）\n    \n    //非常量右值引用\n    int &&d1=std::move(a);    //正确，将非常量左值a转换为非常量右值，可以被非常量右值引用绑定\n    int &&d2=std::move(a1);    //错误,将常量左值a1转换为常量右值，不可以被非常量右值引用绑定\n    \n    //常量右值引用\n    const int &&c1=std::move(a);      //正确，将非常量左值a转换为非常量右值，可以被常量右值引用绑定\n    const int &&c2=std::move(a1);     //正确,将常量左值a1转换为常量右值，可以被常量右值引用绑定\n    ```\n\n    最后可以发现，编译器利用std::move将左值强制转换为相同类型的右值之后，引用情况跟右值是一模一样的。\n\n# 三、右值引用与左值引用的区别\n\n- 1、左值引用绑定到有确定存储空间以及变量名的对象上，表达式结束后对象依然存在；\n\n- 2、右值引用绑定到要求转换的表达式、字面常量、返回右值的表达式等临时对象上，赋值表达式结束后就对象就会被销毁。\n\n- 3、左值引用后可以利用别名修改左值对象；右值引用绑定的值不能修改。\n\n# 四、引入右值引用的原因\n\n- 1、替代需要销毁对象的拷贝，提高效率：某些情况下，需要拷贝一个对象然后将其销毁，如：临时类对象的拷贝就要先将旧内存的资源拷贝到新内存，然后释放旧内存，引入右值引用后，就可以让新对象直接使用旧内存并且销毁原对象，这样就减少了内存和运算资源的使用，从而提高了运行效率；\n\n- 2、移动含有不能共享资源的类对象：像IO、unique_ptr这样的类包含不能被共享的资源（如：IO缓冲、指针），因此，这些类对象不能拷贝但可以移动。这种情况，需要先调用std::move将左值强制转换为右值，再进行右值引用。\n","source":"_posts/C++/左值与右值.md","raw":"# 一、左值与右值\n\n- 啥是左值和右值呢？\n\n  左值：在[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)有确定存储地址、有变量名，表达式结束依然存在的值，简单来说左值就是非临时对象。\n  右值：就是在内存没有确定存储地址、没有变量名，[表达式](https://so.csdn.net/so/search?q=表达式&spm=1001.2101.3001.7020)结束就会销毁的值，简单来说右值就是临时对象。\n\n  ```\n  int a = 0;  // 在这条语句中，a 是左值，0 是临时值，就是右值。\n  ```\n\n- 左值可以分为两类：非常量左值和常量左值；\n\n  ```\n  int a=10;              \t// a 为非常量左值（有确定存储地址，也有变量名）\n  const int a1=10;      //a1 为常量左值（有确定存储地址，也有变量名）\n  const int a2=20;      //a2 为常量左值（有确定存储地址，也有变量名）\n  ```\n\n- 同理，右值也可以分为两类：非常量右值和常量右值。\n\n  ```\n   int a=10;              \t// 10 为非常量右值\n  const int a1=10;      \n  const int a2=20;      \n  a1+a2               \t// (a1+a2) 为常量右值\n  ```\n\n# 二、左值引用于右值引用\n\n- **知道了左值与右值了，那啥是左值引用与右值引用呢？**\n\n  左值引用：其实就是绑定到左值的引用，通过&来获得左值引用。\n\n  - 左值引用举例：\n\n    ```\n    int a=10;              //非常量左值（有确定存储地址，也有变量名）\n    const int a1=10;       //常量左值（有确定存储地址，也有变量名）\n    const int a2=20;       //常量左值（有确定存储地址，也有变量名）\n     \n    //非常量左值引用\n    int &b1=a;            //正确，a是一个非常量左值，可以被非常量左值引用绑定\n    int &b2=a1;           //错误,a1是一个常量左值，不可以被非常量左值引用绑定\n    int &b3=10;           //错误，10是一个非常量右值，不可以被非常量左值引用绑定\n    int &b4=a1+a2;        //错误,（a1+a2）是一个常量右值，不可以被非常量左值引用绑定\n    \n    //常量左值引用\n    const int &c1=a;      //正确，a是一个非常量左值，可以被非常量右值引用绑定\n    const int &c2=a1;     //正确,a1是一个常量左值，可以被非常量右值引用绑定\n    const int &c3=a+a1;   //正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定\n    const int &c4=a1+a2;  //正确,（a1+a2）是一个常量右值，可以被非常量右值引用绑定\n    ```\n\n  - 总结归纳：非常量左值引用只能绑定到非常量左值上；常量左值引用可以绑定到非常量左值、常量左值、非常量右值、常量右值等所有的值类型。\n\n  右值引用：其实也是绑定到右值的引用，通过&&来获得右值引用。\n\n  - 右值引用举例：\n\n    ```\n    int a=10;             //非常量左值（有确定存储地址，也有变量名）\n    const int a1=20;      //常量左值（有确定存储地址，也有变量名）\n    const int a2=20;      //常量左值（有确定存储地址，也有变量名）\n    \n    //非常量右值引用\n    int &&b1=a;            //错误，a是一个非常量左值，不可以被非常量右值引用绑定\n    int &&b2=a1;           //错误,a1是一个常量左值，不可以被非常量右值引用绑定\n    int &&b3=10;           //正确，10是一个非常量右值，可以被非常量右值引用绑定\n    int &&b4=a1+a2;        //错误,（a1+a2）是一个常量右值，不可以被非常量右值引用绑定\n    \n    //常量右值引用\n    const int &&c1=a;      //错误，a是一个非常量左值，不可以被常量右值引用绑定\n    const int &&c2=a1;     //错误,a1是一个常量左值，不可以被常量右值引用绑定\n    const int &&c3=a+a1;   //正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定\n    const int &&c4=a1+a2;  //正确,（a1+a2）是一个常量右值，不可以被常量右值引用绑定\n    ```\n\n  - 总结归纳：非常量右值引用只能绑定到非常量右值上；常量右值引用可以绑定到非常量右值、常量右值上。\n\n    ![](./media/3d9e381b93fe4df790357680b15d4635.png)\n\n    **从上述可以发现，常量左值引用可以绑定到右值上，但右值引用不能绑定任何类型的左值，若想利用右值引用绑定左值该怎么办呢？**\n\n- C++11中提供了一个标准库move函数获得绑定到左值上的右值引用，即直接调用std::move告诉编译器将左值像对待同类型右值一样处理，但是被调用后的左值将不能再被使用。\n\n  - **std::move()函数举例**\n\n    ```\n    int a=10;                 //非常量左值（有确定存储地址，也有变量名）\n    const int a1=20;          //常量左值（有确定存储地址，也有变量名）\n    \n    //非常量右值引用\n    int &&d1=std::move(a);    //正确，将非常量左值a转换为非常量右值，可以被非常量右值引用绑定\n    int &&d2=std::move(a1);    //错误,将常量左值a1转换为常量右值，不可以被非常量右值引用绑定\n    \n    //常量右值引用\n    const int &&c1=std::move(a);      //正确，将非常量左值a转换为非常量右值，可以被常量右值引用绑定\n    const int &&c2=std::move(a1);     //正确,将常量左值a1转换为常量右值，可以被常量右值引用绑定\n    ```\n\n    最后可以发现，编译器利用std::move将左值强制转换为相同类型的右值之后，引用情况跟右值是一模一样的。\n\n# 三、右值引用与左值引用的区别\n\n- 1、左值引用绑定到有确定存储空间以及变量名的对象上，表达式结束后对象依然存在；\n\n- 2、右值引用绑定到要求转换的表达式、字面常量、返回右值的表达式等临时对象上，赋值表达式结束后就对象就会被销毁。\n\n- 3、左值引用后可以利用别名修改左值对象；右值引用绑定的值不能修改。\n\n# 四、引入右值引用的原因\n\n- 1、替代需要销毁对象的拷贝，提高效率：某些情况下，需要拷贝一个对象然后将其销毁，如：临时类对象的拷贝就要先将旧内存的资源拷贝到新内存，然后释放旧内存，引入右值引用后，就可以让新对象直接使用旧内存并且销毁原对象，这样就减少了内存和运算资源的使用，从而提高了运行效率；\n\n- 2、移动含有不能共享资源的类对象：像IO、unique_ptr这样的类包含不能被共享的资源（如：IO缓冲、指针），因此，这些类对象不能拷贝但可以移动。这种情况，需要先调用std::move将左值强制转换为右值，再进行右值引用。\n","slug":"C++/左值与右值","published":1,"date":"2023-08-24T14:38:18.643Z","updated":"2022-12-30T03:13:44.834Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0tj000vdkr7drid2fos","content":"<h1 id=\"一、左值与右值\"><a href=\"#一、左值与右值\" class=\"headerlink\" title=\"一、左值与右值\"></a>一、左值与右值</h1><ul>\n<li><p>啥是左值和右值呢？</p>\n<p>左值：在<a href=\"https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020\">内存</a>有确定存储地址、有变量名，表达式结束依然存在的值，简单来说左值就是非临时对象。<br>右值：就是在内存没有确定存储地址、没有变量名，<a href=\"https://so.csdn.net/so/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1001.2101.3001.7020\">表达式</a>结束就会销毁的值，简单来说右值就是临时对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 0;  // 在这条语句中，a 是左值，0 是临时值，就是右值。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>左值可以分为两类：非常量左值和常量左值；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a=10;              \t// a 为非常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\">const int a1=10;      //a1 为常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\">const int a2=20;      //a2 为常量左值（有确定存储地址，也有变量名）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>同理，右值也可以分为两类：非常量右值和常量右值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> int a=10;              \t// 10 为非常量右值</span><br><span class=\"line\">const int a1=10;      </span><br><span class=\"line\">const int a2=20;      </span><br><span class=\"line\">a1+a2               \t// (a1+a2) 为常量右值</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"二、左值引用于右值引用\"><a href=\"#二、左值引用于右值引用\" class=\"headerlink\" title=\"二、左值引用于右值引用\"></a>二、左值引用于右值引用</h1><ul>\n<li><p><strong>知道了左值与右值了，那啥是左值引用与右值引用呢？</strong></p>\n<p>左值引用：其实就是绑定到左值的引用，通过&amp;来获得左值引用。</p>\n<ul>\n<li><p>左值引用举例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a=10;              //非常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\">const int a1=10;       //常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\">const int a2=20;       //常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\"> </span><br><span class=\"line\">//非常量左值引用</span><br><span class=\"line\">int &amp;b1=a;            //正确，a是一个非常量左值，可以被非常量左值引用绑定</span><br><span class=\"line\">int &amp;b2=a1;           //错误,a1是一个常量左值，不可以被非常量左值引用绑定</span><br><span class=\"line\">int &amp;b3=10;           //错误，10是一个非常量右值，不可以被非常量左值引用绑定</span><br><span class=\"line\">int &amp;b4=a1+a2;        //错误,（a1+a2）是一个常量右值，不可以被非常量左值引用绑定</span><br><span class=\"line\"></span><br><span class=\"line\">//常量左值引用</span><br><span class=\"line\">const int &amp;c1=a;      //正确，a是一个非常量左值，可以被非常量右值引用绑定</span><br><span class=\"line\">const int &amp;c2=a1;     //正确,a1是一个常量左值，可以被非常量右值引用绑定</span><br><span class=\"line\">const int &amp;c3=a+a1;   //正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定</span><br><span class=\"line\">const int &amp;c4=a1+a2;  //正确,（a1+a2）是一个常量右值，可以被非常量右值引用绑定</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>总结归纳：非常量左值引用只能绑定到非常量左值上；常量左值引用可以绑定到非常量左值、常量左值、非常量右值、常量右值等所有的值类型。</p>\n</li>\n</ul>\n<p>右值引用：其实也是绑定到右值的引用，通过&amp;&amp;来获得右值引用。</p>\n<ul>\n<li><p>右值引用举例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a=10;             //非常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\">const int a1=20;      //常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\">const int a2=20;      //常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\"></span><br><span class=\"line\">//非常量右值引用</span><br><span class=\"line\">int &amp;&amp;b1=a;            //错误，a是一个非常量左值，不可以被非常量右值引用绑定</span><br><span class=\"line\">int &amp;&amp;b2=a1;           //错误,a1是一个常量左值，不可以被非常量右值引用绑定</span><br><span class=\"line\">int &amp;&amp;b3=10;           //正确，10是一个非常量右值，可以被非常量右值引用绑定</span><br><span class=\"line\">int &amp;&amp;b4=a1+a2;        //错误,（a1+a2）是一个常量右值，不可以被非常量右值引用绑定</span><br><span class=\"line\"></span><br><span class=\"line\">//常量右值引用</span><br><span class=\"line\">const int &amp;&amp;c1=a;      //错误，a是一个非常量左值，不可以被常量右值引用绑定</span><br><span class=\"line\">const int &amp;&amp;c2=a1;     //错误,a1是一个常量左值，不可以被常量右值引用绑定</span><br><span class=\"line\">const int &amp;&amp;c3=a+a1;   //正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定</span><br><span class=\"line\">const int &amp;&amp;c4=a1+a2;  //正确,（a1+a2）是一个常量右值，不可以被常量右值引用绑定</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>总结归纳：非常量右值引用只能绑定到非常量右值上；常量右值引用可以绑定到非常量右值、常量右值上。</p>\n<p><img src=\"/./media/3d9e381b93fe4df790357680b15d4635.png\"></p>\n<p><strong>从上述可以发现，常量左值引用可以绑定到右值上，但右值引用不能绑定任何类型的左值，若想利用右值引用绑定左值该怎么办呢？</strong></p>\n</li>\n</ul>\n</li>\n<li><p>C++11中提供了一个标准库move函数获得绑定到左值上的右值引用，即直接调用std::move告诉编译器将左值像对待同类型右值一样处理，但是被调用后的左值将不能再被使用。</p>\n<ul>\n<li><p><strong>std::move()函数举例</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a=10;                 //非常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\">const int a1=20;          //常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\"></span><br><span class=\"line\">//非常量右值引用</span><br><span class=\"line\">int &amp;&amp;d1=std::move(a);    //正确，将非常量左值a转换为非常量右值，可以被非常量右值引用绑定</span><br><span class=\"line\">int &amp;&amp;d2=std::move(a1);    //错误,将常量左值a1转换为常量右值，不可以被非常量右值引用绑定</span><br><span class=\"line\"></span><br><span class=\"line\">//常量右值引用</span><br><span class=\"line\">const int &amp;&amp;c1=std::move(a);      //正确，将非常量左值a转换为非常量右值，可以被常量右值引用绑定</span><br><span class=\"line\">const int &amp;&amp;c2=std::move(a1);     //正确,将常量左值a1转换为常量右值，可以被常量右值引用绑定</span><br></pre></td></tr></table></figure>\n\n<p>最后可以发现，编译器利用std::move将左值强制转换为相同类型的右值之后，引用情况跟右值是一模一样的。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"三、右值引用与左值引用的区别\"><a href=\"#三、右值引用与左值引用的区别\" class=\"headerlink\" title=\"三、右值引用与左值引用的区别\"></a>三、右值引用与左值引用的区别</h1><ul>\n<li><p>1、左值引用绑定到有确定存储空间以及变量名的对象上，表达式结束后对象依然存在；</p>\n</li>\n<li><p>2、右值引用绑定到要求转换的表达式、字面常量、返回右值的表达式等临时对象上，赋值表达式结束后就对象就会被销毁。</p>\n</li>\n<li><p>3、左值引用后可以利用别名修改左值对象；右值引用绑定的值不能修改。</p>\n</li>\n</ul>\n<h1 id=\"四、引入右值引用的原因\"><a href=\"#四、引入右值引用的原因\" class=\"headerlink\" title=\"四、引入右值引用的原因\"></a>四、引入右值引用的原因</h1><ul>\n<li><p>1、替代需要销毁对象的拷贝，提高效率：某些情况下，需要拷贝一个对象然后将其销毁，如：临时类对象的拷贝就要先将旧内存的资源拷贝到新内存，然后释放旧内存，引入右值引用后，就可以让新对象直接使用旧内存并且销毁原对象，这样就减少了内存和运算资源的使用，从而提高了运行效率；</p>\n</li>\n<li><p>2、移动含有不能共享资源的类对象：像IO、unique_ptr这样的类包含不能被共享的资源（如：IO缓冲、指针），因此，这些类对象不能拷贝但可以移动。这种情况，需要先调用std::move将左值强制转换为右值，再进行右值引用。</p>\n</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-8.png","cover_type":"img","excerpt":"","more":"<h1 id=\"一、左值与右值\"><a href=\"#一、左值与右值\" class=\"headerlink\" title=\"一、左值与右值\"></a>一、左值与右值</h1><ul>\n<li><p>啥是左值和右值呢？</p>\n<p>左值：在<a href=\"https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020\">内存</a>有确定存储地址、有变量名，表达式结束依然存在的值，简单来说左值就是非临时对象。<br>右值：就是在内存没有确定存储地址、没有变量名，<a href=\"https://so.csdn.net/so/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1001.2101.3001.7020\">表达式</a>结束就会销毁的值，简单来说右值就是临时对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 0;  // 在这条语句中，a 是左值，0 是临时值，就是右值。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>左值可以分为两类：非常量左值和常量左值；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a=10;              \t// a 为非常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\">const int a1=10;      //a1 为常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\">const int a2=20;      //a2 为常量左值（有确定存储地址，也有变量名）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>同理，右值也可以分为两类：非常量右值和常量右值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> int a=10;              \t// 10 为非常量右值</span><br><span class=\"line\">const int a1=10;      </span><br><span class=\"line\">const int a2=20;      </span><br><span class=\"line\">a1+a2               \t// (a1+a2) 为常量右值</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"二、左值引用于右值引用\"><a href=\"#二、左值引用于右值引用\" class=\"headerlink\" title=\"二、左值引用于右值引用\"></a>二、左值引用于右值引用</h1><ul>\n<li><p><strong>知道了左值与右值了，那啥是左值引用与右值引用呢？</strong></p>\n<p>左值引用：其实就是绑定到左值的引用，通过&amp;来获得左值引用。</p>\n<ul>\n<li><p>左值引用举例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a=10;              //非常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\">const int a1=10;       //常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\">const int a2=20;       //常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\"> </span><br><span class=\"line\">//非常量左值引用</span><br><span class=\"line\">int &amp;b1=a;            //正确，a是一个非常量左值，可以被非常量左值引用绑定</span><br><span class=\"line\">int &amp;b2=a1;           //错误,a1是一个常量左值，不可以被非常量左值引用绑定</span><br><span class=\"line\">int &amp;b3=10;           //错误，10是一个非常量右值，不可以被非常量左值引用绑定</span><br><span class=\"line\">int &amp;b4=a1+a2;        //错误,（a1+a2）是一个常量右值，不可以被非常量左值引用绑定</span><br><span class=\"line\"></span><br><span class=\"line\">//常量左值引用</span><br><span class=\"line\">const int &amp;c1=a;      //正确，a是一个非常量左值，可以被非常量右值引用绑定</span><br><span class=\"line\">const int &amp;c2=a1;     //正确,a1是一个常量左值，可以被非常量右值引用绑定</span><br><span class=\"line\">const int &amp;c3=a+a1;   //正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定</span><br><span class=\"line\">const int &amp;c4=a1+a2;  //正确,（a1+a2）是一个常量右值，可以被非常量右值引用绑定</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>总结归纳：非常量左值引用只能绑定到非常量左值上；常量左值引用可以绑定到非常量左值、常量左值、非常量右值、常量右值等所有的值类型。</p>\n</li>\n</ul>\n<p>右值引用：其实也是绑定到右值的引用，通过&amp;&amp;来获得右值引用。</p>\n<ul>\n<li><p>右值引用举例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a=10;             //非常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\">const int a1=20;      //常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\">const int a2=20;      //常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\"></span><br><span class=\"line\">//非常量右值引用</span><br><span class=\"line\">int &amp;&amp;b1=a;            //错误，a是一个非常量左值，不可以被非常量右值引用绑定</span><br><span class=\"line\">int &amp;&amp;b2=a1;           //错误,a1是一个常量左值，不可以被非常量右值引用绑定</span><br><span class=\"line\">int &amp;&amp;b3=10;           //正确，10是一个非常量右值，可以被非常量右值引用绑定</span><br><span class=\"line\">int &amp;&amp;b4=a1+a2;        //错误,（a1+a2）是一个常量右值，不可以被非常量右值引用绑定</span><br><span class=\"line\"></span><br><span class=\"line\">//常量右值引用</span><br><span class=\"line\">const int &amp;&amp;c1=a;      //错误，a是一个非常量左值，不可以被常量右值引用绑定</span><br><span class=\"line\">const int &amp;&amp;c2=a1;     //错误,a1是一个常量左值，不可以被常量右值引用绑定</span><br><span class=\"line\">const int &amp;&amp;c3=a+a1;   //正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定</span><br><span class=\"line\">const int &amp;&amp;c4=a1+a2;  //正确,（a1+a2）是一个常量右值，不可以被常量右值引用绑定</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>总结归纳：非常量右值引用只能绑定到非常量右值上；常量右值引用可以绑定到非常量右值、常量右值上。</p>\n<p><img src=\"/./media/3d9e381b93fe4df790357680b15d4635.png\"></p>\n<p><strong>从上述可以发现，常量左值引用可以绑定到右值上，但右值引用不能绑定任何类型的左值，若想利用右值引用绑定左值该怎么办呢？</strong></p>\n</li>\n</ul>\n</li>\n<li><p>C++11中提供了一个标准库move函数获得绑定到左值上的右值引用，即直接调用std::move告诉编译器将左值像对待同类型右值一样处理，但是被调用后的左值将不能再被使用。</p>\n<ul>\n<li><p><strong>std::move()函数举例</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a=10;                 //非常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\">const int a1=20;          //常量左值（有确定存储地址，也有变量名）</span><br><span class=\"line\"></span><br><span class=\"line\">//非常量右值引用</span><br><span class=\"line\">int &amp;&amp;d1=std::move(a);    //正确，将非常量左值a转换为非常量右值，可以被非常量右值引用绑定</span><br><span class=\"line\">int &amp;&amp;d2=std::move(a1);    //错误,将常量左值a1转换为常量右值，不可以被非常量右值引用绑定</span><br><span class=\"line\"></span><br><span class=\"line\">//常量右值引用</span><br><span class=\"line\">const int &amp;&amp;c1=std::move(a);      //正确，将非常量左值a转换为非常量右值，可以被常量右值引用绑定</span><br><span class=\"line\">const int &amp;&amp;c2=std::move(a1);     //正确,将常量左值a1转换为常量右值，可以被常量右值引用绑定</span><br></pre></td></tr></table></figure>\n\n<p>最后可以发现，编译器利用std::move将左值强制转换为相同类型的右值之后，引用情况跟右值是一模一样的。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"三、右值引用与左值引用的区别\"><a href=\"#三、右值引用与左值引用的区别\" class=\"headerlink\" title=\"三、右值引用与左值引用的区别\"></a>三、右值引用与左值引用的区别</h1><ul>\n<li><p>1、左值引用绑定到有确定存储空间以及变量名的对象上，表达式结束后对象依然存在；</p>\n</li>\n<li><p>2、右值引用绑定到要求转换的表达式、字面常量、返回右值的表达式等临时对象上，赋值表达式结束后就对象就会被销毁。</p>\n</li>\n<li><p>3、左值引用后可以利用别名修改左值对象；右值引用绑定的值不能修改。</p>\n</li>\n</ul>\n<h1 id=\"四、引入右值引用的原因\"><a href=\"#四、引入右值引用的原因\" class=\"headerlink\" title=\"四、引入右值引用的原因\"></a>四、引入右值引用的原因</h1><ul>\n<li><p>1、替代需要销毁对象的拷贝，提高效率：某些情况下，需要拷贝一个对象然后将其销毁，如：临时类对象的拷贝就要先将旧内存的资源拷贝到新内存，然后释放旧内存，引入右值引用后，就可以让新对象直接使用旧内存并且销毁原对象，这样就减少了内存和运算资源的使用，从而提高了运行效率；</p>\n</li>\n<li><p>2、移动含有不能共享资源的类对象：像IO、unique_ptr这样的类包含不能被共享的资源（如：IO缓冲、指针），因此，这些类对象不能拷贝但可以移动。这种情况，需要先调用std::move将左值强制转换为右值，再进行右值引用。</p>\n</li>\n</ul>\n"},{"_content":"# 常用函数\n\n- ## **swap（）：**\n\n  **@brief：**用于元素的交换\n\n  ```\n  swap(a, b)\n  ```\n\n  \n\n- ## **substr（）:**\n\n  **形式 ：** s.substr(pos, len)\n\n  **返回值：** string，包含s中从pos开始的len个字符的拷贝（pos的默认值是0，len的默认值是s.size() - pos，即不加参数会默认拷贝整个s）\n\n  substr有2种常用用法：\n\n  假设：string s = “0123456789”;\n\n  ```\n  string sub1 = s.substr(5); //只有一个数字5表示从下标为5开始一直到结尾：sub1 = “56789”\n  \n  string sub2 = s.substr(5, 3); //从下标为5开始截取长度为3位：sub2 = “567”\n  ```\n\n  \n\n- ## **compare():**\n\n  **@brief：**两个字符串相同，返回0。\n\n  ​\t\t\t\t调用字符串小与被调用字符串，返回-1。\n\n  ​\t\t\t\t调用字符串大于被调用字符串，返回1。\n\n  ```\n  int compare(const string &s) const;\n  \n  int conpare(const char *s) const;\n  ```\n\n  ![1  2  3  4  5  6  7  8  9  le  11  12  13  14  15  16  17  18  19  2e  21  22  23  using namespace std;  int main()  string  string ;  int b=sl. 14+2 ,  cout\\<\\<b\\<\\<endl;  int c=sl.  cout\\<\\<c\\<\\<endl;  int d=sl.  ; //sl +\\*Öando\\$LJs2  string s3=\"abc\";  string s4=\"abc\";  int  cout\\<\\<e\\<\\<endl;  return e; ](media/a5f23af609c2c0cc2c6cfe51f1ca22f0.png)\n\n  \n\n-   ## **reverse():**\n\n    **@brief：**reverse函数用于反转 [ first , last ）范围内的顺序\n\n    ![string a = ihello\";  string b •world';  a.end());  b.end()); ](media/899e5f1f4f1d4a5651454501e4b6a19c.png)\n\n- ## round():\n\n  **@brief：**round()函数仅仅保留到整数位，即仅仅对小数点后一位四舍五入\n\n  ```c++\n  round(1.5) = 2.000000\n  round(1.56) = 2.000000\n  round(-1.5) = -2.000000\n  round(-1.56) = -2.000000\n  ```\n\n- ## std::numeric_limits：\n\n  **@brief：**提供关于不同平台编译的算术类型(整型、[浮点型](https://so.csdn.net/so/search?q=浮点型&spm=1001.2101.3001.7020))的属性信息，如int型的最大最小值，位宽等信息。 因此该模板素有成员函\t\t\t\t数、成员变量均为静态函数\n\n  ```c++\n  #include <iostream>     // std::cout\n  #include <limits>       // std::numeric_limits\n  \n  int main () {\n    std::cout << std::boolalpha;\n    std::cout << \"Minimum value for int: \" << std::numeric_limits<int>::min() << '\\n';\n    std::cout << \"Maximum value for int: \" << std::numeric_limits<int>::max() << '\\n';\n    std::cout << \"int is signed: \" << std::numeric_limits<int>::is_signed << '\\n';\n    std::cout << \"Non-sign bits in int: \" << std::numeric_limits<int>::digits << '\\n';\n    std::cout << \"int has infinity: \" << std::numeric_limits<int>::has_infinity << '\\n';\n    return 0;\n  }\n  ```\n\n  ","source":"_posts/C++/常用函数.md","raw":"# 常用函数\n\n- ## **swap（）：**\n\n  **@brief：**用于元素的交换\n\n  ```\n  swap(a, b)\n  ```\n\n  \n\n- ## **substr（）:**\n\n  **形式 ：** s.substr(pos, len)\n\n  **返回值：** string，包含s中从pos开始的len个字符的拷贝（pos的默认值是0，len的默认值是s.size() - pos，即不加参数会默认拷贝整个s）\n\n  substr有2种常用用法：\n\n  假设：string s = “0123456789”;\n\n  ```\n  string sub1 = s.substr(5); //只有一个数字5表示从下标为5开始一直到结尾：sub1 = “56789”\n  \n  string sub2 = s.substr(5, 3); //从下标为5开始截取长度为3位：sub2 = “567”\n  ```\n\n  \n\n- ## **compare():**\n\n  **@brief：**两个字符串相同，返回0。\n\n  ​\t\t\t\t调用字符串小与被调用字符串，返回-1。\n\n  ​\t\t\t\t调用字符串大于被调用字符串，返回1。\n\n  ```\n  int compare(const string &s) const;\n  \n  int conpare(const char *s) const;\n  ```\n\n  ![1  2  3  4  5  6  7  8  9  le  11  12  13  14  15  16  17  18  19  2e  21  22  23  using namespace std;  int main()  string  string ;  int b=sl. 14+2 ,  cout\\<\\<b\\<\\<endl;  int c=sl.  cout\\<\\<c\\<\\<endl;  int d=sl.  ; //sl +\\*Öando\\$LJs2  string s3=\"abc\";  string s4=\"abc\";  int  cout\\<\\<e\\<\\<endl;  return e; ](media/a5f23af609c2c0cc2c6cfe51f1ca22f0.png)\n\n  \n\n-   ## **reverse():**\n\n    **@brief：**reverse函数用于反转 [ first , last ）范围内的顺序\n\n    ![string a = ihello\";  string b •world';  a.end());  b.end()); ](media/899e5f1f4f1d4a5651454501e4b6a19c.png)\n\n- ## round():\n\n  **@brief：**round()函数仅仅保留到整数位，即仅仅对小数点后一位四舍五入\n\n  ```c++\n  round(1.5) = 2.000000\n  round(1.56) = 2.000000\n  round(-1.5) = -2.000000\n  round(-1.56) = -2.000000\n  ```\n\n- ## std::numeric_limits：\n\n  **@brief：**提供关于不同平台编译的算术类型(整型、[浮点型](https://so.csdn.net/so/search?q=浮点型&spm=1001.2101.3001.7020))的属性信息，如int型的最大最小值，位宽等信息。 因此该模板素有成员函\t\t\t\t数、成员变量均为静态函数\n\n  ```c++\n  #include <iostream>     // std::cout\n  #include <limits>       // std::numeric_limits\n  \n  int main () {\n    std::cout << std::boolalpha;\n    std::cout << \"Minimum value for int: \" << std::numeric_limits<int>::min() << '\\n';\n    std::cout << \"Maximum value for int: \" << std::numeric_limits<int>::max() << '\\n';\n    std::cout << \"int is signed: \" << std::numeric_limits<int>::is_signed << '\\n';\n    std::cout << \"Non-sign bits in int: \" << std::numeric_limits<int>::digits << '\\n';\n    std::cout << \"int has infinity: \" << std::numeric_limits<int>::has_infinity << '\\n';\n    return 0;\n  }\n  ```\n\n  ","slug":"C++/常用函数","published":1,"date":"2023-08-24T14:38:18.645Z","updated":"2022-12-30T03:13:44.834Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0tj000wdkr77xux5kg8","content":"<h1 id=\"常用函数\"><a href=\"#常用函数\" class=\"headerlink\" title=\"常用函数\"></a>常用函数</h1><ul>\n<li><h2 id=\"swap（）：\"><a href=\"#swap（）：\" class=\"headerlink\" title=\"swap（）：\"></a><strong>swap（）：</strong></h2><p><strong>@brief：</strong>用于元素的交换</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swap(a, b)</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><h2 id=\"substr（）\"><a href=\"#substr（）\" class=\"headerlink\" title=\"substr（）:\"></a><strong>substr（）:</strong></h2><p><strong>形式 ：</strong> s.substr(pos, len)</p>\n<p><strong>返回值：</strong> string，包含s中从pos开始的len个字符的拷贝（pos的默认值是0，len的默认值是s.size() - pos，即不加参数会默认拷贝整个s）</p>\n<p>substr有2种常用用法：</p>\n<p>假设：string s &#x3D; “0123456789”;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string sub1 = s.substr(5); //只有一个数字5表示从下标为5开始一直到结尾：sub1 = “56789”</span><br><span class=\"line\"></span><br><span class=\"line\">string sub2 = s.substr(5, 3); //从下标为5开始截取长度为3位：sub2 = “567”</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><h2 id=\"compare\"><a href=\"#compare\" class=\"headerlink\" title=\"compare():\"></a><strong>compare():</strong></h2><p><strong>@brief：</strong>两个字符串相同，返回0。</p>\n<p>​\t\t\t\t调用字符串小与被调用字符串，返回-1。</p>\n<p>​\t\t\t\t调用字符串大于被调用字符串，返回1。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int compare(const string &amp;s) const;</span><br><span class=\"line\"></span><br><span class=\"line\">int conpare(const char *s) const;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/media/a5f23af609c2c0cc2c6cfe51f1ca22f0.png\" alt=\"1  2  3  4  5  6  7  8  9  le  11  12  13  14  15  16  17  18  19  2e  21  22  23  using namespace std;  int main()  string  string ;  int b=sl. 14+2 ,  cout\\&lt;\\&lt;b\\&lt;\\&lt;endl;  int c=sl.  cout\\&lt;\\&lt;c\\&lt;\\&lt;endl;  int d=sl.  ; //sl +\\*Öando\\$LJs2  string s3=&quot;abc&quot;;  string s4=&quot;abc&quot;;  int  cout\\&lt;\\&lt;e\\&lt;\\&lt;endl;  return e; \"></p>\n</li>\n<li><h2 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse():\"></a><strong>reverse():</strong></h2><p><strong>@brief：</strong>reverse函数用于反转 [ first , last ）范围内的顺序</p>\n<p><img src=\"/media/899e5f1f4f1d4a5651454501e4b6a19c.png\" alt=\"string a = ihello&quot;;  string b •world&#39;;  a.end());  b.end()); \"></p>\n</li>\n<li><h2 id=\"round\"><a href=\"#round\" class=\"headerlink\" title=\"round():\"></a>round():</h2><p><strong>@brief：</strong>round()函数仅仅保留到整数位，即仅仅对小数点后一位四舍五入</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">round</span>(<span class=\"number\">1.5</span>) = <span class=\"number\">2.000000</span></span><br><span class=\"line\"><span class=\"built_in\">round</span>(<span class=\"number\">1.56</span>) = <span class=\"number\">2.000000</span></span><br><span class=\"line\"><span class=\"built_in\">round</span>(<span class=\"number\">-1.5</span>) = <span class=\"number\">-2.000000</span></span><br><span class=\"line\"><span class=\"built_in\">round</span>(<span class=\"number\">-1.56</span>) = <span class=\"number\">-2.000000</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><h2 id=\"std-numeric-limits：\"><a href=\"#std-numeric-limits：\" class=\"headerlink\" title=\"std::numeric_limits：\"></a>std::numeric_limits：</h2><p><strong>@brief：</strong>提供关于不同平台编译的算术类型(整型、<a href=\"https://so.csdn.net/so/search?q=%E6%B5%AE%E7%82%B9%E5%9E%8B&spm=1001.2101.3001.7020\">浮点型</a>)的属性信息，如int型的最大最小值，位宽等信息。 因此该模板素有成员函\t\t\t\t数、成员变量均为静态函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>     <span class=\"comment\">// std::cout</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;limits&gt;</span>       <span class=\"comment\">// std::numeric_limits</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  std::cout &lt;&lt; std::boolalpha;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">&quot;Minimum value for int: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class=\"type\">int</span>&gt;::<span class=\"built_in\">min</span>() &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">&quot;Maximum value for int: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class=\"type\">int</span>&gt;::<span class=\"built_in\">max</span>() &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">&quot;int is signed: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class=\"type\">int</span>&gt;::is_signed &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">&quot;Non-sign bits in int: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class=\"type\">int</span>&gt;::digits &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">&quot;int has infinity: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class=\"type\">int</span>&gt;::has_infinity &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-7.png","cover_type":"img","excerpt":"","more":"<h1 id=\"常用函数\"><a href=\"#常用函数\" class=\"headerlink\" title=\"常用函数\"></a>常用函数</h1><ul>\n<li><h2 id=\"swap（）：\"><a href=\"#swap（）：\" class=\"headerlink\" title=\"swap（）：\"></a><strong>swap（）：</strong></h2><p><strong>@brief：</strong>用于元素的交换</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swap(a, b)</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><h2 id=\"substr（）\"><a href=\"#substr（）\" class=\"headerlink\" title=\"substr（）:\"></a><strong>substr（）:</strong></h2><p><strong>形式 ：</strong> s.substr(pos, len)</p>\n<p><strong>返回值：</strong> string，包含s中从pos开始的len个字符的拷贝（pos的默认值是0，len的默认值是s.size() - pos，即不加参数会默认拷贝整个s）</p>\n<p>substr有2种常用用法：</p>\n<p>假设：string s &#x3D; “0123456789”;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string sub1 = s.substr(5); //只有一个数字5表示从下标为5开始一直到结尾：sub1 = “56789”</span><br><span class=\"line\"></span><br><span class=\"line\">string sub2 = s.substr(5, 3); //从下标为5开始截取长度为3位：sub2 = “567”</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><h2 id=\"compare\"><a href=\"#compare\" class=\"headerlink\" title=\"compare():\"></a><strong>compare():</strong></h2><p><strong>@brief：</strong>两个字符串相同，返回0。</p>\n<p>​\t\t\t\t调用字符串小与被调用字符串，返回-1。</p>\n<p>​\t\t\t\t调用字符串大于被调用字符串，返回1。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int compare(const string &amp;s) const;</span><br><span class=\"line\"></span><br><span class=\"line\">int conpare(const char *s) const;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/media/a5f23af609c2c0cc2c6cfe51f1ca22f0.png\" alt=\"1  2  3  4  5  6  7  8  9  le  11  12  13  14  15  16  17  18  19  2e  21  22  23  using namespace std;  int main()  string  string ;  int b=sl. 14+2 ,  cout\\&lt;\\&lt;b\\&lt;\\&lt;endl;  int c=sl.  cout\\&lt;\\&lt;c\\&lt;\\&lt;endl;  int d=sl.  ; //sl +\\*Öando\\$LJs2  string s3=&quot;abc&quot;;  string s4=&quot;abc&quot;;  int  cout\\&lt;\\&lt;e\\&lt;\\&lt;endl;  return e; \"></p>\n</li>\n<li><h2 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse():\"></a><strong>reverse():</strong></h2><p><strong>@brief：</strong>reverse函数用于反转 [ first , last ）范围内的顺序</p>\n<p><img src=\"/media/899e5f1f4f1d4a5651454501e4b6a19c.png\" alt=\"string a = ihello&quot;;  string b •world&#39;;  a.end());  b.end()); \"></p>\n</li>\n<li><h2 id=\"round\"><a href=\"#round\" class=\"headerlink\" title=\"round():\"></a>round():</h2><p><strong>@brief：</strong>round()函数仅仅保留到整数位，即仅仅对小数点后一位四舍五入</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">round</span>(<span class=\"number\">1.5</span>) = <span class=\"number\">2.000000</span></span><br><span class=\"line\"><span class=\"built_in\">round</span>(<span class=\"number\">1.56</span>) = <span class=\"number\">2.000000</span></span><br><span class=\"line\"><span class=\"built_in\">round</span>(<span class=\"number\">-1.5</span>) = <span class=\"number\">-2.000000</span></span><br><span class=\"line\"><span class=\"built_in\">round</span>(<span class=\"number\">-1.56</span>) = <span class=\"number\">-2.000000</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><h2 id=\"std-numeric-limits：\"><a href=\"#std-numeric-limits：\" class=\"headerlink\" title=\"std::numeric_limits：\"></a>std::numeric_limits：</h2><p><strong>@brief：</strong>提供关于不同平台编译的算术类型(整型、<a href=\"https://so.csdn.net/so/search?q=%E6%B5%AE%E7%82%B9%E5%9E%8B&spm=1001.2101.3001.7020\">浮点型</a>)的属性信息，如int型的最大最小值，位宽等信息。 因此该模板素有成员函\t\t\t\t数、成员变量均为静态函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span>     <span class=\"comment\">// std::cout</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;limits&gt;</span>       <span class=\"comment\">// std::numeric_limits</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  std::cout &lt;&lt; std::boolalpha;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">&quot;Minimum value for int: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class=\"type\">int</span>&gt;::<span class=\"built_in\">min</span>() &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">&quot;Maximum value for int: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class=\"type\">int</span>&gt;::<span class=\"built_in\">max</span>() &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">&quot;int is signed: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class=\"type\">int</span>&gt;::is_signed &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">&quot;Non-sign bits in int: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class=\"type\">int</span>&gt;::digits &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">&quot;int has infinity: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class=\"type\">int</span>&gt;::has_infinity &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"_content":"# 二叉树遍历\n\n2022年1月17日\n\n13:47\n\n![D  c  D  c  c  D  c  void recursion (BinaryNode \\* node)  if (node NULL)  return;  recursion (node-\\> IChi 1 d)  cout node-\\>data endl ,  recursion (node-\\>rChi 1 d)  DLR  (tR)BiBD  LDR  LRDe  DLR  LDR  LRD  — EJ\\*Ü, ](media/90765ad142ae9c04739fde85d776f281.png)\n","source":"_posts/C++/二叉树遍历.md","raw":"# 二叉树遍历\n\n2022年1月17日\n\n13:47\n\n![D  c  D  c  c  D  c  void recursion (BinaryNode \\* node)  if (node NULL)  return;  recursion (node-\\> IChi 1 d)  cout node-\\>data endl ,  recursion (node-\\>rChi 1 d)  DLR  (tR)BiBD  LDR  LRDe  DLR  LDR  LRD  — EJ\\*Ü, ](media/90765ad142ae9c04739fde85d776f281.png)\n","slug":"C++/二叉树遍历","published":1,"date":"2023-08-24T14:38:18.639Z","updated":"2022-12-30T03:13:44.834Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0tj000xdkr7dfcxe9e2","content":"<h1 id=\"二叉树遍历\"><a href=\"#二叉树遍历\" class=\"headerlink\" title=\"二叉树遍历\"></a>二叉树遍历</h1><p>2022年1月17日</p>\n<p>13:47</p>\n<p><img src=\"/media/90765ad142ae9c04739fde85d776f281.png\" alt=\"D  c  D  c  c  D  c  void recursion (BinaryNode \\* node)  if (node NULL)  return;  recursion (node-\\&gt; IChi 1 d)  cout node-\\&gt;data endl ,  recursion (node-\\&gt;rChi 1 d)  DLR  (tR)BiBD  LDR  LRDe  DLR  LDR  LRD  — EJ\\*Ü, \"></p>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-1.png","cover_type":"img","excerpt":"","more":"<h1 id=\"二叉树遍历\"><a href=\"#二叉树遍历\" class=\"headerlink\" title=\"二叉树遍历\"></a>二叉树遍历</h1><p>2022年1月17日</p>\n<p>13:47</p>\n<p><img src=\"/media/90765ad142ae9c04739fde85d776f281.png\" alt=\"D  c  D  c  c  D  c  void recursion (BinaryNode \\* node)  if (node NULL)  return;  recursion (node-\\&gt; IChi 1 d)  cout node-\\&gt;data endl ,  recursion (node-\\&gt;rChi 1 d)  DLR  (tR)BiBD  LDR  LRDe  DLR  LDR  LRD  — EJ\\*Ü, \"></p>\n"},{"_content":"# 数据类型字节数\n\n\n\n![](media/b5d733fac8312c1270eb8bc87d58c555.png)\n\n1个字节 = 8位  n表示位\n\n整数有符号取值范围：[-2^(n-1), 2^(n-1) -1]\n\n整数无符号取值范围：[0, 2^n -1]\n\n```\n一、整型(int、short、long、long long)\n1、有符号整型\n有符号整型的数据类型通常包括 int、short、long、long long 四种，因为是有符号类型，所以前面要加上 signed ，但是通常省略，也就是说在代码中直接打出 int 类型就代表是有符号类型的。\n\n（1）int类型\n数据类型大小是 4 字节，能表示的数值范围是\n-2^(32-1) – 2^(32-1)-1 （即 -2147483648 ~ 2147483647）\n打印类型是 %d ，使用格式为 int 名 = 值;\n\n（2）short类型\n数据类型大小是 2 字节，能表示的数值范围是\n-2^(16-1) – 2^(16-1) -1 （即 -32768 ~ 32767）\n打印类型是 %hd ，使用格式为 short 名 = 值;\n\n（3）long类型\n数据类型大小是 4 字节，能表示的数值范围是\n-2^(32-1) – 2^(32-1)-1 （即 -2147483648 ~ 2147483647）\n打印类型是 %ld ，使用格式为 long 名 = 值;\n\n（4）long long类型\n数据类型大小是 8 字节，能表示的数值范围是\n-2^(64-1) ~ 2^(64-1)-1\n\n打印类型是 %lld ，使用格式为 long long 名 = 值;\n\n2、无符号整型\n无符号数用 unsigned 表示 ，只表示数据量，而没有方向（没有正负，且无符号数最高位不是符号位，而就是数的一部分，无符号数不可能是负数。\n\n（1）unsigned int 类型\n数据类型大小是 4 字节，能表示的数值范围是\n0 – 2^(32）-1 （即 0~4294967295）\n打印类型是 %u ，使用格式为 unsigned int 名 = 值;\n\n（2）unsigned short 类型\n数据类型大小是 2 字节，能表示的数值范围是\n0 ~ 2^16 -1 （即 0~65535）\n打印类型是 %hu ，使用格式为 unsigned short 名 = 值;\n\n（3）unsigned long 类型\n数据类型大小是 4 字节，能表示的数值范围是\n0 – 2^(32）-1 （即 0~4294967295）\n打印类型是 %lu ，使用格式为 unsigned long 名 = 值;\n\n（4）unsigned long long 类型\n数据类型大小是 8 字节，能表示的数值范围是\n0~2^64-1\n打印类型是 %llu ，使用格式为 unsigned long long 名 = 值;\n```\n\n","source":"_posts/C++/数据类型字节数.md","raw":"# 数据类型字节数\n\n\n\n![](media/b5d733fac8312c1270eb8bc87d58c555.png)\n\n1个字节 = 8位  n表示位\n\n整数有符号取值范围：[-2^(n-1), 2^(n-1) -1]\n\n整数无符号取值范围：[0, 2^n -1]\n\n```\n一、整型(int、short、long、long long)\n1、有符号整型\n有符号整型的数据类型通常包括 int、short、long、long long 四种，因为是有符号类型，所以前面要加上 signed ，但是通常省略，也就是说在代码中直接打出 int 类型就代表是有符号类型的。\n\n（1）int类型\n数据类型大小是 4 字节，能表示的数值范围是\n-2^(32-1) – 2^(32-1)-1 （即 -2147483648 ~ 2147483647）\n打印类型是 %d ，使用格式为 int 名 = 值;\n\n（2）short类型\n数据类型大小是 2 字节，能表示的数值范围是\n-2^(16-1) – 2^(16-1) -1 （即 -32768 ~ 32767）\n打印类型是 %hd ，使用格式为 short 名 = 值;\n\n（3）long类型\n数据类型大小是 4 字节，能表示的数值范围是\n-2^(32-1) – 2^(32-1)-1 （即 -2147483648 ~ 2147483647）\n打印类型是 %ld ，使用格式为 long 名 = 值;\n\n（4）long long类型\n数据类型大小是 8 字节，能表示的数值范围是\n-2^(64-1) ~ 2^(64-1)-1\n\n打印类型是 %lld ，使用格式为 long long 名 = 值;\n\n2、无符号整型\n无符号数用 unsigned 表示 ，只表示数据量，而没有方向（没有正负，且无符号数最高位不是符号位，而就是数的一部分，无符号数不可能是负数。\n\n（1）unsigned int 类型\n数据类型大小是 4 字节，能表示的数值范围是\n0 – 2^(32）-1 （即 0~4294967295）\n打印类型是 %u ，使用格式为 unsigned int 名 = 值;\n\n（2）unsigned short 类型\n数据类型大小是 2 字节，能表示的数值范围是\n0 ~ 2^16 -1 （即 0~65535）\n打印类型是 %hu ，使用格式为 unsigned short 名 = 值;\n\n（3）unsigned long 类型\n数据类型大小是 4 字节，能表示的数值范围是\n0 – 2^(32）-1 （即 0~4294967295）\n打印类型是 %lu ，使用格式为 unsigned long 名 = 值;\n\n（4）unsigned long long 类型\n数据类型大小是 8 字节，能表示的数值范围是\n0~2^64-1\n打印类型是 %llu ，使用格式为 unsigned long long 名 = 值;\n```\n\n","slug":"C++/数据类型字节数","published":1,"date":"2023-08-24T14:38:18.648Z","updated":"2023-01-17T04:02:36.198Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0tk000ydkr77s6getrk","content":"<h1 id=\"数据类型字节数\"><a href=\"#数据类型字节数\" class=\"headerlink\" title=\"数据类型字节数\"></a>数据类型字节数</h1><p><img src=\"/media/b5d733fac8312c1270eb8bc87d58c555.png\"></p>\n<p>1个字节 &#x3D; 8位  n表示位</p>\n<p>整数有符号取值范围：[-2^(n-1), 2^(n-1) -1]</p>\n<p>整数无符号取值范围：[0, 2^n -1]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一、整型(int、short、long、long long)</span><br><span class=\"line\">1、有符号整型</span><br><span class=\"line\">有符号整型的数据类型通常包括 int、short、long、long long 四种，因为是有符号类型，所以前面要加上 signed ，但是通常省略，也就是说在代码中直接打出 int 类型就代表是有符号类型的。</span><br><span class=\"line\"></span><br><span class=\"line\">（1）int类型</span><br><span class=\"line\">数据类型大小是 4 字节，能表示的数值范围是</span><br><span class=\"line\">-2^(32-1) – 2^(32-1)-1 （即 -2147483648 ~ 2147483647）</span><br><span class=\"line\">打印类型是 %d ，使用格式为 int 名 = 值;</span><br><span class=\"line\"></span><br><span class=\"line\">（2）short类型</span><br><span class=\"line\">数据类型大小是 2 字节，能表示的数值范围是</span><br><span class=\"line\">-2^(16-1) – 2^(16-1) -1 （即 -32768 ~ 32767）</span><br><span class=\"line\">打印类型是 %hd ，使用格式为 short 名 = 值;</span><br><span class=\"line\"></span><br><span class=\"line\">（3）long类型</span><br><span class=\"line\">数据类型大小是 4 字节，能表示的数值范围是</span><br><span class=\"line\">-2^(32-1) – 2^(32-1)-1 （即 -2147483648 ~ 2147483647）</span><br><span class=\"line\">打印类型是 %ld ，使用格式为 long 名 = 值;</span><br><span class=\"line\"></span><br><span class=\"line\">（4）long long类型</span><br><span class=\"line\">数据类型大小是 8 字节，能表示的数值范围是</span><br><span class=\"line\">-2^(64-1) ~ 2^(64-1)-1</span><br><span class=\"line\"></span><br><span class=\"line\">打印类型是 %lld ，使用格式为 long long 名 = 值;</span><br><span class=\"line\"></span><br><span class=\"line\">2、无符号整型</span><br><span class=\"line\">无符号数用 unsigned 表示 ，只表示数据量，而没有方向（没有正负，且无符号数最高位不是符号位，而就是数的一部分，无符号数不可能是负数。</span><br><span class=\"line\"></span><br><span class=\"line\">（1）unsigned int 类型</span><br><span class=\"line\">数据类型大小是 4 字节，能表示的数值范围是</span><br><span class=\"line\">0 – 2^(32）-1 （即 0~4294967295）</span><br><span class=\"line\">打印类型是 %u ，使用格式为 unsigned int 名 = 值;</span><br><span class=\"line\"></span><br><span class=\"line\">（2）unsigned short 类型</span><br><span class=\"line\">数据类型大小是 2 字节，能表示的数值范围是</span><br><span class=\"line\">0 ~ 2^16 -1 （即 0~65535）</span><br><span class=\"line\">打印类型是 %hu ，使用格式为 unsigned short 名 = 值;</span><br><span class=\"line\"></span><br><span class=\"line\">（3）unsigned long 类型</span><br><span class=\"line\">数据类型大小是 4 字节，能表示的数值范围是</span><br><span class=\"line\">0 – 2^(32）-1 （即 0~4294967295）</span><br><span class=\"line\">打印类型是 %lu ，使用格式为 unsigned long 名 = 值;</span><br><span class=\"line\"></span><br><span class=\"line\">（4）unsigned long long 类型</span><br><span class=\"line\">数据类型大小是 8 字节，能表示的数值范围是</span><br><span class=\"line\">0~2^64-1</span><br><span class=\"line\">打印类型是 %llu ，使用格式为 unsigned long long 名 = 值;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-5.png","cover_type":"img","excerpt":"","more":"<h1 id=\"数据类型字节数\"><a href=\"#数据类型字节数\" class=\"headerlink\" title=\"数据类型字节数\"></a>数据类型字节数</h1><p><img src=\"/media/b5d733fac8312c1270eb8bc87d58c555.png\"></p>\n<p>1个字节 &#x3D; 8位  n表示位</p>\n<p>整数有符号取值范围：[-2^(n-1), 2^(n-1) -1]</p>\n<p>整数无符号取值范围：[0, 2^n -1]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一、整型(int、short、long、long long)</span><br><span class=\"line\">1、有符号整型</span><br><span class=\"line\">有符号整型的数据类型通常包括 int、short、long、long long 四种，因为是有符号类型，所以前面要加上 signed ，但是通常省略，也就是说在代码中直接打出 int 类型就代表是有符号类型的。</span><br><span class=\"line\"></span><br><span class=\"line\">（1）int类型</span><br><span class=\"line\">数据类型大小是 4 字节，能表示的数值范围是</span><br><span class=\"line\">-2^(32-1) – 2^(32-1)-1 （即 -2147483648 ~ 2147483647）</span><br><span class=\"line\">打印类型是 %d ，使用格式为 int 名 = 值;</span><br><span class=\"line\"></span><br><span class=\"line\">（2）short类型</span><br><span class=\"line\">数据类型大小是 2 字节，能表示的数值范围是</span><br><span class=\"line\">-2^(16-1) – 2^(16-1) -1 （即 -32768 ~ 32767）</span><br><span class=\"line\">打印类型是 %hd ，使用格式为 short 名 = 值;</span><br><span class=\"line\"></span><br><span class=\"line\">（3）long类型</span><br><span class=\"line\">数据类型大小是 4 字节，能表示的数值范围是</span><br><span class=\"line\">-2^(32-1) – 2^(32-1)-1 （即 -2147483648 ~ 2147483647）</span><br><span class=\"line\">打印类型是 %ld ，使用格式为 long 名 = 值;</span><br><span class=\"line\"></span><br><span class=\"line\">（4）long long类型</span><br><span class=\"line\">数据类型大小是 8 字节，能表示的数值范围是</span><br><span class=\"line\">-2^(64-1) ~ 2^(64-1)-1</span><br><span class=\"line\"></span><br><span class=\"line\">打印类型是 %lld ，使用格式为 long long 名 = 值;</span><br><span class=\"line\"></span><br><span class=\"line\">2、无符号整型</span><br><span class=\"line\">无符号数用 unsigned 表示 ，只表示数据量，而没有方向（没有正负，且无符号数最高位不是符号位，而就是数的一部分，无符号数不可能是负数。</span><br><span class=\"line\"></span><br><span class=\"line\">（1）unsigned int 类型</span><br><span class=\"line\">数据类型大小是 4 字节，能表示的数值范围是</span><br><span class=\"line\">0 – 2^(32）-1 （即 0~4294967295）</span><br><span class=\"line\">打印类型是 %u ，使用格式为 unsigned int 名 = 值;</span><br><span class=\"line\"></span><br><span class=\"line\">（2）unsigned short 类型</span><br><span class=\"line\">数据类型大小是 2 字节，能表示的数值范围是</span><br><span class=\"line\">0 ~ 2^16 -1 （即 0~65535）</span><br><span class=\"line\">打印类型是 %hu ，使用格式为 unsigned short 名 = 值;</span><br><span class=\"line\"></span><br><span class=\"line\">（3）unsigned long 类型</span><br><span class=\"line\">数据类型大小是 4 字节，能表示的数值范围是</span><br><span class=\"line\">0 – 2^(32）-1 （即 0~4294967295）</span><br><span class=\"line\">打印类型是 %lu ，使用格式为 unsigned long 名 = 值;</span><br><span class=\"line\"></span><br><span class=\"line\">（4）unsigned long long 类型</span><br><span class=\"line\">数据类型大小是 8 字节，能表示的数值范围是</span><br><span class=\"line\">0~2^64-1</span><br><span class=\"line\">打印类型是 %llu ，使用格式为 unsigned long long 名 = 值;</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"# 单例模式\n\n\n\n## 1.构造函数私有化\n\n![- class  ChairMan  public:  static  ChairMar1 \\* getlnstacne  return singleMan,  private:  Chairman  b) 01  Chai rM const ChairMan  // public:  private:  static  ChairMart  \\* singleMan,  thairMar1  Chairman • :singleMan -  Chairman  new ](media/82e528c1d8aeb1e85113f6a7d826cdfd.png)\n\n## 2.\n\n![ChairMan \\* cl = Chairhan: •.åetlnstacne()  Chairlan \\* c2 = Chairhan: ; ](media/f700387f242b93abd4799aae4384a23a.png)\n","source":"_posts/C++/单例模式.md","raw":"# 单例模式\n\n\n\n## 1.构造函数私有化\n\n![- class  ChairMan  public:  static  ChairMar1 \\* getlnstacne  return singleMan,  private:  Chairman  b) 01  Chai rM const ChairMan  // public:  private:  static  ChairMart  \\* singleMan,  thairMar1  Chairman • :singleMan -  Chairman  new ](media/82e528c1d8aeb1e85113f6a7d826cdfd.png)\n\n## 2.\n\n![ChairMan \\* cl = Chairhan: •.åetlnstacne()  Chairlan \\* c2 = Chairhan: ; ](media/f700387f242b93abd4799aae4384a23a.png)\n","slug":"C++/单例模式","published":1,"date":"2023-08-24T14:38:18.642Z","updated":"2022-12-30T03:13:44.834Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0tk000zdkr70qqx0paq","content":"<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><h2 id=\"1-构造函数私有化\"><a href=\"#1-构造函数私有化\" class=\"headerlink\" title=\"1.构造函数私有化\"></a>1.构造函数私有化</h2><p><img src=\"/media/82e528c1d8aeb1e85113f6a7d826cdfd.png\" alt=\"- class  ChairMan  public:  static  ChairMar1 \\* getlnstacne  return singleMan,  private:  Chairman  b) 01  Chai rM const ChairMan  // public:  private:  static  ChairMart  \\* singleMan,  thairMar1  Chairman • :singleMan -  Chairman  new \"></p>\n<h2 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h2><p><img src=\"/media/f700387f242b93abd4799aae4384a23a.png\" alt=\"ChairMan \\* cl = Chairhan: •.åetlnstacne()  Chairlan \\* c2 = Chairhan: ; \"></p>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-5.png","cover_type":"img","excerpt":"","more":"<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><h2 id=\"1-构造函数私有化\"><a href=\"#1-构造函数私有化\" class=\"headerlink\" title=\"1.构造函数私有化\"></a>1.构造函数私有化</h2><p><img src=\"/media/82e528c1d8aeb1e85113f6a7d826cdfd.png\" alt=\"- class  ChairMan  public:  static  ChairMar1 \\* getlnstacne  return singleMan,  private:  Chairman  b) 01  Chai rM const ChairMan  // public:  private:  static  ChairMart  \\* singleMan,  thairMar1  Chairman • :singleMan -  Chairman  new \"></p>\n<h2 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h2><p><img src=\"/media/f700387f242b93abd4799aae4384a23a.png\" alt=\"ChairMan \\* cl = Chairhan: •.åetlnstacne()  Chairlan \\* c2 = Chairhan: ; \"></p>\n"},{"_content":"# 构造函数的调用时机\n\n```c++\n//1. 无参构造调用方式\nvoid test01(){\n    \n    //调用无参构造函数\n    Person person1; \n    person1.PrintPerson();\n \n    //无参构造函数错误调用方式\n    //Person person2();\n    //person2.PrintPerson();\n}\n//2. 调用有参构造函数\nvoid test02(){\n    \n    //第一种 括号法，最常用\n    Person person01(100);\n    person01.PrintPerson();\n \n    //调用拷贝构造函数\n    Person person02(person01);\n    person02.PrintPerson();\n \n    //第二种 匿名对象(显示调用构造函数)\n    Person(200); //匿名对象，没有名字的对象\n \n    Person person03 = Person(300);\n    person03.PrintPerson();\n \n    //注意: 使用匿名对象初始化判断调用哪一个构造函数，要看匿名对象的参数类型\n    Person person06(Person(400)); //等价于 Person person06 = Person(400);\n    person06.PrintPerson();\n \n    //第三种 =号法 隐式转换\n    Person person04 = 100; //Person person04 =  Person(100)\n    person04.PrintPerson();\n \n    //调用拷贝构造\n    Person person05 = person04; //Person person05 =  Person(person04)\n    person05.PrintPerson();\n}\n\n```\n\n\n","source":"_posts/C++/构造函数的调用时机.md","raw":"# 构造函数的调用时机\n\n```c++\n//1. 无参构造调用方式\nvoid test01(){\n    \n    //调用无参构造函数\n    Person person1; \n    person1.PrintPerson();\n \n    //无参构造函数错误调用方式\n    //Person person2();\n    //person2.PrintPerson();\n}\n//2. 调用有参构造函数\nvoid test02(){\n    \n    //第一种 括号法，最常用\n    Person person01(100);\n    person01.PrintPerson();\n \n    //调用拷贝构造函数\n    Person person02(person01);\n    person02.PrintPerson();\n \n    //第二种 匿名对象(显示调用构造函数)\n    Person(200); //匿名对象，没有名字的对象\n \n    Person person03 = Person(300);\n    person03.PrintPerson();\n \n    //注意: 使用匿名对象初始化判断调用哪一个构造函数，要看匿名对象的参数类型\n    Person person06(Person(400)); //等价于 Person person06 = Person(400);\n    person06.PrintPerson();\n \n    //第三种 =号法 隐式转换\n    Person person04 = 100; //Person person04 =  Person(100)\n    person04.PrintPerson();\n \n    //调用拷贝构造\n    Person person05 = person04; //Person person05 =  Person(person04)\n    person05.PrintPerson();\n}\n\n```\n\n\n","slug":"C++/构造函数的调用时机","published":1,"date":"2023-08-24T14:38:18.650Z","updated":"2022-12-30T03:13:44.834Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0tk0010dkr79e4e75lw","content":"<h1 id=\"构造函数的调用时机\"><a href=\"#构造函数的调用时机\" class=\"headerlink\" title=\"构造函数的调用时机\"></a>构造函数的调用时机</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. 无参构造调用方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//调用无参构造函数</span></span><br><span class=\"line\">    Person person1; </span><br><span class=\"line\">    person1.<span class=\"built_in\">PrintPerson</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//无参构造函数错误调用方式</span></span><br><span class=\"line\">    <span class=\"comment\">//Person person2();</span></span><br><span class=\"line\">    <span class=\"comment\">//person2.PrintPerson();</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2. 调用有参构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//第一种 括号法，最常用</span></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">person01</span><span class=\"params\">(<span class=\"number\">100</span>)</span></span>;</span><br><span class=\"line\">    person01.<span class=\"built_in\">PrintPerson</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//调用拷贝构造函数</span></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">person02</span><span class=\"params\">(person01)</span></span>;</span><br><span class=\"line\">    person02.<span class=\"built_in\">PrintPerson</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//第二种 匿名对象(显示调用构造函数)</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"number\">200</span>); <span class=\"comment\">//匿名对象，没有名字的对象</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    Person person03 = <span class=\"built_in\">Person</span>(<span class=\"number\">300</span>);</span><br><span class=\"line\">    person03.<span class=\"built_in\">PrintPerson</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//注意: 使用匿名对象初始化判断调用哪一个构造函数，要看匿名对象的参数类型</span></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">person06</span><span class=\"params\">(Person(<span class=\"number\">400</span>))</span></span>; <span class=\"comment\">//等价于 Person person06 = Person(400);</span></span><br><span class=\"line\">    person06.<span class=\"built_in\">PrintPerson</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//第三种 =号法 隐式转换</span></span><br><span class=\"line\">    Person person04 = <span class=\"number\">100</span>; <span class=\"comment\">//Person person04 =  Person(100)</span></span><br><span class=\"line\">    person04.<span class=\"built_in\">PrintPerson</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//调用拷贝构造</span></span><br><span class=\"line\">    Person person05 = person04; <span class=\"comment\">//Person person05 =  Person(person04)</span></span><br><span class=\"line\">    person05.<span class=\"built_in\">PrintPerson</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-6.png","cover_type":"img","excerpt":"","more":"<h1 id=\"构造函数的调用时机\"><a href=\"#构造函数的调用时机\" class=\"headerlink\" title=\"构造函数的调用时机\"></a>构造函数的调用时机</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. 无参构造调用方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test01</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//调用无参构造函数</span></span><br><span class=\"line\">    Person person1; </span><br><span class=\"line\">    person1.<span class=\"built_in\">PrintPerson</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//无参构造函数错误调用方式</span></span><br><span class=\"line\">    <span class=\"comment\">//Person person2();</span></span><br><span class=\"line\">    <span class=\"comment\">//person2.PrintPerson();</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2. 调用有参构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test02</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//第一种 括号法，最常用</span></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">person01</span><span class=\"params\">(<span class=\"number\">100</span>)</span></span>;</span><br><span class=\"line\">    person01.<span class=\"built_in\">PrintPerson</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//调用拷贝构造函数</span></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">person02</span><span class=\"params\">(person01)</span></span>;</span><br><span class=\"line\">    person02.<span class=\"built_in\">PrintPerson</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//第二种 匿名对象(显示调用构造函数)</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"number\">200</span>); <span class=\"comment\">//匿名对象，没有名字的对象</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    Person person03 = <span class=\"built_in\">Person</span>(<span class=\"number\">300</span>);</span><br><span class=\"line\">    person03.<span class=\"built_in\">PrintPerson</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//注意: 使用匿名对象初始化判断调用哪一个构造函数，要看匿名对象的参数类型</span></span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">person06</span><span class=\"params\">(Person(<span class=\"number\">400</span>))</span></span>; <span class=\"comment\">//等价于 Person person06 = Person(400);</span></span><br><span class=\"line\">    person06.<span class=\"built_in\">PrintPerson</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//第三种 =号法 隐式转换</span></span><br><span class=\"line\">    Person person04 = <span class=\"number\">100</span>; <span class=\"comment\">//Person person04 =  Person(100)</span></span><br><span class=\"line\">    person04.<span class=\"built_in\">PrintPerson</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//调用拷贝构造</span></span><br><span class=\"line\">    Person person05 = person04; <span class=\"comment\">//Person person05 =  Person(person04)</span></span><br><span class=\"line\">    person05.<span class=\"built_in\">PrintPerson</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"_content":"# CMakeLists简易模板\n\n```cmake\ncmake_minimum_required(VERSION 2.8)\nPROJECT(ndt_mapping)\n\n#dboost\nadd_definitions(-DBOOST_ERROR_CODE_HEADER_ONLY)\n\nfind_package(OpenCV 4.5.2 QUIET)\nif(NOT OpenCV_FOUND)\n    find_package(OpenCV 2.4.3 QUIET)\n    if(NOT OpenCV_FOUND)\n        message(FATAL_ERROR \"OpenCV > 2.4.3 not found.\")\n    endif()\nendif()\n\nfind_package(Eigen3 3.1.0 REQUIRED NO_MODULE)\nfind_package(PCL REQUIRED)\n\ninclude_directories(\n        ${PROJECT_SOURCE_DIR}\n        ${PROJECT_SOURCE_DIR}/src\n        ${OpenCV_INCLUDE_DIRS}\n        #eigen库只包含头文件\n        #${EIGEN3_INCLUDE_DIR}\n        ${PCL_INCLUDE_DIRS}\n)\n\nadd_library(async_buffer SHARED\n        src/async_buffer.cc\n        src/async_buffer.h)\n\ntarget_link_libraries(async_buffer\n        ${OpenCV_LIBRARIES}\n        ${PCL_LIBRARIES}\n        #gflags可以直接链接\n        gflags)\n\nadd_executable(ndt_mapping src/ndt_mapping.cc)\ntarget_link_libraries(ndt_mapping async_buffer)\n\n#设置了CMake变量OpenCV_DIR为OpenCV库的配置文件所在路径，正是通过载入这个路径下的OpenCVConfig.cmake配置文件才能配置好OpenCV库，\n#然后在OpenCVConfig.cmake配置文件中定义了变量OpenCV_INCLUDE_DIRS为OpenCV库头文件包含路径，这样我们才能才在代码中\n#使用#include <opencv2/opencv.hpp>而不会出现编译错误，同时定义了变量OpenCV_LIBS为OpenCV链接库路径，这样我们才能正确链接到\n#OpenCV中的库文件，而不会出现类似未定义的引用这样的链接错误。\nmessage(STATUS \"OpenCV_DIR = ${OpenCV_DIR}\")\nmessage(STATUS \"OpenCV_INCLUDE_DIRS = ${OpenCV_INCLUDE_DIRS}\")\nmessage(STATUS \"OpenCV_LIBS = ${OpenCV_LIBS}\")\nmessage(STATUS \"OpenCV_LIBRARIES = ${OpenCV_LIBRARIES}\")\n\nmessage(STATUS \"PCL_DIR = ${PCL_DIR}\")\nmessage(STATUS \"Gflags_DIR = ${Gflags_DIR}\")\n```","source":"_posts/C++/CMakeLists简易模板.md","raw":"# CMakeLists简易模板\n\n```cmake\ncmake_minimum_required(VERSION 2.8)\nPROJECT(ndt_mapping)\n\n#dboost\nadd_definitions(-DBOOST_ERROR_CODE_HEADER_ONLY)\n\nfind_package(OpenCV 4.5.2 QUIET)\nif(NOT OpenCV_FOUND)\n    find_package(OpenCV 2.4.3 QUIET)\n    if(NOT OpenCV_FOUND)\n        message(FATAL_ERROR \"OpenCV > 2.4.3 not found.\")\n    endif()\nendif()\n\nfind_package(Eigen3 3.1.0 REQUIRED NO_MODULE)\nfind_package(PCL REQUIRED)\n\ninclude_directories(\n        ${PROJECT_SOURCE_DIR}\n        ${PROJECT_SOURCE_DIR}/src\n        ${OpenCV_INCLUDE_DIRS}\n        #eigen库只包含头文件\n        #${EIGEN3_INCLUDE_DIR}\n        ${PCL_INCLUDE_DIRS}\n)\n\nadd_library(async_buffer SHARED\n        src/async_buffer.cc\n        src/async_buffer.h)\n\ntarget_link_libraries(async_buffer\n        ${OpenCV_LIBRARIES}\n        ${PCL_LIBRARIES}\n        #gflags可以直接链接\n        gflags)\n\nadd_executable(ndt_mapping src/ndt_mapping.cc)\ntarget_link_libraries(ndt_mapping async_buffer)\n\n#设置了CMake变量OpenCV_DIR为OpenCV库的配置文件所在路径，正是通过载入这个路径下的OpenCVConfig.cmake配置文件才能配置好OpenCV库，\n#然后在OpenCVConfig.cmake配置文件中定义了变量OpenCV_INCLUDE_DIRS为OpenCV库头文件包含路径，这样我们才能才在代码中\n#使用#include <opencv2/opencv.hpp>而不会出现编译错误，同时定义了变量OpenCV_LIBS为OpenCV链接库路径，这样我们才能正确链接到\n#OpenCV中的库文件，而不会出现类似未定义的引用这样的链接错误。\nmessage(STATUS \"OpenCV_DIR = ${OpenCV_DIR}\")\nmessage(STATUS \"OpenCV_INCLUDE_DIRS = ${OpenCV_INCLUDE_DIRS}\")\nmessage(STATUS \"OpenCV_LIBS = ${OpenCV_LIBS}\")\nmessage(STATUS \"OpenCV_LIBRARIES = ${OpenCV_LIBRARIES}\")\n\nmessage(STATUS \"PCL_DIR = ${PCL_DIR}\")\nmessage(STATUS \"Gflags_DIR = ${Gflags_DIR}\")\n```","slug":"C++/CMakeLists简易模板","published":1,"date":"2023-08-24T14:38:18.614Z","updated":"2022-12-30T03:13:44.814Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0tk0011dkr74m1baut4","content":"<h1 id=\"CMakeLists简易模板\"><a href=\"#CMakeLists简易模板\" class=\"headerlink\" title=\"CMakeLists简易模板\"></a>CMakeLists简易模板</h1><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">cmake_minimum_required</span>(VERSION <span class=\"number\">2.8</span>)</span><br><span class=\"line\"><span class=\"keyword\">PROJECT</span>(ndt_mapping)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#dboost</span></span><br><span class=\"line\"><span class=\"keyword\">add_definitions</span>(-DBOOST_ERROR_CODE_HEADER_ONLY)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">find_package</span>(OpenCV <span class=\"number\">4.5</span>.<span class=\"number\">2</span> QUIET)</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">NOT</span> OpenCV_FOUND)</span><br><span class=\"line\">    <span class=\"keyword\">find_package</span>(OpenCV <span class=\"number\">2.4</span>.<span class=\"number\">3</span> QUIET)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">NOT</span> OpenCV_FOUND)</span><br><span class=\"line\">        <span class=\"keyword\">message</span>(FATAL_ERROR <span class=\"string\">&quot;OpenCV &gt; 2.4.3 not found.&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">endif</span>()</span><br><span class=\"line\"><span class=\"keyword\">endif</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">find_package</span>(Eigen3 <span class=\"number\">3.1</span>.<span class=\"number\">0</span> REQUIRED NO_MODULE)</span><br><span class=\"line\"><span class=\"keyword\">find_package</span>(PCL REQUIRED)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">include_directories</span>(</span><br><span class=\"line\">        <span class=\"variable\">$&#123;PROJECT_SOURCE_DIR&#125;</span></span><br><span class=\"line\">        <span class=\"variable\">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src</span><br><span class=\"line\">        <span class=\"variable\">$&#123;OpenCV_INCLUDE_DIRS&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">#eigen库只包含头文件</span></span><br><span class=\"line\">        <span class=\"comment\">#$&#123;EIGEN3_INCLUDE_DIR&#125;</span></span><br><span class=\"line\">        <span class=\"variable\">$&#123;PCL_INCLUDE_DIRS&#125;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">add_library</span>(async_buffer SHARED</span><br><span class=\"line\">        src/async_buffer.cc</span><br><span class=\"line\">        src/async_buffer.h)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">target_link_libraries</span>(async_buffer</span><br><span class=\"line\">        <span class=\"variable\">$&#123;OpenCV_LIBRARIES&#125;</span></span><br><span class=\"line\">        <span class=\"variable\">$&#123;PCL_LIBRARIES&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">#gflags可以直接链接</span></span><br><span class=\"line\">        gflags)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(ndt_mapping src/ndt_mapping.cc)</span><br><span class=\"line\"><span class=\"keyword\">target_link_libraries</span>(ndt_mapping async_buffer)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#设置了CMake变量OpenCV_DIR为OpenCV库的配置文件所在路径，正是通过载入这个路径下的OpenCVConfig.cmake配置文件才能配置好OpenCV库，</span></span><br><span class=\"line\"><span class=\"comment\">#然后在OpenCVConfig.cmake配置文件中定义了变量OpenCV_INCLUDE_DIRS为OpenCV库头文件包含路径，这样我们才能才在代码中</span></span><br><span class=\"line\"><span class=\"comment\">#使用#include &lt;opencv2/opencv.hpp&gt;而不会出现编译错误，同时定义了变量OpenCV_LIBS为OpenCV链接库路径，这样我们才能正确链接到</span></span><br><span class=\"line\"><span class=\"comment\">#OpenCV中的库文件，而不会出现类似未定义的引用这样的链接错误。</span></span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;OpenCV_DIR = $&#123;OpenCV_DIR&#125;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;OpenCV_INCLUDE_DIRS = $&#123;OpenCV_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;OpenCV_LIBS = $&#123;OpenCV_LIBS&#125;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;OpenCV_LIBRARIES = $&#123;OpenCV_LIBRARIES&#125;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;PCL_DIR = $&#123;PCL_DIR&#125;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;Gflags_DIR = $&#123;Gflags_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-8.png","cover_type":"img","excerpt":"","more":"<h1 id=\"CMakeLists简易模板\"><a href=\"#CMakeLists简易模板\" class=\"headerlink\" title=\"CMakeLists简易模板\"></a>CMakeLists简易模板</h1><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">cmake_minimum_required</span>(VERSION <span class=\"number\">2.8</span>)</span><br><span class=\"line\"><span class=\"keyword\">PROJECT</span>(ndt_mapping)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#dboost</span></span><br><span class=\"line\"><span class=\"keyword\">add_definitions</span>(-DBOOST_ERROR_CODE_HEADER_ONLY)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">find_package</span>(OpenCV <span class=\"number\">4.5</span>.<span class=\"number\">2</span> QUIET)</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">NOT</span> OpenCV_FOUND)</span><br><span class=\"line\">    <span class=\"keyword\">find_package</span>(OpenCV <span class=\"number\">2.4</span>.<span class=\"number\">3</span> QUIET)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">NOT</span> OpenCV_FOUND)</span><br><span class=\"line\">        <span class=\"keyword\">message</span>(FATAL_ERROR <span class=\"string\">&quot;OpenCV &gt; 2.4.3 not found.&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">endif</span>()</span><br><span class=\"line\"><span class=\"keyword\">endif</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">find_package</span>(Eigen3 <span class=\"number\">3.1</span>.<span class=\"number\">0</span> REQUIRED NO_MODULE)</span><br><span class=\"line\"><span class=\"keyword\">find_package</span>(PCL REQUIRED)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">include_directories</span>(</span><br><span class=\"line\">        <span class=\"variable\">$&#123;PROJECT_SOURCE_DIR&#125;</span></span><br><span class=\"line\">        <span class=\"variable\">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src</span><br><span class=\"line\">        <span class=\"variable\">$&#123;OpenCV_INCLUDE_DIRS&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">#eigen库只包含头文件</span></span><br><span class=\"line\">        <span class=\"comment\">#$&#123;EIGEN3_INCLUDE_DIR&#125;</span></span><br><span class=\"line\">        <span class=\"variable\">$&#123;PCL_INCLUDE_DIRS&#125;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">add_library</span>(async_buffer SHARED</span><br><span class=\"line\">        src/async_buffer.cc</span><br><span class=\"line\">        src/async_buffer.h)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">target_link_libraries</span>(async_buffer</span><br><span class=\"line\">        <span class=\"variable\">$&#123;OpenCV_LIBRARIES&#125;</span></span><br><span class=\"line\">        <span class=\"variable\">$&#123;PCL_LIBRARIES&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">#gflags可以直接链接</span></span><br><span class=\"line\">        gflags)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(ndt_mapping src/ndt_mapping.cc)</span><br><span class=\"line\"><span class=\"keyword\">target_link_libraries</span>(ndt_mapping async_buffer)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#设置了CMake变量OpenCV_DIR为OpenCV库的配置文件所在路径，正是通过载入这个路径下的OpenCVConfig.cmake配置文件才能配置好OpenCV库，</span></span><br><span class=\"line\"><span class=\"comment\">#然后在OpenCVConfig.cmake配置文件中定义了变量OpenCV_INCLUDE_DIRS为OpenCV库头文件包含路径，这样我们才能才在代码中</span></span><br><span class=\"line\"><span class=\"comment\">#使用#include &lt;opencv2/opencv.hpp&gt;而不会出现编译错误，同时定义了变量OpenCV_LIBS为OpenCV链接库路径，这样我们才能正确链接到</span></span><br><span class=\"line\"><span class=\"comment\">#OpenCV中的库文件，而不会出现类似未定义的引用这样的链接错误。</span></span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;OpenCV_DIR = $&#123;OpenCV_DIR&#125;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;OpenCV_INCLUDE_DIRS = $&#123;OpenCV_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;OpenCV_LIBS = $&#123;OpenCV_LIBS&#125;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;OpenCV_LIBRARIES = $&#123;OpenCV_LIBRARIES&#125;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;PCL_DIR = $&#123;PCL_DIR&#125;&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(STATUS <span class=\"string\">&quot;Gflags_DIR = $&#123;Gflags_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>"},{"_content":"# 计算时间\n\n```c++\n#include<chrono>\nstd::chrono::steady_clock::time_point t1 = std::chrono::steady_clock::now();\nstd::chrono::steady_clock::time_point t2 = std::chrono::steady_clock::now();\ndouble ttrack = std::chrono::duration_cast< std::chrono::duration<double>>(t2-t1).count();\n```\n\n\n","source":"_posts/C++/计算时间.md","raw":"# 计算时间\n\n```c++\n#include<chrono>\nstd::chrono::steady_clock::time_point t1 = std::chrono::steady_clock::now();\nstd::chrono::steady_clock::time_point t2 = std::chrono::steady_clock::now();\ndouble ttrack = std::chrono::duration_cast< std::chrono::duration<double>>(t2-t1).count();\n```\n\n\n","slug":"C++/计算时间","published":1,"date":"2023-08-24T14:38:18.653Z","updated":"2022-12-30T03:13:44.835Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0tk0012dkr72mof7ccm","content":"<h1 id=\"计算时间\"><a href=\"#计算时间\" class=\"headerlink\" title=\"计算时间\"></a>计算时间</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\">std::chrono::steady_clock::time_point t1 = std::chrono::steady_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">std::chrono::steady_clock::time_point t2 = std::chrono::steady_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\"><span class=\"type\">double</span> ttrack = std::chrono::duration_cast&lt; std::chrono::duration&lt;<span class=\"type\">double</span>&gt;&gt;(t2-t1).<span class=\"built_in\">count</span>();</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-6.png","cover_type":"img","excerpt":"","more":"<h1 id=\"计算时间\"><a href=\"#计算时间\" class=\"headerlink\" title=\"计算时间\"></a>计算时间</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\">std::chrono::steady_clock::time_point t1 = std::chrono::steady_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">std::chrono::steady_clock::time_point t2 = std::chrono::steady_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\"><span class=\"type\">double</span> ttrack = std::chrono::duration_cast&lt; std::chrono::duration&lt;<span class=\"type\">double</span>&gt;&gt;(t2-t1).<span class=\"built_in\">count</span>();</span><br></pre></td></tr></table></figure>\n\n\n"},{"_content":"# 常规函数与内联函数\n\n\n\n常规函数调用将程序流程转到独立的函数就行运行\n\n\n\n内敛函数用相应的代码段替换函数调用，因此内联函数运行较快，但是更加占用内存\n","source":"_posts/C++/常规函数与内联函数.md","raw":"# 常规函数与内联函数\n\n\n\n常规函数调用将程序流程转到独立的函数就行运行\n\n\n\n内敛函数用相应的代码段替换函数调用，因此内联函数运行较快，但是更加占用内存\n","slug":"C++/常规函数与内联函数","published":1,"date":"2023-08-24T14:38:18.646Z","updated":"2022-12-30T03:13:44.834Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0tl0013dkr7d54vfs0y","content":"<h1 id=\"常规函数与内联函数\"><a href=\"#常规函数与内联函数\" class=\"headerlink\" title=\"常规函数与内联函数\"></a>常规函数与内联函数</h1><p>常规函数调用将程序流程转到独立的函数就行运行</p>\n<p>内敛函数用相应的代码段替换函数调用，因此内联函数运行较快，但是更加占用内存</p>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-8.png","cover_type":"img","excerpt":"","more":"<h1 id=\"常规函数与内联函数\"><a href=\"#常规函数与内联函数\" class=\"headerlink\" title=\"常规函数与内联函数\"></a>常规函数与内联函数</h1><p>常规函数调用将程序流程转到独立的函数就行运行</p>\n<p>内敛函数用相应的代码段替换函数调用，因此内联函数运行较快，但是更加占用内存</p>\n"},{"_content":"# 转换\n\n## int to string \n\n```c++\nstring = to_string(int a)\n```\n\n\n\n## string to char\n\n```c++\n*.c_str()\n```\n\n\n\n## char\\* to double \n\n```c++\nstd::atof()\n```\n\n","source":"_posts/C++/转换.md","raw":"# 转换\n\n## int to string \n\n```c++\nstring = to_string(int a)\n```\n\n\n\n## string to char\n\n```c++\n*.c_str()\n```\n\n\n\n## char\\* to double \n\n```c++\nstd::atof()\n```\n\n","slug":"C++/转换","published":1,"date":"2023-08-24T14:38:18.654Z","updated":"2022-12-30T03:13:44.835Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0tl0014dkr71c7xffka","content":"<h1 id=\"转换\"><a href=\"#转换\" class=\"headerlink\" title=\"转换\"></a>转换</h1><h2 id=\"int-to-string\"><a href=\"#int-to-string\" class=\"headerlink\" title=\"int to string\"></a>int to string</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = <span class=\"built_in\">to_string</span>(<span class=\"type\">int</span> a)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"string-to-char\"><a href=\"#string-to-char\" class=\"headerlink\" title=\"string to char\"></a>string to char</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*.<span class=\"built_in\">c_str</span>()</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"char-to-double\"><a href=\"#char-to-double\" class=\"headerlink\" title=\"char* to double\"></a>char* to double</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::<span class=\"built_in\">atof</span>()</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-1.png","cover_type":"img","excerpt":"","more":"<h1 id=\"转换\"><a href=\"#转换\" class=\"headerlink\" title=\"转换\"></a>转换</h1><h2 id=\"int-to-string\"><a href=\"#int-to-string\" class=\"headerlink\" title=\"int to string\"></a>int to string</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string = <span class=\"built_in\">to_string</span>(<span class=\"type\">int</span> a)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"string-to-char\"><a href=\"#string-to-char\" class=\"headerlink\" title=\"string to char\"></a>string to char</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*.<span class=\"built_in\">c_str</span>()</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"char-to-double\"><a href=\"#char-to-double\" class=\"headerlink\" title=\"char* to double\"></a>char* to double</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::<span class=\"built_in\">atof</span>()</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"# 类知识点\n\n1. 类声明描述如何分配内存，但是并不分配内存\n\n   \n\n2. 对于静态成员函数，在类外进行初始化\n\n   \n\n3. 构造函数用于创建对象\n\n   \n\n4. 函数返回对象时会调用拷贝构造函数\n\n   \n\n5. 一个类的所有对象共享一组类方法\n\n   \n\n6. 继承类可以重新定义在父类中的函数，并且使用虚函数语法时，可以使用父类指针或者引用指向继承类对象，会根据指向的对象类型来选择函数方法，如果不使用虚函数，则只会根据引用或者指针类型选择函数方法，这样就会造成冲突。也就是使用了动态联编，而后者则是静态联编。\n\n   \n\n7. 最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时使用基类方法使派生类能够访问基类数据。\n\n   \n\n8. 包含动态内存分配时（new delete）要考虑深浅拷贝问题！默认复制构造函数对于动态内存分配来说是不合适的，容易造成内存的泄露。\n\n   \n\n9. 一般使用对象作为函数参数时，应该按照引用传递而不是值传递，这样是为了提高效率，按值传递对象涉及到生成临时拷贝。返回对象与返回引用与参数时情况相似。\n\n   \n\n10. 使用explicit来防止单参数构造函数的隐式转换，使用const方法防止修改数据\n\n    ```\n    class t(int a);\n    t = 10; 存在隐式转换\n    ```\n\n    \n\n11. 派生类的成员可以直接访问基类的保护成员，但是不能直接访问基类的私有成员","source":"_posts/C++/类知识点.md","raw":"# 类知识点\n\n1. 类声明描述如何分配内存，但是并不分配内存\n\n   \n\n2. 对于静态成员函数，在类外进行初始化\n\n   \n\n3. 构造函数用于创建对象\n\n   \n\n4. 函数返回对象时会调用拷贝构造函数\n\n   \n\n5. 一个类的所有对象共享一组类方法\n\n   \n\n6. 继承类可以重新定义在父类中的函数，并且使用虚函数语法时，可以使用父类指针或者引用指向继承类对象，会根据指向的对象类型来选择函数方法，如果不使用虚函数，则只会根据引用或者指针类型选择函数方法，这样就会造成冲突。也就是使用了动态联编，而后者则是静态联编。\n\n   \n\n7. 最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时使用基类方法使派生类能够访问基类数据。\n\n   \n\n8. 包含动态内存分配时（new delete）要考虑深浅拷贝问题！默认复制构造函数对于动态内存分配来说是不合适的，容易造成内存的泄露。\n\n   \n\n9. 一般使用对象作为函数参数时，应该按照引用传递而不是值传递，这样是为了提高效率，按值传递对象涉及到生成临时拷贝。返回对象与返回引用与参数时情况相似。\n\n   \n\n10. 使用explicit来防止单参数构造函数的隐式转换，使用const方法防止修改数据\n\n    ```\n    class t(int a);\n    t = 10; 存在隐式转换\n    ```\n\n    \n\n11. 派生类的成员可以直接访问基类的保护成员，但是不能直接访问基类的私有成员","slug":"C++/类知识点","published":1,"date":"2023-08-24T14:38:18.652Z","updated":"2022-12-30T03:13:44.835Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cllq8n0tl0015dkr7fm8m5llp","content":"<h1 id=\"类知识点\"><a href=\"#类知识点\" class=\"headerlink\" title=\"类知识点\"></a>类知识点</h1><ol>\n<li><p>类声明描述如何分配内存，但是并不分配内存</p>\n</li>\n<li><p>对于静态成员函数，在类外进行初始化</p>\n</li>\n<li><p>构造函数用于创建对象</p>\n</li>\n<li><p>函数返回对象时会调用拷贝构造函数</p>\n</li>\n<li><p>一个类的所有对象共享一组类方法</p>\n</li>\n<li><p>继承类可以重新定义在父类中的函数，并且使用虚函数语法时，可以使用父类指针或者引用指向继承类对象，会根据指向的对象类型来选择函数方法，如果不使用虚函数，则只会根据引用或者指针类型选择函数方法，这样就会造成冲突。也就是使用了动态联编，而后者则是静态联编。</p>\n</li>\n<li><p>最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时使用基类方法使派生类能够访问基类数据。</p>\n</li>\n<li><p>包含动态内存分配时（new delete）要考虑深浅拷贝问题！默认复制构造函数对于动态内存分配来说是不合适的，容易造成内存的泄露。</p>\n</li>\n<li><p>一般使用对象作为函数参数时，应该按照引用传递而不是值传递，这样是为了提高效率，按值传递对象涉及到生成临时拷贝。返回对象与返回引用与参数时情况相似。</p>\n</li>\n<li><p>使用explicit来防止单参数构造函数的隐式转换，使用const方法防止修改数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class t(int a);</span><br><span class=\"line\">t = 10; 存在隐式转换</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>派生类的成员可以直接访问基类的保护成员，但是不能直接访问基类的私有成员</p>\n</li>\n</ol>\n","site":{"data":{"link":[{"class_name":"��������","class_desc":"��Щ�ˣ���Щ��","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"���١�����ǿ�����־���"}]},{"class_name":"��վ","class_desc":"ֵ���Ƽ�����վ","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"��Ƶ��վ"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"�й�����罻����ƽ̨"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"�罻����ƽ̨"}]}]}},"cover":"/img/material-7.png","cover_type":"img","excerpt":"","more":"<h1 id=\"类知识点\"><a href=\"#类知识点\" class=\"headerlink\" title=\"类知识点\"></a>类知识点</h1><ol>\n<li><p>类声明描述如何分配内存，但是并不分配内存</p>\n</li>\n<li><p>对于静态成员函数，在类外进行初始化</p>\n</li>\n<li><p>构造函数用于创建对象</p>\n</li>\n<li><p>函数返回对象时会调用拷贝构造函数</p>\n</li>\n<li><p>一个类的所有对象共享一组类方法</p>\n</li>\n<li><p>继承类可以重新定义在父类中的函数，并且使用虚函数语法时，可以使用父类指针或者引用指向继承类对象，会根据指向的对象类型来选择函数方法，如果不使用虚函数，则只会根据引用或者指针类型选择函数方法，这样就会造成冲突。也就是使用了动态联编，而后者则是静态联编。</p>\n</li>\n<li><p>最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时使用基类方法使派生类能够访问基类数据。</p>\n</li>\n<li><p>包含动态内存分配时（new delete）要考虑深浅拷贝问题！默认复制构造函数对于动态内存分配来说是不合适的，容易造成内存的泄露。</p>\n</li>\n<li><p>一般使用对象作为函数参数时，应该按照引用传递而不是值传递，这样是为了提高效率，按值传递对象涉及到生成临时拷贝。返回对象与返回引用与参数时情况相似。</p>\n</li>\n<li><p>使用explicit来防止单参数构造函数的隐式转换，使用const方法防止修改数据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class t(int a);</span><br><span class=\"line\">t = 10; 存在隐式转换</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>派生类的成员可以直接访问基类的保护成员，但是不能直接访问基类的私有成员</p>\n</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cllq8n0t70005dkr76miz71pm","category_id":"cllq8n0t90008dkr786iz7mq6","_id":"cllq8n0td000idkr76otfhy4j"},{"post_id":"cllq8n0td000kdkr777gkdmr5","category_id":"cllq8n0t90008dkr786iz7mq6","_id":"cllq8n0te000pdkr7ari9bdhf"}],"PostTag":[{"post_id":"cllq8n0t70005dkr76miz71pm","tag_id":"cllq8n0ta0009dkr7bo8ggshw","_id":"cllq8n0tc000fdkr72e9g1i1i"},{"post_id":"cllq8n0td000kdkr777gkdmr5","tag_id":"cllq8n0ta0009dkr7bo8ggshw","_id":"cllq8n0te000mdkr7f371au8e"}],"Tag":[{"name":"C++","_id":"cllq8n0ta0009dkr7bo8ggshw"}]}}