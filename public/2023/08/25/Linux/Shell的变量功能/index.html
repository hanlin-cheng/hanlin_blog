<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Shell的变量功能 | HanLin</title><meta name="author" content="Hanlin,cheng.lv@slamtec.com"><meta name="copyright" content="Hanlin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Shell 的变量功能变量是 bash 环境中非常重要的一个玩意儿，我们知道 Linux 是多人多任务的环境，每个人登陆系统都能取得一个 bash ， 每个人都能够使用 bash 下达 mail 这个命令来收受『自己』的邮件，问题是， bash 是如何得知你的邮件信箱是哪个文件？ 这就需要『变量』的帮助啦！所以，你说变量重不重要呢？底下我们将介绍重要的环境变量、变量的取用与配置等数据， 呼呼！动动">
<meta property="og:type" content="article">
<meta property="og:title" content="Shell的变量功能">
<meta property="og:url" content="https://hanlin-cheng.github.io/2023/08/25/Linux/Shell%E7%9A%84%E5%8F%98%E9%87%8F%E5%8A%9F%E8%83%BD/">
<meta property="og:site_name" content="HanLin">
<meta property="og:description" content="Shell 的变量功能变量是 bash 环境中非常重要的一个玩意儿，我们知道 Linux 是多人多任务的环境，每个人登陆系统都能取得一个 bash ， 每个人都能够使用 bash 下达 mail 这个命令来收受『自己』的邮件，问题是， bash 是如何得知你的邮件信箱是哪个文件？ 这就需要『变量』的帮助啦！所以，你说变量重不重要呢？底下我们将介绍重要的环境变量、变量的取用与配置等数据， 呼呼！动动">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://hanlin-cheng.github.io/img/material-7.png">
<meta property="article:published_time" content="2023-08-25T09:18:58.006Z">
<meta property="article:modified_time" content="2023-08-25T09:21:17.316Z">
<meta property="article:author" content="Hanlin">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Shell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hanlin-cheng.github.io/img/material-7.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hanlin-cheng.github.io/2023/08/25/Linux/Shell%E7%9A%84%E5%8F%98%E9%87%8F%E5%8A%9F%E8%83%BD/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Shell的变量功能',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-25 17:21:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-sharp fa-solid fa-compass"></i><span> Directory</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/resource/"><i class="fa-fw fa-solid fa-graduation-cap"></i><span> Resource</span></a></div><div class="menus_item"><a class="site-page" href="/software/"><i class="fa-fw fa-solid fa-chalkboard"></i><span> Software</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> Resume</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="HanLin"><span class="site-name">HanLin</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-sharp fa-solid fa-compass"></i><span> Directory</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/resource/"><i class="fa-fw fa-solid fa-graduation-cap"></i><span> Resource</span></a></div><div class="menus_item"><a class="site-page" href="/software/"><i class="fa-fw fa-solid fa-chalkboard"></i><span> Software</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> Resume</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Shell的变量功能</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-08-25T09:18:58.006Z" title="Created 2023-08-25 17:18:58">2023-08-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-08-25T09:21:17.316Z" title="Updated 2023-08-25 17:21:17">2023-08-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Shell的变量功能"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="Shell-的变量功能"><a href="#Shell-的变量功能" class="headerlink" title="Shell 的变量功能"></a><img src="http://cn.linux.vbird.org/image/logo.png" alt="大标题的图示"><strong>Shell 的变量功能</strong></h2><p>变量是 bash 环境中非常重要的一个玩意儿，我们知道 Linux 是多人多任务的环境，每个人登陆系统都能取得一个 bash ， 每个人都能够使用 bash 下达 mail 这个命令来收受『自己』的邮件，问题是， bash 是如何得知你的邮件信箱是哪个文件？ 这就需要『变量』的帮助啦！所以，你说变量重不重要呢？底下我们将介绍重要的环境变量、变量的取用与配置等数据， 呼呼！动动脑时间又来到啰！^_^</p>
<hr>
<h2 id="什么是变量？"><a href="#什么是变量？" class="headerlink" title="什么是变量？"></a><img src="http://cn.linux.vbird.org/image/logo.png" alt="小标题的图示"><strong>什么是变量？</strong></h2><p>那么，什么是『变量』呢？简单的说，就是让某一个特定字符串代表不固定的内容就是了。举个大家在国中都会学到的数学例子， 那就是：『 y &#x3D; ax + b 』这东西，在等号左边的(y)就是变量，在等号右边的(ax+b)就是变量内容。 要注意的是，左边是未知数，右边是已知数喔！ 讲的更简单一点，我们可以『用一个简单的 “字眼” 来取代另一个比较复杂或者是容易变动的数据』。这有什么好处啊？最大的好处就是『方便！』。</p>
<hr>
<ul>
<li><h3 id="变量的可变性与方便性"><a href="#变量的可变性与方便性" class="headerlink" title="变量的可变性与方便性"></a>变量的可变性与方便性</h3></li>
</ul>
<p>举例来说，我们每个账号的邮件信箱默认是以 MAIL 这个变量来进行存取的， 当 dmtsai 这个使用者登陆时，他便会取得 MAIL 这个变量，而这个变量的内容其实就是 &#x2F;var&#x2F;spool&#x2F;mail&#x2F;dmtsai， 那如果 vbird 登陆呢？他取得的 MAIL 这个变量的内容其实就是 &#x2F;var&#x2F;spool&#x2F;mail&#x2F;vbird 。 而我们使用信件读取命令 mail 来读取自己的邮件信箱时，嘿嘿，这支程序可以直接读取 MAIL 这个变量的内容， 就能够自动的分辨出属于自己的信箱信件啰！这样一来，设计程序的设计师就真的很方便的啦！</p>
<p><img src="/media/var_01.gif" alt="程序、变量与不同用户的关系"><br>图 2.1.1、程序、变量与不同用户的关系</p>
<p>如上图所示，由于系统已经帮我们规划好 MAIL 这个变量，所以用户只要知道 mail 这个命令如何使用即可， mail 会主动的取用 MAIL 这个变量，就能够如上图所示的取得自己的邮件信箱了！(注意大小写，小写的 mail 是命令， 大写的 MAIL 则是变量名称喔！)</p>
<p>那么使用变量真的比较好吗？这是当然的！想象一个例子，如果 mail 这个命令将 root 收信的邮件信箱 (mailbox) 档名为 &#x2F;var&#x2F;spool&#x2F;mail&#x2F;root 直接写入程序代码中。那么当 dmtsai 要使用 mail 时，将会取得 &#x2F;var&#x2F;spool&#x2F;mail&#x2F;root 这个文件的内容！ 不合理吧！所以你就需要帮 dmtsai 也设计一个 mail 的程序，将 &#x2F;var&#x2F;spool&#x2F;mail&#x2F;dmtsai 写死到 mail 的程序代码当中！ 天吶！那系统要有多少个 mail 命令啊？反过来说，使用变量就变的很简单了！因为你不需要更动到程序代码啊！ 只要将 MAIL 这个变量带入不同的内容即可让所有使用者透过 mail 取得自己的信件！当然简单多了！</p>
<hr>
<ul>
<li><h3 id="影响-bash-环境操作的变量"><a href="#影响-bash-环境操作的变量" class="headerlink" title="影响 bash 环境操作的变量"></a>影响 bash 环境操作的变量</h3></li>
</ul>
<p>某些特定变量会影响到 bash 的环境喔！举例来说，我们前面已经提到过很多次的那个 PATH 变量！ 你能不能在任何目录下运行某个命令，与 PATH 这个变量有很大的关系。例如你下达 ls 这个命令时，系统就是透过 PATH 这个变量里面的内容所记录的路径顺序来搜寻命令的呢！如果在搜寻完 PATH 变量内的路径还找不到 ls 这个命令时， 就会在屏幕上显示『 command not found 』的错误信息了。</p>
<p>如果说的学理一点，那么由于在 Linux System 下面，所有的线程都是需要一个运行码， 而就如同上面提到的，你『真正以 shell 来跟 Linux 沟通，是在正确的登陆 Linux 之后！』这个时候你就有一个 bash 的运行程序，也才可以真正的经由 bash 来跟系统沟通啰！而在进入 shell 之前，也正如同上面提到的，由于系统需要一些变量来提供他数据的存取 (或者是一些环境的配置参数值， 例如是否要显示彩色等等的) ，所以就有一些所谓的『环境变量』 需要来读入系统中了！这些环境变量例如 PATH、HOME、MAIL、SHELL 等等，都是很重要的， 为了区别与自定义变量的不同，环境变量通常以大写字符来表示呢！</p>
<hr>
<ul>
<li><h3 id="脚本程序设计-shell-script-的好帮手"><a href="#脚本程序设计-shell-script-的好帮手" class="headerlink" title="脚本程序设计 (shell script) 的好帮手"></a>脚本程序设计 (shell script) 的好帮手</h3></li>
</ul>
<p>这些还都只是系统默认的变量的目的，如果是个人的配置方面的应用呢：例如你要写一个大型的 script 时，有些数据因为可能由于用户习惯的不同而有差异，比如说路径好了，由于该路径在 script 被使用在相当多的地方，如果下次换了一部主机，都要修改 script 里面的所有路径，那么我一定会疯掉！ 这个时候如果使用变量，而将该变量的定义写在最前面，后面相关的路径名称都以变量来取代， 嘿嘿！那么你只要修改一行就等于修改整篇 script 了！方便的很！所以，良好的程序设计师都会善用变量的定义！</p>
<p><img src="/media/var_02.gif" alt="变量应用于 shell script 的示意图"><br>图 2.1.2、变量应用于 shell script 的示意图</p>
<p>最后我们就简单的对『什么是变量』作个简单定义好了： 『变量就是以一组文字或符号等，来取代一些配置或者是一串保留的数据！』， 例如：我配置了『myname』就是『VBird』，所以当你读取 myname 这个变量的时候，系统自然就会知道！哈！那就是 VBird 啦！ 那么如何『显示变量』呢？这就需要使用到 echo 这个命令啦！</p>
<hr>
<h2 id="变量的取用与配置：echo-变量配置守则-unset"><a href="#变量的取用与配置：echo-变量配置守则-unset" class="headerlink" title="变量的取用与配置：echo, 变量配置守则, unset"></a><img src="http://cn.linux.vbird.org/image/logo.png" alt="小标题的图示"><strong>变量的取用与配置：echo, 变量配置守则, unset</strong></h2><p>说的口沫横飞的，也不知道『变量』与『变量代表的内容』有啥关系？ 那我们就将『变量』的『内容』拿出来给您瞧瞧好了。你可以利用 echo 这个命令来取用变量， 但是，变量在被取用时，前面必须要加上钱字号『 $ 』才行，举例来说，要知道 PATH 的内容，该如何是好？</p>
<hr>
<ul>
<li><h3 id="变量的取用-echo"><a href="#变量的取用-echo" class="headerlink" title="变量的取用: echo"></a>变量的取用: echo</h3></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# echo $variable [root@www ~]# echo $PATH /usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin [root@www ~]# echo $&#123;PATH&#125; </span><br></pre></td></tr></table></figure>

<p>变量的取用就如同上面的范例，利用 echo 就能够读出，只是需要在变量名称前面加上 $ ， 或者是以 ${变量} 的方式来取用都可以！当然啦，那个 echo 的功能可是很多的， 我们这里单纯是拿 echo 来读出变量的内容而已，更多的 echo 使用，请自行给他 man echo 吧！ ^_^</p>
<p>例题：请在屏幕上面显示出您的环境变量 HOME 与 MAIL：答：echo $HOME 或者是 echo ${HOME} echo $MAIL 或者是 echo ${MAIL}</p>
<p>现在我们知道了变量与变量内容之间的相关性了，好了，那么我要如何『配置』或者是『修改』 某个变量的内容啊？很简单啦！用『等号(&#x3D;)』连接变量与他的内容就好啦！举例来说： 我要将 myname 这个变量名称的内容配置为 VBird ，那么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# echo $myname       &lt;==这里并没有任何数据～因为这个变量尚未被配置！是空的！ [root@www ~]# myname=VBird [root@www ~]# echo $myname VBird  &lt;==出现了！因为这个变量已经被配置了！ </span><br></pre></td></tr></table></figure>

<p>瞧！如此一来，这个变量名称 myname 的内容就带有 VBird 这个数据啰～ 而由上面的例子当中，我们也可以知道： 在 bash 当中，当一个变量名称尚未被配置时，默认的内容是『空』的。 另外，变量在配置时，还是需要符合某些规定的，否则会配置失败喔！ 这些守则如下所示啊！</p>
<hr>
<ul>
<li><h3 id="变量的配置守则"><a href="#变量的配置守则" class="headerlink" title="变量的配置守则"></a>变量的配置守则</h3></li>
</ul>
<ol>
<li><p>变量与变量内容以一个等号『&#x3D;』来连结，如下所示：<br>『myname&#x3D;VBird』</p>
</li>
<li><p>等号两边不能直接接空格符，如下所示为错误：<br>『myname &#x3D; VBird』或『myname&#x3D;VBird Tsai』</p>
</li>
<li><p>变量名称只能是英文字母与数字，但是开头字符不能是数字，如下为错误：<br>『2myname&#x3D;VBird』</p>
</li>
<li><p>变量内容若有空格符可使用双引号『”』或单引号『’』将变量内容结合起来，但</p>
<ul>
<li>双引号内的特殊字符如 $ 等，可以保有原本的特性，如下所示：<br>『var&#x3D;”lang is $LANG”』则『echo $var』可得『lang is en_US』</li>
<li>单引号内的特殊字符则仅为一般字符 (纯文本)，如下所示：<br>『var&#x3D;’lang is $LANG’』则『echo $var』可得『lang is $LANG』</li>
</ul>
</li>
<li><p>可用跳脱字符『 \ 』将特殊符号(如 [Enter], $, , 空格符, ‘等)变成一般字符；</p>
</li>
<li><p>在一串命令中，还需要藉由其他的命令提供的信息，可以使用反单引号『<code>命令</code>』或 『$(命令)』。特别注意，那个 &#96; 是键盘上方的数字键 1 左边那个按键，而不是单引号！ 例如想要取得核心版本的配置：<br>『version&#x3D;$(uname -r)』再『echo $version』可得『2.6.18-128.el5』</p>
</li>
<li><p>若该变量为扩增变量内容时，则可用 “$变量名称” 或 ${变量} 累加内容，如下所示：<br>『PATH&#x3D;”$PATH”:&#x2F;home&#x2F;bin』</p>
</li>
<li><p>若该变量需要在其他子程序运行，则需要以 export 来使变量变成环境变量：<br>『export PATH』</p>
</li>
<li><p>通常大写字符为系统默认变量，自行配置变量可以使用小写字符，方便判断 (纯粹依照使用者兴趣与嗜好) ；</p>
</li>
<li><p>取消变量的方法为使用 unset ：『unset 变量名称』例如取消 myname 的配置：<br>『unset myname』</p>
</li>
</ol>
<p>底下让鸟哥举几个例子来让你试看看，就知道怎么配置好你的变量啰！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">范例一：配置一变量 name ，且内容为 VBird</span><br><span class="line">[root@www ~]# 12name=VBird</span><br><span class="line">-bash: 12name=VBird: command not found  &lt;==屏幕会显示错误！因为不能以数字开头！</span><br><span class="line">[root@www ~]# name = VBird            &lt;==还是错误！因为有空白！</span><br><span class="line">[root@www ~]# name=VBird              &lt;==OK 的啦！</span><br><span class="line"></span><br><span class="line">范例二：承上题，若变量内容为 VBird&#x27;s name 呢，就是变量内容含有特殊符号时：</span><br><span class="line">[root@www ~]# name=VBird&#x27;s name  </span><br><span class="line"># 单引号与双引号必须要成对，在上面的配置中仅有一个单引号，因此当你按下 enter 后，</span><br><span class="line"># 你还可以继续输入变量内容。这与我们所需要的功能不同，失败啦！</span><br><span class="line"># 记得，失败后要复原请按下 [ctrl]-c 结束！</span><br><span class="line">[root@www ~]# name=&quot;VBird&#x27;s name&quot;    &lt;==OK 的啦！</span><br><span class="line"># 命令是由左边向右找→，先遇到的引号先有用，因此如上所示，单引号会失效！</span><br><span class="line">[root@www ~]# name=&#x27;VBird&#x27;s name&#x27;    &lt;==失败的啦！</span><br><span class="line"># 因为前两个单引号已成对，后面就多了一个不成对的单引号了！因此也就失败了！</span><br><span class="line">[root@www ~]# name=VBird\&#x27;s\ name     &lt;==OK 的啦！</span><br><span class="line"># 利用反斜杠 (\) 跳脱特殊字符，例如单引号与空格键，这也是 OK 的啦！</span><br><span class="line"></span><br><span class="line">范例三：我要在 PATH 这个变量当中『累加』:/home/dmtsai/bin 这个目录</span><br><span class="line">[root@www ~]# PATH=$PATH:/home/dmtsai/bin</span><br><span class="line">[root@www ~]# PATH=&quot;$PATH&quot;:/home/dmtsai/bin</span><br><span class="line">[root@www ~]# PATH=$&#123;PATH&#125;:/home/dmtsai/bin</span><br><span class="line"># 上面这三种格式在 PATH 里头的配置都是 OK 的！但是底下的例子就不见得啰！</span><br><span class="line"></span><br><span class="line">范例四：承范例三，我要将 name 的内容多出 &quot;yes&quot; 呢？</span><br><span class="line">[root@www ~]# name=$nameyes  </span><br><span class="line"># 知道了吧？如果没有双引号，那么变量成了啥？name 的内容是 $nameyes 这个变量！</span><br><span class="line"># 呵呵！我们可没有配置过 nameyes 这个变量吶！所以，应该是底下这样才对！</span><br><span class="line">[root@www ~]# name=&quot;$name&quot;yes</span><br><span class="line">[root@www ~]# name=$&#123;name&#125;yes  &lt;==以此例较佳！</span><br><span class="line"></span><br><span class="line">范例五：如何让我刚刚配置的 name=VBird 可以用在下个 shell 的程序？</span><br><span class="line">[root@www ~]# name=VBird</span><br><span class="line">[root@www ~]# bash        &lt;==进入到所谓的子程序</span><br><span class="line">[root@www ~]# echo $name  &lt;==子程序：再次的 echo 一下；</span><br><span class="line">       &lt;==嘿嘿！并没有刚刚配置的内容喔！</span><br><span class="line">[root@www ~]# exit        &lt;==子程序：离开这个子程序</span><br><span class="line">[root@www ~]# export name</span><br><span class="line">[root@www ~]# bash        &lt;==进入到所谓的子程序</span><br><span class="line">[root@www ~]# echo $name  &lt;==子程序：在此运行！</span><br><span class="line">VBird  &lt;==看吧！出现配置值了！</span><br><span class="line">[root@www ~]# exit        &lt;==子程序：离开这个子程序</span><br></pre></td></tr></table></figure>

<p>什么是『子程序』呢？就是说，在我目前这个 shell 的情况下，去激活另一个新的 shell ，新的那个 shell 就是子程序啦！在一般的状态下，父程序的自定义变量是无法在子程序内使用的。但是透过 export 将变量变成环境变量后，就能够在子程序底下应用了！很不赖吧！至于程序的相关概念， 我们会在<a target="_blank" rel="noopener" href="http://cn.linux.vbird.org/linux_basic/0440processcontrol.php">第十七章程序管理</a>当中提到的喔！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">范例六：如何进入到您目前核心的模块目录？ [root@www ~]# cd /lib/modules/`uname -r`/kernel [root@www ~]# cd /lib/modules/$(uname -r)/kernel </span><br></pre></td></tr></table></figure>

<p>每个 Linux 都能够拥有多个核心版本，且几乎 distribution 的核心版本都不相同。以 CentOS 5.3 (未升级前) 为例，他的默认核心版本是 2.6.18-128.el5 ，所以核心模块目录在 &#x2F;lib&#x2F;modules&#x2F;2.6.18-128.el5&#x2F;kernel&#x2F; 内。 也由于每个 distributions 的这个值都不相同，但是我们却可以利用 uname -r 这个命令先取得版本信息。所以啰，就可以透过上面命令当中的内含命令 <code>uname -r</code> 先取得版本输出到 cd … 那个命令当中，就能够顺利的进入目前核心的驱动程序所放置的目录啰！很方便吧！</p>
<p>其实上面的命令可以说是作了两次动作，亦即是：</p>
<ol>
<li>先进行反单引号内的动作『uname -r』并得到核心版本为 2.6.18-128.el5</li>
<li>将上述的结果带入原命令，故得命令为：『cd &#x2F;lib&#x2F;modules&#x2F;2.6.18-128.el5&#x2F;kernel&#x2F;』</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">范例七：取消刚刚配置的 name 这个变量内容 [root@www ~]# unset name </span><br></pre></td></tr></table></figure>

<p>根据上面的案例你可以试试看！就可以了解变量的配置啰！这个是很重要的呦！请勤加练习！ 其中，较为重要的一些特殊符号的使用啰！例如单引号、双引号、跳脱字符、钱字号、反单引号等等，底下的例题想一想吧！</p>
<p>例题：在变量的配置当中，单引号与双引号的用途有何不同？ 答：单引号与双引号的最大不同在于双引号仍然可以保有变量的内容，但单引号内仅能是一般字符 ，而不会有特殊符号。我们以底下的例子做说明：假设您定义了一个变量， name&#x3D;VBird ，现在想以 name 这个变量的内容定义出 myname 显示 VBird its me 这个内容，要如何订定呢？[root@www ~]# name&#x3D;VBird [root@www ~]# echo $name VBird [root@www ~]# myname&#x3D;”$name its me” [root@www ~]# echo $myname VBird its me [root@www ~]# myname&#x3D;’$name its me’ [root@www ~]# echo $myname $name its me发现了吗？没错！使用了单引号的时候，那么 $name 将失去原有的变量内容，仅为一般字符的显示型态而已！这里必需要特别小心在意！</p>
<p>例题：在命令下达的过程中，反单引号( )这个符号代表的意义为何？答：在一串命令中，在 之内的命令将会被先运行，而其运行出来的结果将做为外部的输入信息！例如 uname -r 会显示出目前的核心版本，而我们的核心版本在 &#x2F;lib&#x2F;modules 里面，因此，你可以先运行 uname -r 找出核心版本，然后再以『 cd 目录』到该目录下，当然也可以运行如同上面范例六的运行内容啰。  另外再举个例子，我们也知道， <a target="_blank" rel="noopener" href="http://cn.linux.vbird.org/linux_basic/0220filemanager.php#locate">locate</a> 命令可以列出所有的相关文件档名，但是，如果我想要知道各个文件的权限呢？举例来说，我想要知道每个 crontab 相关档名的权限：[root@www ~]# ls -l <code>locate crontab</code>如此一来，先以 locate 将文件名数据都列出来，再以 ls 命令来处理的意思啦！瞭了吗？ ^_^</p>
<p>例题：若你有一个常去的工作目录名称为：『&#x2F;cluster&#x2F;server&#x2F;work&#x2F;taiwan_2005&#x2F;003&#x2F;』，如何进行该目录的简化？答：在一般的情况下，如果你想要进入上述的目录得要『cd &#x2F;cluster&#x2F;server&#x2F;work&#x2F;taiwan_2005&#x2F;003&#x2F;』， 以鸟哥自己的案例来说，鸟哥跑数值模式常常会配置很长的目录名称(避免忘记)，但如此一来变换目录就很麻烦。 此时，鸟哥习惯利用底下的方式来降低命令下达错误的问题：[root@www ~]# work&#x3D;”&#x2F;cluster&#x2F;server&#x2F;work&#x2F;taiwan_2005&#x2F;003&#x2F;“ [root@www ~]# cd $work未来我想要使用其他目录作为我的模式工作目录时，只要变更 work 这个变量即可！而这个变量又可以在 <a target="_blank" rel="noopener" href="http://cn.linux.vbird.org/linux_basic/0320bash_2.php#settings_bashrc">bash 的配置文件</a>中直接指定，那我每次登陆只要运行『 cd $work 』就能够去到数值模式仿真的工作目录了！是否很方便呢？ ^_^</p>
<hr>
<h2 id="环境变量的功能"><a href="#环境变量的功能" class="headerlink" title="环境变量的功能"></a><img src="http://cn.linux.vbird.org/image/logo.png" alt="小标题的图示"><strong>环境变量的功能</strong></h2><p>环境变量可以帮我们达到很多功能～包括家目录的变换啊、提示字符的显示啊、运行文件搜寻的路径啊等等的， 还有很多很多啦！那么，既然环境变量有那么多的功能，问一下，目前我的 shell 环境中， 有多少默认的环境变量啊？我们可以利用两个命令来查阅，分别是 env 与 export 呢！</p>
<hr>
<ul>
<li><h3 id="用-env-观察环境变量与常见环境变量说明"><a href="#用-env-观察环境变量与常见环境变量说明" class="headerlink" title="用 env 观察环境变量与常见环境变量说明"></a>用 env 观察环境变量与常见环境变量说明</h3></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">范例一：列出目前的 shell 环境下的所有环境变量与其内容。</span><br><span class="line">[root@www ~]# env</span><br><span class="line">HOSTNAME=www.vbird.tsai    &lt;== 这部主机的主机名</span><br><span class="line">TERM=xterm                 &lt;== 这个终端机使用的环境是什么类型</span><br><span class="line">SHELL=/bin/bash            &lt;== 目前这个环境下，使用的 Shell 是哪一个程序？</span><br><span class="line">HISTSIZE=1000              &lt;== 『记录命令的笔数』在 CentOS 默认可记录 1000 笔</span><br><span class="line">USER=root                  &lt;== 使用者的名称啊！</span><br><span class="line">LS_COLORS=no=00:fi=00:di=00;34:ln=00;36:pi=40;33:so=00;35:bd=40;33;01:cd=40;33;01:</span><br><span class="line">or=01;05;37;41:mi=01;05;37;41:ex=00;32:*.cmd=00;32:*.exe=00;32:*.com=00;32:*.btm=0</span><br><span class="line">0;32:*.bat=00;32:*.sh=00;32:*.csh=00;32:*.tar=00;31:*.tgz=00;31:*.arj=00;31:*.taz=</span><br><span class="line">00;31:*.lzh=00;31:*.zip=00;31:*.z=00;31:*.Z=00;31:*.gz=00;31:*.bz2=00;31:*.bz=00;3</span><br><span class="line">1:*.tz=00;31:*.rpm=00;31:*.cpio=00;31:*.jpg=00;35:*.gif=00;35:*.bmp=00;35:*.xbm=00</span><br><span class="line">;35:*.xpm=00;35:*.png=00;35:*.tif=00;35: &lt;== 一些颜色显示</span><br><span class="line">MAIL=/var/spool/mail/root  &lt;== 这个用户所取用的 mailbox 位置</span><br><span class="line">PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/X11R6/bin:/usr/local/bin:/usr/local/sbin:</span><br><span class="line">/root/bin                  &lt;== 不再多讲啊！是运行文件命令搜寻路径</span><br><span class="line">INPUTRC=/etc/inputrc       &lt;== 与键盘按键功能有关。可以配置特殊按键！</span><br><span class="line">PWD=/root                  &lt;== 目前用户所在的工作目录 (利用 pwd 取出！)</span><br><span class="line">LANG=en_US                 &lt;== 这个与语系有关，底下会再介绍！</span><br><span class="line">HOME=/root                 &lt;== 这个用户的家目录啊！</span><br><span class="line">_=/bin/env                 &lt;== 上一次使用的命令的最后一个参数(或命令本身)</span><br></pre></td></tr></table></figure>

<p>env 是 environment (环境) 的简写啊，上面的例子当中，是列出来所有的环境变量。当然，如果使用 export 也会是一样的内容～ 只不过， export 还有其他额外的功能就是了，我们等一下再提这个 export 命令。 那么上面这些变量有些什么功用呢？底下我们就一个一个来分析分析！</p>
<ul>
<li><p><strong>HOME</strong><br>代表用户的家目录。还记得我们可以使用 cd ~ 去到自己的家目录吗？或者利用 cd 就可以直接回到用户家目录了。那就是取用这个变量啦～ 有很多程序都可能会取用到这个变量的值！</p>
</li>
<li><p><strong>SHELL</strong><br>告知我们，目前这个环境使用的 SHELL 是哪支程序？ Linux 默认使用 &#x2F;bin&#x2F;bash 的啦！</p>
</li>
<li><p><strong>HISTSIZE</strong><br>这个与『历史命令』有关，亦即是， 我们曾经下达过的命令可以被系统记录下来，而记录的『笔数』则是由这个值来配置的。</p>
</li>
<li><p><strong>MAIL</strong><br>当我们使用 mail 这个命令在收信时，系统会去读取的邮件信箱文件 (mailbox)。</p>
</li>
<li><p><strong>PATH</strong><br>就是运行文件搜寻的路径啦～目录与目录中间以冒号(:)分隔， 由于文件的搜寻是依序由 PATH 的变量内的目录来查询，所以，目录的顺序也是重要的喔。</p>
</li>
<li><p><strong>LANG</strong><br>这个重要！就是语系数据啰～很多信息都会用到他， 举例来说，当我们在启动某些 perl 的程序语言文件时，他会主动的去分析语系数据文件， 如果发现有他无法解析的编码语系，可能会产生错误喔！一般来说，我们中文编码通常是 zh_TW.Big5 或者是 zh_TW.UTF-8，这两个编码偏偏不容易被解译出来，所以，有的时候，可能需要修订一下语系数据。 这部分我们会在下个小节做介绍的！</p>
</li>
<li><p><strong>RANDOM</strong></p>
<p>这个玩意儿就是『随机随机数』的变量啦！目前大多数的 distributions 都会有随机数生成器，那就是</p>
<p> &#x2F;dev&#x2F;random</p>
<p>这个文件。 我们可以透过这个随机数文件相关的变量 ($RANDOM) 来随机取得随机数值喔。在 BASH 的环境下，这个 RANDOM 变量的内容，介于 0<del>32767 之间，所以，你只要 echo $RANDOM 时，系统就会主动的随机取出一个介于 0</del>32767 的数值。万一我想要使用 0~9 之间的数值呢？呵呵～利用 declare 宣告数值类型， 然后这样做就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# declare -i number=$RANDOM*10/32768 ; </span><br><span class="line">echo $number </span><br><span class="line">8   &lt;== 此时会随机取出 0~9 之间的数值喔！ </span><br></pre></td></tr></table></figure></li>
</ul>
<p>大致上是有这些环境变量啦～里面有些比较重要的参数，在底下我们都会另外进行一些说明的～</p>
<hr>
<ul>
<li><h3 id="用-set-观察所有变量-含环境变量与自定义变量"><a href="#用-set-观察所有变量-含环境变量与自定义变量" class="headerlink" title="用 set 观察所有变量 (含环境变量与自定义变量)"></a>用 set 观察所有变量 (含环境变量与自定义变量)</h3></li>
</ul>
<p>bash 可不只有环境变量喔，还有一些与 bash 操作接口有关的变量，以及用户自己定义的变量存在的。 那么这些变量如何观察呢？这个时候就得要使用 set 这个命令了。 set 除了环境变量之外， 还会将其他在 bash 内的变量通通显示出来哩！信息很多，底下鸟哥仅列出几个重要的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# set</span><br><span class="line">BASH=/bin/bash           &lt;== bash 的主程序放置路径</span><br><span class="line">BASH_VERSINFO=([0]=&quot;3&quot; [1]=&quot;2&quot; [2]=&quot;25&quot; [3]=&quot;1&quot; [4]=&quot;release&quot; </span><br><span class="line">[5]=&quot;i686-redhat-linux-gnu&quot;)      &lt;== bash 的版本啊！</span><br><span class="line">BASH_VERSION=&#x27;3.2.25(1)-release&#x27;  &lt;== 也是 bash 的版本啊！</span><br><span class="line">COLORS=/etc/DIR_COLORS.xterm      &lt;== 使用的颜色纪录文件</span><br><span class="line">COLUMNS=115              &lt;== 在目前的终端机环境下，使用的字段有几个字符长度</span><br><span class="line">HISTFILE=/root/.bash_history      &lt;== 历史命令记录的放置文件，隐藏档</span><br><span class="line">HISTFILESIZE=1000        &lt;== 存起来(与上个变量有关)的文件之命令的最大纪录笔数。</span><br><span class="line">HISTSIZE=1000            &lt;== 目前环境下，可记录的历史命令最大笔数。</span><br><span class="line">HOSTTYPE=i686            &lt;== 主机安装的软件主要类型。我们用的是 i686 兼容机器软件</span><br><span class="line">IFS=$&#x27; \t\n&#x27;             &lt;== 默认的分隔符</span><br><span class="line">LINES=35                 &lt;== 目前的终端机下的最大行数</span><br><span class="line">MACHTYPE=i686-redhat-linux-gnu    &lt;== 安装的机器类型</span><br><span class="line">MAILCHECK=60             &lt;== 与邮件有关。每 60 秒去扫瞄一次信箱有无新信！</span><br><span class="line">OLDPWD=/home             &lt;== 上个工作目录。我们可以用 cd - 来取用这个变量。</span><br><span class="line">OSTYPE=linux-gnu         &lt;== 操作系统的类型！</span><br><span class="line">PPID=20025               &lt;== 父程序的 PID (会在后续章节才介绍)</span><br><span class="line">PS1=&#x27;[\u@\h \W]\$ &#x27;      &lt;== PS1 就厉害了。这个是命令提示字符，也就是我们常见的</span><br><span class="line">                             [root@www ~]# 或 [dmtsai ~]$ 的配置值啦！可以更动的！</span><br><span class="line">PS2=&#x27;&gt; &#x27;                 &lt;== 如果你使用跳脱符号 (\) 第二行以后的提示字符也</span><br><span class="line">name=VBird               &lt;== 刚刚配置的自定义变量也可以被列出来喔！</span><br><span class="line">$                        &lt;== 目前这个 shell 所使用的 PID</span><br><span class="line">?                        &lt;== 刚刚运行完命令的回传值。</span><br></pre></td></tr></table></figure>

<p>一般来说，不论是否为环境变量，只要跟我们目前这个 shell 的操作接口有关的变量， 通常都会被配置为大写字符，也就是说，『基本上，在 Linux 默认的情况中，使用{大写的字母}来配置的变量一般为系统内定需要的变量』。 OK！OK！那么上头那些变量当中，有哪些是比较重要的？大概有这几个吧！</p>
<ul>
<li><p>PS1</p>
<p>：(提示字符的配置)</p>
<p>这是 PS1 (数字的 1 不是英文字母)，这个东西就是我们的『</p>
<p>命令提示字符</p>
<p>』喔！ 当我们每次按下 [Enter] 按键去运行某个命令后，最后要再次出现提示字符时， 就会主动去读取这个变量值了。上头 PS1 内显示的是一些特殊符号，这些特殊符号可以显示不同的信息， 每个 distributions 的 bash 默认的 PS1 变量内容可能有些许的差异，不要紧，『习惯你自己的习惯』就好了。 你可以用 man bash (</p>
<p>注3</p>
<p>)去查询一下 PS1 的相关说明，以理解底下的一些符号意义。</p>
<ul>
<li>\d ：可显示出『星期 月 日』的日期格式，如：”Mon Feb 2”</li>
<li>\H ：完整的主机名。举例来说，鸟哥的练习机为『<a target="_blank" rel="noopener" href="http://www.vbird.tsai』/">www.vbird.tsai』</a></li>
<li>\h ：仅取主机名在第一个小数点之前的名字，如鸟哥主机则为『www』后面省略</li>
<li>\t ：显示时间，为 24 小时格式的『HH:MM:SS』</li>
<li>\T ：显示时间，为 12 小时格式的『HH:MM:SS』</li>
<li>\A ：显示时间，为 24 小时格式的『HH:MM』</li>
<li>@ ：显示时间，为 12 小时格式的『am&#x2F;pm』样式</li>
<li>\u ：目前使用者的账号名称，如『root』；</li>
<li>\v ：BASH 的版本信息，如鸟哥的测试主板本为 3.2.25(1)，仅取『3.2』显示</li>
<li>\w ：完整的工作目录名称，由根目录写起的目录名称。但家目录会以 ~ 取代；</li>
<li>\W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。</li>
<li># ：下达的第几个命令。</li>
<li>$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ 啰～</li>
</ul>
<p>好了，让我们来看看 CentOS 默认的 PS1 内容吧：『[\u@\h \W]$ 』，现在你知道那些反斜杠后的数据意义了吧？ 要注意喔！那个反斜杠后的数据为 PS1 的特殊功能，与 bash 的变量配置没关系啦！不要搞混了喔！ 那你现在知道为何你的命令提示字符是：『 [root@www ~]# 』了吧？ 好了，那么假设我想要有类似底下的提示字符：</p>
<blockquote>
<p>[root@www &#x2F;home&#x2F;dmtsai 16:50 #12]#</p>
</blockquote>
<p>那个 # 代表第 12 次下达的命令。那么应该如何配置 PS1 呢？可以这样啊：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~ ]# cd /home</span><br><span class="line">[root@www home]# PS1=&#x27;[\u@\h \w \A #\#]\$ &#x27;</span><br><span class="line">[root@www /home 17:02 #85]# </span><br><span class="line"># 看到了吗？提示字符变了！变的很有趣吧！其中，那个 #85 比较有趣，</span><br><span class="line"># 如果您再随便输入几次 ls 后，该数字就会添加喔！为啥？上面有说明滴！</span><br></pre></td></tr></table></figure>


</li>
<li><p>**$**：(关于本 shell 的 PID)</p>
<p>钱字号本身也是个变量喔！这个咚咚代表的是『目前这个 Shell 的线程代号』，亦即是所谓的 PID (Process ID)。 更多的程序观念，我们会在第四篇的时候提及。想要知道我们的 shell 的 PID ，就可以用：『 echo $$ 』即可！出现的数字就是你的 PID 号码。</p>
</li>
<li><p>?</p>
<p>：(关于上个运行命令的回传值)</p>
<p>什么？问号也是一个特殊的变量？没错！在 bash 里面这个变量可重要的很！ 这个变量是：『上一个运行的命令所回传的值』， 上面这句话的重点是『上一个命令』与『回传值』两个地方。当我们运行某些命令时， 这些命令都会回传一个运行后的代码。一般来说，如果成功的运行该命令， 则会回传一个 0 值，如果运行过程发生错误，就会回传『错误代码』才对！一般就是以非为 0 的数值来取代。 我们以底下的例子来看看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# echo $SHELL</span><br><span class="line">/bin/bash                                  &lt;==可顺利显示！没有错误！</span><br><span class="line">[root@www ~]# echo $?</span><br><span class="line">0                                          &lt;==因为没问题，所以回传值为 0</span><br><span class="line">[root@www ~]# 12name=VBird</span><br><span class="line">-bash: 12name=VBird: command not found     &lt;==发生错误了！bash回报有问题</span><br><span class="line">[root@www ~]# echo $?</span><br><span class="line">127                                        &lt;==因为有问题，回传错误代码(非为0)</span><br><span class="line"># 错误代码回传值依据软件而有不同，我们可以利用这个代码来搜寻错误的原因喔！</span><br><span class="line">[root@www ~]# echo $?</span><br><span class="line">0</span><br><span class="line"># 咦！怎么又变成正确了？这是因为 &quot;?&quot; 只与『上一个运行命令』有关，</span><br><span class="line"># 所以，我们上一个命令是运行『 echo $? 』，当然没有错误，所以是 0 没错！</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>OSTYPE, HOSTTYPE, MACHTYPE</strong>：(主机硬件与核心的等级)</p>
<p>我们在<a target="_blank" rel="noopener" href="http://cn.linux.vbird.org/linux_basic/0105computers.php#pc_cpu">第零章、计算器概论内的 CPU 等级</a>说明中谈过 CPU ， 目前个人计算机的 CPU 主要分为 32&#x2F;64 位，其中 32 位又可分为 i386, i586, i686，而 64 位则称为 x86_64。 由于不同等级的 CPU 命令集不太相同，因此你的软件可能会针对某些 CPU 进行优化，以求取较佳的软件性能。 所以软件就有 i386, i686 及 x86_64 之分。以目前 (2009) 的主流硬件来说，几乎都是 x86_64 的天下！ 但是毕竟旧机器还是非常多，以鸟哥的环境来说，我用 P-III 等级的计算机，所以上头就发现我的等级是 i686 啦！</p>
<p>要留意的是，较高阶的硬件通常会向下兼容旧有的软件，但较高阶的软件可能无法在旧机器上面安装！ 我们在<a target="_blank" rel="noopener" href="http://cn.linux.vbird.org/linux_basic/0130designlinux.php#beforeinstall_distro">第三章</a>就曾说明过， 这里再强调一次，你可以在 x86_64 的硬件上安装 i386 的 Linux 操作系统，但是你无法在 i686 的硬件上安装 x86_64 的 Linux 操作系统！这点得要牢记在心！</p>
</li>
</ul>
<hr>
<ul>
<li><strong>export</strong>： <strong>自定义变量转成环境变量</strong></li>
</ul>
<p>谈了 env 与 set 现在知道有所谓的环境变量与自定义变量，那么这两者之间有啥差异呢？其实这两者的差异在于『 该变量是否会被子程序所继续引用』啦！唔！那么啥是父程序？子程序？ 这就得要了解一下命令的下达行为了。</p>
<p>当你登陆 Linux 并取得一个 bash 之后，你的 bash 就是一个独立的程序，被称为 PID 的就是。 接下来你在这个 bash 底下所下达的任何命令都是由这个 bash 所衍生出来的，那些被下达的命令就被称为子程序了。 我们可以用底下的图示来简单的说明一下父程序与子程序的概念：</p>
<p><img src="/media/ppid.gif" alt="程序相关性示意图"><br>图 2.3.1、程序相关性示意图</p>
<p>如上所示，我们在原本的 bash 底下运行另一个 bash ，结果操作的环境接口会跑到第二个 bash 去(就是子程序)， 那原本的 bash 就会在暂停的情况 (睡着了，就是 sleep)。整个命令运行的环境是实线的部分！若要回到原本的 bash 去， 就只有将第二个 bash 结束掉 (下达 exit 或 logout) 才行。更多的程序概念我们会在第四篇谈及，这里只要有这个概念即可。</p>
<p>这个程序概念与变量有啥关系啊？关系可大了！因为子程序仅会继承父程序的环境变量， 子程序不会继承父程序的自定义变量啦！所以你在原本 bash 的自定义变量在进入了子程序后就会消失不见， 一直到你离开子程序并回到原本的父程序后，这个变量才会又出现！</p>
<p>换个角度来想，也就是说，如果我能将自定义变量变成环境变量的话，那不就可以让该变量值继续存在于子程序了？ 呵呵！没错！此时，那个 export 命令就很有用啦！如你想要让该变量内容继续的在子程序中使用，那么就请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# export 变量名称 </span><br></pre></td></tr></table></figure>

<p>这东西用在『分享自己的变量配置给后来呼叫的文件或其他程序』啦！ 像鸟哥常常在自己的主控文件后面呼叫其他附属文件(类似函式的功能)，但是主控文件与附属文件内都有相同的变量名称， 若一再重复配置时，要修改也很麻烦，此时只要在原本的第一个文件内配置好『 export 变量 』， 后面所呼叫的文件就能够使用这个变量配置了！而不需要重复配置，这非常实用于 shell script 当中喔！ 如果仅下达 export 而没有接变量时，那么此时将会把所有的『环境变量』秀出来喔！例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# export declare -x HISTSIZE=&quot;1000&quot; declare -x HOME=&quot;/root&quot; declare -x HOSTNAME=&quot;www.vbird.tsai&quot; declare -x INPUTRC=&quot;/etc/inputrc&quot; declare -x LANG=&quot;en_US&quot; declare -x LOGNAME=&quot;root&quot; # 后面的鸟哥就都直接省略了！不然....浪费版面～ ^_^ </span><br></pre></td></tr></table></figure>

<p>那如何将环境变量转成自定义变量呢？可以使用本章后续介绍的 <a target="_blank" rel="noopener" href="http://cn.linux.vbird.org/linux_basic/0320bash_2.php#declare">declare</a> 呢！</p>
<hr>
<h2 id="影响显示结果的语系变量-locale"><a href="#影响显示结果的语系变量-locale" class="headerlink" title="影响显示结果的语系变量 (locale)"></a><img src="http://cn.linux.vbird.org/image/logo.png" alt="小标题的图示"><strong>影响显示结果的语系变量 (locale)</strong></h2><p>还记得我们在<a target="_blank" rel="noopener" href="http://cn.linux.vbird.org/linux_basic/0160startlinux.php#cmd_cmd_lang">第五章里面提到的语系问题</a>吗？ 就是当我们使用 man command 的方式去查询某个数据的说明文件时，该说明档的内容可能会因为我们使用的语系不同而产生乱码。 另外，利用 ls 查询文件的时间时，也可能会有乱码出现在时间的部分。那个问题其实就是语系的问题啦。</p>
<p>目前大多数的 Linux distributions 已经都是支持日渐流行的万国码了，也都支持大部分的国家语系。 这有赖于 <a target="_blank" rel="noopener" href="http://cn.linux.vbird.org/linux_basic/0320bash_2.php#ps4">i18n (注4)</a> 支持的帮助呢！ 那么我们的 Linux 到底支持了多少的语系呢？这可以由 locale 这个命令来查询到喔！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# locale -a</span><br><span class="line">....(前面省略)....</span><br><span class="line">zh_TW</span><br><span class="line">zh_TW.big5     &lt;==大五码的中文编码</span><br><span class="line">zh_TW.euctw</span><br><span class="line">zh_TW.utf8     &lt;==万国码的中文编码</span><br><span class="line">zu_ZA</span><br><span class="line">zu_ZA.iso88591</span><br><span class="line">zu_ZA.utf8</span><br></pre></td></tr></table></figure>

<p>正体中文语系至少支持了两种以上的编码，一种是目前还是很常见的 big5 ，另一种则是越来越热门的 utf-8 编码。 那么我们如何修订这些编码呢？其实可以透过底下这些变量的说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# locale  &lt;==后面不加任何选项与参数即可！</span><br><span class="line">LANG=en_US                   &lt;==主语言的环境</span><br><span class="line">LC_CTYPE=&quot;en_US&quot;             &lt;==字符(文字)辨识的编码</span><br><span class="line">LC_NUMERIC=&quot;en_US&quot;           &lt;==数字系统的显示信息</span><br><span class="line">LC_TIME=&quot;en_US&quot;              &lt;==时间系统的显示数据</span><br><span class="line">LC_COLLATE=&quot;en_US&quot;           &lt;==字符串的比较与排序等</span><br><span class="line">LC_MONETARY=&quot;en_US&quot;          &lt;==币值格式的显示等</span><br><span class="line">LC_MESSAGES=&quot;en_US&quot;          &lt;==信息显示的内容，如菜单、错误信息等</span><br><span class="line">LC_ALL=                      &lt;==整体语系的环境</span><br><span class="line">....(后面省略)....</span><br></pre></td></tr></table></figure>

<p>基本上，你可以逐一配置每个与语系有关的变量数据，但事实上，如果其他的语系变量都未配置， 且你有配置 LANG 或者是 LC_ALL 时，则其他的语系变量就会被这两个变量所取代！ 这也是为什么我们在 Linux 当中，通常说明仅配置 LANG 这个变量而已，因为他是最主要的配置变量！ 好了，那么你应该要觉得奇怪的是，为什么在 Linux 主机的终端机接口 (tty1 ~ tty6) 的环境下，如果配置『 LANG&#x3D;zh_TW.big5 』这个配置值生效后，使用 man 或者其他信息输出时， 都会有一堆乱码，尤其是使用 ls -l 这个参数时？</p>
<p>因为在 Linux 主机的终端机接口环境下是无法显示像中文这么复杂的编码文字， 所以就会产生乱码了。也就是如此，我们才会必须要在 tty1 ~ tty6 的环境下， 加装一些中文化接口的软件，才能够看到中文啊！不过，如果你是在 MS Windows 主机以远程联机服务器的软件联机到主机的话，那么，嘿嘿！其实文字接口确实是可以看到中文的。 此时反而你得要在 LANG 配置中文编码才好呢！</p>
<p>你当然可以让每个使用者自己去调整自己喜好的语系，但是整体系统默认的语系定义在哪里呢？ 其实就是在 &#x2F;etc&#x2F;sysconfig&#x2F;i18n 啰！这个文件在 CentOS 5.x 的内容有点像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# cat /etc/sysconfig/i18n </span><br><span class="line">LANG=&quot;zh_TW.UTF-8&quot; </span><br></pre></td></tr></table></figure>

<p>因为鸟哥在<a target="_blank" rel="noopener" href="http://cn.linux.vbird.org/linux_basic/0157installcentos5.php">第四章的安装时</a>选择的是中文语系安装画面， 所以这个文件默认就会使用中文编码啦！你也可以自行将他改成你想要的语系编码即可。</p>
<hr>
<h2 id="变量的有效范围"><a href="#变量的有效范围" class="headerlink" title="变量的有效范围"></a><img src="http://cn.linux.vbird.org/image/logo.png" alt="小标题的图示"><strong>变量的有效范围</strong></h2><p>什么？变量也有使用的『范围』？没错啊～我们在上头的 <a target="_blank" rel="noopener" href="http://cn.linux.vbird.org/linux_basic/0320bash_2.php#export">export</a> 命令说明中，就提到了这个概念了。如果在跑程序的时候，有父程序与子程序的不同程序关系时， 则『变量』可否被引用与 export 有关。被 export 后的变量，我们可以称他为『环境变量』！ 环境变量可以被子程序所引用，但是其他的自定义变量内容就不会存在于子程序中。</p>
<p>在学理方面，为什么环境变量的数据可以被子程序所引用呢？这是因为内存配置的关系！理论上是这样的：</p>
<ul>
<li>当启动一个 shell，操作系统会分配一记忆区块给 shell 使用，此内存内之变量可让子程序取用</li>
<li>若在父程序利用 export 功能，可以让自定义变量的内容写到上述的记忆区块当中(环境变量)；</li>
<li>当加载另一个 shell 时 (亦即启动子程序，而离开原本的父程序了)，子 shell 可以将父 shell 的环境变量所在的记忆区块导入自己的环境变量区块当中。</li>
</ul>
<p>透过这样的关系，我们就可以让某些变量在相关的程序之间存在，以帮助自己更方便的操作环境喔！ 不过要提醒的是，这个『环境变量』与『bash 的操作环境』意思不太一样，举例来说， PS1 并不是环境变量， 但是这个 PS1 会影响到 bash 的接口 (提示字符嘛)！相关性要厘清喔！^_^</p>
<hr>
<h2 id="变量键盘读取、数组与宣告：-read-array-declare"><a href="#变量键盘读取、数组与宣告：-read-array-declare" class="headerlink" title="变量键盘读取、数组与宣告： read, array, declare"></a><img src="http://cn.linux.vbird.org/image/logo.png" alt="小标题的图示"><strong>变量键盘读取、数组与宣告： read, array, declare</strong></h2><p>我们上面提到的变量配置功能，都是由命令列直接配置的，那么，可不可以让用户能够经由键盘输入？ 什么意思呢？是否记得某些程序运行的过程当中，会等待使用者输入 “yes&#x2F;no” 之类的信息啊？ 在 bash 里面也有相对应的功能喔！此外，我们还可以宣告这个变量的属性， 例如：数组或者是数字等等的。底下就来看看吧！</p>
<hr>
<ul>
<li><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3></li>
</ul>
<p>要读取来自键盘输入的变量，就是用 read 这个命令了。这个命令最常被用在 shell script 的撰写当中， 想要跟使用者对谈？用这个命令就对了。关于 script 的写法，我们会在第十三章介绍，底下先来瞧一瞧 read 的相关语法吧！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# read [-pt] variable</span><br><span class="line">选项与参数：</span><br><span class="line">-p  ：后面可以接提示字符！</span><br><span class="line">-t  ：后面可以接等待的『秒数！』这个比较有趣～不会一直等待使用者啦！</span><br><span class="line"></span><br><span class="line">范例一：让用户由键盘输入一内容，将该内容变成名为 atest 的变量</span><br><span class="line">[root@www ~]# read atest</span><br><span class="line">This is a test        &lt;==此时光标会等待你输入！请输入左侧文字看看</span><br><span class="line">[root@www ~]# echo $atest</span><br><span class="line">This is a test          &lt;==你刚刚输入的数据已经变成一个变量内容！</span><br><span class="line"></span><br><span class="line">范例二：提示使用者 30 秒内输入自己的大名，将该输入字符串作为名为 named 的变量内容</span><br><span class="line">[root@www ~]# read -p &quot;Please keyin your name: &quot; -t 30 named</span><br><span class="line">Please keyin your name: VBird Tsai   &lt;==注意看，会有提示字符喔！</span><br><span class="line">[root@www ~]# echo $named</span><br><span class="line">VBird Tsai        &lt;==输入的数据又变成一个变量的内容了！</span><br></pre></td></tr></table></figure>

<p>read 之后不加任何参数，直接加上变量名称，那么底下就会主动出现一个空白行等待你的输入(如范例一)。 如果加上 -t 后面接秒数，例如上面的范例二，那么 30 秒之内没有任何动作时， 该命令就会自动略过了～如果是加上 -p ，嘿嘿！在输入的光标前就会有比较多可以用的提示字符给我们参考！ 在命令的下达里面，比较美观啦！ ^_^</p>
<hr>
<ul>
<li><h3 id="declare-typeset"><a href="#declare-typeset" class="headerlink" title="declare &#x2F; typeset"></a>declare &#x2F; typeset</h3></li>
</ul>
<p>declare 或 typeset 是一样的功能，就是在『宣告变量的类型』。如果使用 declare 后面并没有接任何参数，那么 bash 就会主动的将所有的变量名称与内容通通叫出来，就好像使用 set 一样啦！ 那么 declare 还有什么语法呢？看看先：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# declare [-aixr] variable</span><br><span class="line">选项与参数：</span><br><span class="line">-a  ：将后面名为 variable 的变量定义成为数组 (array) 类型</span><br><span class="line">-i  ：将后面名为 variable 的变量定义成为整数数字 (integer) 类型</span><br><span class="line">-x  ：用法与 export 一样，就是将后面的 variable 变成环境变量；</span><br><span class="line">-r  ：将变量配置成为 readonly 类型，该变量不可被更改内容，也不能 unset</span><br><span class="line"></span><br><span class="line">范例一：让变量 sum 进行 100+300+50 的加总结果</span><br><span class="line">[root@www ~]# sum=100+300+50</span><br><span class="line">[root@www ~]# echo $sum</span><br><span class="line">100+300+50  &lt;==咦！怎么没有帮我计算加总？因为这是文字型态的变量属性啊！</span><br><span class="line">[root@www ~]# declare -i sum=100+300+50</span><br><span class="line">[root@www ~]# echo $sum</span><br><span class="line">450         &lt;==瞭乎？？</span><br></pre></td></tr></table></figure>

<p>由于在默认的情况底下， bash 对于变量有几个基本的定义：</p>
<ul>
<li>变量类型默认为『字符串』，所以若不指定变量类型，则 1+2 为一个『字符串』而不是『计算式』。 所以上述第一个运行的结果才会出现那个情况的；</li>
<li>bash 环境中的数值运算，默认最多仅能到达整数形态，所以 1&#x2F;3 结果是 0；</li>
</ul>
<p>现在你晓得为啥你需要进行变量宣告了吧？如果需要非字符串类型的变量，那就得要进行变量的宣告才行啦！ 底下继续来玩些其他的 declare 功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">范例二：将 sum 变成环境变量</span><br><span class="line">[root@www ~]# declare -x sum</span><br><span class="line">[root@www ~]# export | grep sum</span><br><span class="line">declare -ix sum=&quot;450&quot;  &lt;==果然出现了！包括有 i 与 x 的宣告！</span><br><span class="line"></span><br><span class="line">范例三：让 sum 变成只读属性，不可更动！</span><br><span class="line">[root@www ~]# declare -r sum</span><br><span class="line">[root@www ~]# sum=tesgting</span><br><span class="line">-bash: sum: readonly variable  &lt;==老天爷～不能改这个变量了！</span><br><span class="line"></span><br><span class="line">范例四：让 sum 变成非环境变量的自定义变量吧！</span><br><span class="line">[root@www ~]# declare +x sum  &lt;== 将 - 变成 + 可以进行『取消』动作</span><br><span class="line">[root@www ~]# declare -p sum  &lt;== -p 可以单独列出变量的类型</span><br><span class="line">declare -ir sum=&quot;450&quot; &lt;== 看吧！只剩下 i, r 的类型，不具有 x 啰！</span><br></pre></td></tr></table></figure>

<p>declare 也是个很有用的功能～尤其是当我们需要使用到底下的数组功能时， 他也可以帮我们宣告数组的属性喔！不过，老话一句，数组也是在 shell script 比较常用的啦！ 比较有趣的是，如果你不小心将变量配置为『只读』，通常得要注销再登陆才能复原该变量的类型了！ @_@</p>
<hr>
<ul>
<li><h3 id="数组-array-变量类型"><a href="#数组-array-变量类型" class="headerlink" title="数组 (array) 变量类型"></a>数组 (array) 变量类型</h3></li>
</ul>
<p>某些时候，我们必须使用数组来宣告一些变量，这有什么好处啊？在一般人的使用上， 果然是看不出来有什么好处的！不过，如果您曾经写过程序的话，那才会比较了解数组的意义～ 数组对写数值程序的设计师来说，可是不能错过学习的重点之一哩！好！不啰唆～ 那么要如何配置数组的变量与内容呢？在 bash 里头，数组的配置方式是：</p>
<blockquote>
<p>var[index]&#x3D;content</p>
</blockquote>
<p>意思是说，我有一个数组名为 var ，而这个数组的内容为 var[1]&#x3D;小明， var[2]&#x3D;大明， var[3]&#x3D;好明 …. 等等，那个 index 就是一些数字啦，重点是用中刮号 ([ ]) 来配置的。 目前我们 bash 提供的是一维数组。老实说，如果您不必写一些复杂的程序， 那么这个数组的地方，可以先略过，等到有需要再来学习即可！因为要制作出数组， 通常与循环或者其他判断式交互使用才有比较高的存在意义！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">范例：配置上面提到的 var[1] ～ var[3] 的变量。</span><br><span class="line">[root@www ~]# var[1]=&quot;small min&quot;</span><br><span class="line">[root@www ~]# var[2]=&quot;big min&quot;</span><br><span class="line">[root@www ~]# var[3]=&quot;nice min&quot;</span><br><span class="line">[root@www ~]# echo &quot;$&#123;var[1]&#125;, $&#123;var[2]&#125;, $&#123;var[3]&#125;&quot;</span><br><span class="line">small min, big min, nice min</span><br></pre></td></tr></table></figure>

<p>数组的变量类型比较有趣的地方在于『读取』，一般来说，建议直接以 ${数组} 的方式来读取，比较正确无误的啦！</p>
<hr>
<h2 id="与文件系统及程序的限制关系：-ulimit"><a href="#与文件系统及程序的限制关系：-ulimit" class="headerlink" title="与文件系统及程序的限制关系： ulimit"></a><img src="http://cn.linux.vbird.org/image/logo.png" alt="小标题的图示"><strong>与文件系统及程序的限制关系： ulimit</strong></h2><p>想象一个状况：我的 Linux 主机里面同时登陆了十个人，这十个人不知怎么搞的， 同时开启了 100 个文件，每个文件的大小约 10MBytes ，请问一下， 我的 Linux 主机的内存要有多大才够？ 10<em>100</em>10 &#x3D; 10000 MBytes &#x3D; 10GBytes … 老天爷，这样，系统不挂点才有鬼哩！为了要预防这个情况的发生，所以我们的 bash 是可以『限制用户的某些系统资源』的，包括可以开启的文件数量， 可以使用的 CPU 时间，可以使用的内存总量等等。如何配置？用 ulimit 吧！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@www ~]# ulimit [-SHacdfltu] [配额]</span><br><span class="line">选项与参数：</span><br><span class="line">-H  ：hard limit ，严格的配置，必定不能超过这个配置的数值；</span><br><span class="line">-S  ：soft limit ，警告的配置，可以超过这个配置值，但是若超过则有警告信息。</span><br><span class="line">      在配置上，通常 soft 会比 hard 小，举例来说，soft 可配置为 80 而 hard </span><br><span class="line">      配置为 100，那么你可以使用到 90 (因为没有超过 100)，但介于 80~100 之间时，</span><br><span class="line">      系统会有警告信息通知你！</span><br><span class="line">-a  ：后面不接任何选项与参数，可列出所有的限制额度；</span><br><span class="line">-c  ：当某些程序发生错误时，系统可能会将该程序在内存中的信息写成文件(除错用)，</span><br><span class="line">      这种文件就被称为核心文件(core file)。此为限制每个核心文件的最大容量。</span><br><span class="line">-f  ：此 shell 可以创建的最大文件容量(一般可能配置为 2GB)单位为 Kbytes</span><br><span class="line">-d  ：程序可使用的最大断裂内存(segment)容量；</span><br><span class="line">-l  ：可用于锁定 (lock) 的内存量</span><br><span class="line">-t  ：可使用的最大 CPU 时间 (单位为秒)</span><br><span class="line">-u  ：单一用户可以使用的最大程序(process)数量。</span><br><span class="line"></span><br><span class="line">范例一：列出你目前身份(假设为root)的所有限制数据数值</span><br><span class="line">[root@www ~]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0          &lt;==只要是 0 就代表没限制</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited  &lt;==可创建的单一文件的大小</span><br><span class="line">pending signals                 (-i) 11774</span><br><span class="line">max locked memory       (kbytes, -l) 32</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024       &lt;==同时可开启的文件数量</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 10240</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 11774</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br><span class="line"></span><br><span class="line">范例二：限制用户仅能创建 10MBytes 以下的容量的文件</span><br><span class="line">[root@www ~]# ulimit -f 10240</span><br><span class="line">[root@www ~]# ulimit -a</span><br><span class="line">file size               (blocks, -f) 10240 &lt;==最大量为10240Kbyes，相当10Mbytes</span><br><span class="line">[root@www ~]# dd if=/dev/zero of=123 bs=1M count=20</span><br><span class="line">File size limit exceeded &lt;==尝试创建 20MB 的文件，结果失败了！</span><br></pre></td></tr></table></figure>

<p>还记得我们在<a target="_blank" rel="noopener" href="http://cn.linux.vbird.org/linux_basic/0230filesystem.php">第八章 Linux 磁盘文件系统</a>里面提到过，单一 filesystem 能够支持的单一文件大小与 block 的大小有关。例如 block size 为 1024 byte 时，单一文件可达 16GB 的容量。但是，我们可以用 ulimit 来限制使用者可以创建的文件大小喔！ 利用 ulimit -f 就可以来配置了！例如上面的范例二，要注意单位喔！单位是 Kbytes。 若改天你一直无法创建一个大容量的文件，记得瞧一瞧 ulimit 的信息喔！</p>
<hr>
<h2 id="变量内容的删除、取代与替换"><a href="#变量内容的删除、取代与替换" class="headerlink" title="变量内容的删除、取代与替换"></a><img src="http://cn.linux.vbird.org/image/logo.png" alt="小标题的图示"><strong>变量内容的删除、取代与替换</strong></h2><p>变量除了可以直接配置来修改原本的内容之外，有没有办法透过简单的动作来将变量的内容进行微调呢？ 举例来说，进行变量内容的删除、取代与替换等！是可以的！我们可以透过几个简单的小步骤来进行变量内容的微调喔！ 底下就来试试看！</p>
<hr>
<ul>
<li><h3 id="变量内容的删除与取代"><a href="#变量内容的删除与取代" class="headerlink" title="变量内容的删除与取代"></a>变量内容的删除与取代</h3></li>
</ul>
<p>变量的内容可以很简单的透过几个咚咚来进行删除喔！我们使用 PATH 这个变量的内容来做测试好了。 请你依序进行底下的几个例子来玩玩，比较容易感受的到鸟哥在这里想要表达的意义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">范例一：先让小写的 path 自定义变量配置的与 PATH 内容相同</span><br><span class="line">[root@www ~]# path=$&#123;PATH&#125;</span><br><span class="line">[root@www ~]# echo $path</span><br><span class="line">/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:</span><br><span class="line">/usr/sbin:/usr/bin:/root/bin  &lt;==这两行其实是同一行啦！</span><br><span class="line"></span><br><span class="line">范例二：假设我不喜欢 kerberos，所以要将前两个目录删除掉，如何显示？</span><br><span class="line">[root@www ~]# echo $&#123;path#/*kerberos/bin:&#125;</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure>

<p>上面这个范例很有趣的！他的重点可以用底下这张表格来说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$&#123;variable#/*kerberos/bin:&#125;</span><br><span class="line">   上面的特殊字体部分是关键词！用在这种删除模式所必须存在的</span><br><span class="line"></span><br><span class="line">$&#123;variable#/*kerberos/bin:&#125;</span><br><span class="line">   这就是原本的变量名称，以上面范例二来说，这里就填写 path 这个『变量名称』啦！</span><br><span class="line"></span><br><span class="line">$&#123;variable#/*kerberos/bin:&#125;</span><br><span class="line">   这是重点！代表『从变量内容的最前面开始向右删除』，且仅删除最短的那个</span><br><span class="line"></span><br><span class="line">$&#123;variable#/*kerberos/bin:&#125;</span><br><span class="line">   代表要被删除的部分，由于 # 代表由前面开始删除，所以这里便由开始的 / 写起。</span><br><span class="line">   需要注意的是，我们还可以透过通配符 * 来取代 0 到无穷多个任意字符</span><br><span class="line"></span><br><span class="line">   以上面范例二的结果来看， path 这个变量被删除的内容如下所示：</span><br><span class="line">/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:</span><br><span class="line">/usr/sbin:/usr/bin:/root/bin  &lt;==这两行其实是同一行啦！</span><br></pre></td></tr></table></figure>

<p>很有趣吧！这样了解了 # 的功能了吗？接下来让我们来看看底下的范例三！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">范例三：我想要删除前面所有的目录，仅保留最后一个目录</span><br><span class="line">[root@www ~]# echo $&#123;path#/*:&#125;</span><br><span class="line">/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:</span><br><span class="line">/root/bin     &lt;==这两行其实是同一行啦！</span><br><span class="line"># 由于一个 # 仅删除掉最短的那个，因此他删除的情况可以用底下的删除线来看：</span><br><span class="line"># /usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:</span><br><span class="line"># /usr/sbin:/usr/bin:/root/bin  &lt;==这两行其实是同一行啦！</span><br><span class="line"></span><br><span class="line">[root@www ~]# echo $&#123;path##/*:&#125;</span><br><span class="line">/root/bin</span><br><span class="line"># 嘿！多加了一个 # 变成 ## 之后，他变成『删除掉最长的那个数据』！亦即是：</span><br><span class="line"># /usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:</span><br><span class="line"># /usr/sbin:/usr/bin:/root/bin  &lt;==这两行其实是同一行啦！</span><br></pre></td></tr></table></figure>

<p>非常有趣！不是吗？因为在 PATH 这个变量的内容中，每个目录都是以冒号『:』隔开的， 所以要从头删除掉目录就是介于斜线 (&#x2F;) 到冒号 (:) 之间的数据！但是 PATH 中不止一个冒号 (:) 啊！ 所以 # 与 ## 就分别代表：</p>
<ul>
<li># ：符合取代文字的『最短的』那一个；</li>
<li>##：符合取代文字的『最长的』那一个</li>
</ul>
<p>上面谈到的是『从前面开始删除变量内容』，那么如果想要『从后面向前删除变量内容』呢？ 这个时候就得使用百分比 (%) 符号了！来看看范例四怎么做吧！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">范例四：我想要删除最后面那个目录，亦即从 : 到 bin 为止的字符串</span><br><span class="line">[root@www ~]# echo $&#123;path%:*bin&#125;</span><br><span class="line">/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:</span><br><span class="line">/usr/sbin:/usr/bin  &lt;==注意啊！最后面一个目录不见去！</span><br><span class="line"># 这个 % 符号代表由最后面开始向前删除！所以上面得到的结果其实是来自如下：</span><br><span class="line"># /usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:</span><br><span class="line"># /usr/sbin:/usr/bin:/root/bin  &lt;==这两行其实是同一行啦！</span><br><span class="line"></span><br><span class="line">范例五：那如果我只想要保留第一个目录呢？</span><br><span class="line">[root@www ~]# echo $&#123;path%%:*bin&#125;</span><br><span class="line">/usr/kerberos/sbin</span><br><span class="line"># 同样的， %% 代表的则是最长的符合字符串，所以结果其实是来自如下：</span><br><span class="line"># /usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:</span><br><span class="line"># /usr/sbin:/usr/bin:/root/bin  &lt;==这两行其实是同一行啦！</span><br></pre></td></tr></table></figure>

<p>由于我是想要由变量内容的后面向前面删除，而我这个变量内容最后面的结尾是『&#x2F;root&#x2F;bin』， 所以你可以看到上面我删除的数据最终一定是『bin』，亦即是『:*bin』那个 * 代表通配符！ 至于 % 与 %% 的意义其实与 # 及 ## 类似！这样理解否？</p>
<p>了解了删除功能后，接下来谈谈取代吧！继续玩玩范例六啰！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">范例六：将 path 的变量内容内的 sbin 取代成大写 SBIN：</span><br><span class="line">[root@www ~]# echo $&#123;path/sbin/SBIN&#125;</span><br><span class="line">/usr/kerberos/SBIN:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:</span><br><span class="line">/usr/sbin:/usr/bin:/root/bin</span><br><span class="line"># 这个部分就容易理解的多了！关键词在于那两个斜线，两斜线中间的是旧字符串</span><br><span class="line"># 后面的是新字符串，所以结果就会出现如上述的特殊字体部分啰！</span><br><span class="line"></span><br><span class="line">[root@www ~]# echo $&#123;path//sbin/SBIN&#125;</span><br><span class="line">/usr/kerberos/SBIN:/usr/kerberos/bin:/usr/local/SBIN:/usr/local/bin:/SBIN:/bin:</span><br><span class="line">/usr/SBIN:/usr/bin:/root/bin</span><br><span class="line"># 如果是两条斜线，那么就变成所有符合的内容都会被取代喔！</span><br></pre></td></tr></table></figure>

<p>我们将这部份作个总结说明一下：</p>
<table>
<thead>
<tr>
<th>变量配置方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>${变量#关键词} ${变量##关键词}</td>
<td>若变量内容从头开始的数据符合『关键词』，则将符合的最短数据删除 若变量内容从头开始的数据符合『关键词』，则将符合的最长数据删除</td>
</tr>
<tr>
<td>${变量%关键词} ${变量%%关键词}</td>
<td>若变量内容从尾向前的数据符合『关键词』，则将符合的最短数据删除 若变量内容从尾向前的数据符合『关键词』，则将符合的最长数据删除</td>
</tr>
<tr>
<td>${变量&#x2F;旧字符串&#x2F;新字符串} ${变量&#x2F;&#x2F;旧字符串&#x2F;新字符串}</td>
<td>若变量内容符合『旧字符串』则『第一个旧字符串会被新字符串取代』 若变量内容符合『旧字符串』则『全部的旧字符串会被新字符串取代』</td>
</tr>
</tbody></table>
<hr>
<ul>
<li><h3 id="变量的测试与内容替换"><a href="#变量的测试与内容替换" class="headerlink" title="变量的测试与内容替换"></a>变量的测试与内容替换</h3></li>
</ul>
<p>在某些时刻我们常常需要『判断』某个变量是否存在，若变量存在则使用既有的配置，若变量不存在则给予一个常用的配置。 我们举底下的例子来说明好了，看看能不能较容易被你所理解呢！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">范例一：测试一下是否存在 username 这个变量，若不存在则给予 username 内容为 root [root@www ~]# echo $username           &lt;==由于出现空白，所以 username 可能不存在，也可能是空字符串 [root@www ~]# username=$&#123;username-root&#125; [root@www ~]# echo $username root       &lt;==因为 username 没有配置，所以主动给予名为 root 的内容。 [root@www ~]# username=&quot;vbird tsai&quot; &lt;==主动配置 username 的内容 [root@www ~]# username=$&#123;username-root&#125; [root@www ~]# echo $username vbird tsai &lt;==因为 username 已经配置了，所以使用旧有的配置而不以 root 取代 </span><br></pre></td></tr></table></figure>

<p>在上面的范例中，重点在于减号『 - 』后面接的关键词！基本上你可以这样理解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_var=$&#123;old_var-content&#125;   新的变量，主要用来取代旧变量。新旧变量名称其实常常是一样的 new_var=$&#123;old_var-content&#125;   这是本范例中的关键词部分！必须要存在的哩！ new_var=$&#123;old_var-content&#125;   旧的变量，被测试的项目！ new_var=$&#123;old_var-content&#125;   变量的『内容』，在本范例中，这个部分是在『给予未配置变量的内容』 </span><br></pre></td></tr></table></figure>

<p>不过这还是有点问题！因为 username 可能已经被配置为『空字符串』了！果真如此的话，那你还可以使用底下的范例来给予 username 的内容成为 root 喔！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">范例二：若 username 未配置或为空字符串，则将 username 内容配置为 root [root@www ~]# username=&quot;&quot; [root@www ~]# username=$&#123;username-root&#125; [root@www ~]# echo $username      &lt;==因为 username 被配置为空字符串了！所以当然还是保留为空字符串！ [root@www ~]# username=$&#123;username:-root&#125; [root@www ~]# echo $username root  &lt;==加上『 : 』后若变量内容为空或者是未配置，都能够以后面的内容替换！ </span><br></pre></td></tr></table></figure>

<p>在大括号内有没有冒号『 : 』的差别是很大的！加上冒号后，被测试的变量未被配置或者是已被配置为空字符串时， 都能够用后面的内容 (本例中是使用 root 为内容) 来替换与配置！这样可以了解了吗？除了这样的测试之外， 还有其他的测试方法喔！鸟哥将他整理如下：</p>
<table>
<thead>
<tr>
<th><strong>Tips:</strong> 底下的例子当中，那个 var 与 str 为变量，我们想要针对 str 是否有配置来决定 var 的值喔！ 一般来说， str: 代表『str 没配置或为空的字符串时』；至于 str 则仅为『没有该变量』。</th>
<th><img src="http://cn.linux.vbird.org/linux_basic/0320bash_files/vbird_face.gif" alt="鸟哥的图示"></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>变量配置方式</th>
<th>str 没有配置</th>
<th>str 为空字符串</th>
<th>str 已配置非为空字符串</th>
</tr>
</thead>
<tbody><tr>
<td>var&#x3D;${str-expr}</td>
<td>var&#x3D;expr</td>
<td>var&#x3D;</td>
<td>var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;${str:-expr}</td>
<td>var&#x3D;expr</td>
<td>var&#x3D;expr</td>
<td>var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;${str+expr}</td>
<td>var&#x3D;</td>
<td>var&#x3D;expr</td>
<td>var&#x3D;expr</td>
</tr>
<tr>
<td>var&#x3D;${str:+expr}</td>
<td>var&#x3D;</td>
<td>var&#x3D;</td>
<td>var&#x3D;expr</td>
</tr>
<tr>
<td>var&#x3D;${str&#x3D;expr}</td>
<td>str&#x3D;expr var&#x3D;expr</td>
<td>str 不变 var&#x3D;</td>
<td>str 不变 var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;${str:&#x3D;expr}</td>
<td>str&#x3D;expr var&#x3D;expr</td>
<td>str&#x3D;expr var&#x3D;expr</td>
<td>str 不变 var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;${str?expr}</td>
<td>expr 输出至 stderr</td>
<td>var&#x3D;</td>
<td>var&#x3D;$str</td>
</tr>
<tr>
<td>var&#x3D;${str:?expr}</td>
<td>expr 输出至 stderr</td>
<td>expr 输出至 stderr</td>
<td>var&#x3D;$str</td>
</tr>
</tbody></table>
<p>根据上面这张表，我们来进行几个范例的练习吧！ ^_^！首先让我们来测试一下，如果旧变量 (str) 不存在时， 我们要给予新变量一个内容，若旧变量存在则新变量内容以旧变量来替换，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">范例一：测试一下是否存在 username 这个变量，若不存在则给予 username 内容为 root</span><br><span class="line">[root@www ~]# echo $username</span><br><span class="line">           &lt;==由于出现空白，所以 username 可能不存在，也可能是空字符串</span><br><span class="line">[root@www ~]# username=$&#123;username-root&#125;</span><br><span class="line">[root@www ~]# echo $username</span><br><span class="line">root       &lt;==因为 username 没有配置，所以主动给予名为 root 的内容。</span><br><span class="line">[root@www ~]# username=&quot;vbird tsai&quot; &lt;==主动配置 username 的内容</span><br><span class="line">[root@www ~]# username=$&#123;username-root&#125;</span><br><span class="line">[root@www ~]# echo $username</span><br><span class="line">vbird tsai &lt;==因为 username 已经配置了，所以使用旧有的配置而不以 root 取代</span><br></pre></td></tr></table></figure>

<p>关于减号 (-) 其实上面我们谈过了！这里的测试只是要让你更加了解，这个减号的测试并不会影响到旧变量的内容。 如果你想要将旧变量内容也一起替换掉的话，那么就使用等号 (&#x3D;) 吧！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new_var=$&#123;old_var-content&#125;</span><br><span class="line">   新的变量，主要用来取代旧变量。新旧变量名称其实常常是一样的</span><br><span class="line"></span><br><span class="line">new_var=$&#123;old_var-content&#125;</span><br><span class="line">   这是本范例中的关键词部分！必须要存在的哩！</span><br><span class="line"></span><br><span class="line">new_var=$&#123;old_var-content&#125;</span><br><span class="line">   旧的变量，被测试的项目！</span><br><span class="line"></span><br><span class="line">new_var=$&#123;old_var-content&#125;</span><br><span class="line">   变量的『内容』，在本范例中，这个部分是在『给予未配置变量的内容』</span><br></pre></td></tr></table></figure>

<p>那如果我只是想知道，如果旧变量不存在时，整个测试就告知我『有错误』，此时就能够使用问号『 ? 』的帮忙啦！ 底下这个测试练习一下先！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">测试：若 str 不存在时，则 var 的测试结果直接显示 &quot;无此变量&quot;</span><br><span class="line">[root@www ~]# unset str; var=$&#123;str?无此变量&#125;</span><br><span class="line">-bash: str: 无此变量    &lt;==因为 str 不存在，所以输出错误信息 </span><br><span class="line"></span><br><span class="line">测试：若 str 存在时，则 var 的内容会与 str 相同！</span><br><span class="line">[root@www ~]# str=&quot;oldvar&quot;; var=$&#123;str?novar&#125;</span><br><span class="line">[root@www ~]# echo var=&quot;$var&quot;, str=&quot;$str&quot;</span><br><span class="line">var=oldvar, str=oldvar  &lt;==因为 str 存在，所以 var 等于 str 的内容</span><br></pre></td></tr></table></figure>

<p>基本上这种变量的测试也能够透过 shell script 内的 if…then… 来处理， 不过既然 bash 有提供这么简单的方法来测试变量，那我们也可以多学一些嘛！ 不过这种变量测试通常是在程序设计当中比较容易出现，如果这里看不懂就先略过，未来有用到判断变量值时，再回来看看吧！ ^_^</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://hanlin-cheng.github.io">Hanlin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://hanlin-cheng.github.io/2023/08/25/Linux/Shell%E7%9A%84%E5%8F%98%E9%87%8F%E5%8A%9F%E8%83%BD/">https://hanlin-cheng.github.io/2023/08/25/Linux/Shell%E7%9A%84%E5%8F%98%E9%87%8F%E5%8A%9F%E8%83%BD/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/Shell/">Shell</a></div><div class="post_share"><div class="social-share" data-image="/img/material-7.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/25/README/" title=""><img class="cover" src="/img/material-3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2023/08/25/Linux/%E8%AE%A4%E8%AF%86BASH%E8%BF%99%E4%B8%AAShell/" title="认识BASH这个Shell"><img class="cover" src="/img/material-4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">认识BASH这个Shell</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/08/25/Linux/%E8%AE%A4%E8%AF%86BASH%E8%BF%99%E4%B8%AAShell/" title="认识BASH这个Shell"><img class="cover" src="/img/material-4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-25</div><div class="title">认识BASH这个Shell</div></div></a></div><div><a href="/2023/08/25/slam_config/Ubuntu18.04%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" title="Ubuntu18.04环境配置"><img class="cover" src="/img/material-7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-25</div><div class="title">Ubuntu18.04环境配置</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Hanlin</div><div class="author-info__description">Talk is cheap, show you code</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hanlin-cheng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hanlin-cheng" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:cheng.lv@slamtec.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Shell-%E7%9A%84%E5%8F%98%E9%87%8F%E5%8A%9F%E8%83%BD"><span class="toc-number">1.</span> <span class="toc-text">Shell 的变量功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">什么是变量？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%AF%E5%8F%98%E6%80%A7%E4%B8%8E%E6%96%B9%E4%BE%BF%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">变量的可变性与方便性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%B1%E5%93%8D-bash-%E7%8E%AF%E5%A2%83%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.</span> <span class="toc-text">影响 bash 环境操作的变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-shell-script-%E7%9A%84%E5%A5%BD%E5%B8%AE%E6%89%8B"><span class="toc-number">2.3.</span> <span class="toc-text">脚本程序设计 (shell script) 的好帮手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%96%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%EF%BC%9Aecho-%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E5%AE%88%E5%88%99-unset"><span class="toc-number">3.</span> <span class="toc-text">变量的取用与配置：echo, 变量配置守则, unset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%96%E7%94%A8-echo"><span class="toc-number">3.1.</span> <span class="toc-text">变量的取用: echo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E5%AE%88%E5%88%99"><span class="toc-number">3.2.</span> <span class="toc-text">变量的配置守则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">4.</span> <span class="toc-text">环境变量的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-env-%E8%A7%82%E5%AF%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E8%A7%81%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AF%B4%E6%98%8E"><span class="toc-number">4.1.</span> <span class="toc-text">用 env 观察环境变量与常见环境变量说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-set-%E8%A7%82%E5%AF%9F%E6%89%80%E6%9C%89%E5%8F%98%E9%87%8F-%E5%90%AB%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">4.2.</span> <span class="toc-text">用 set 观察所有变量 (含环境变量与自定义变量)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%B1%E5%93%8D%E6%98%BE%E7%A4%BA%E7%BB%93%E6%9E%9C%E7%9A%84%E8%AF%AD%E7%B3%BB%E5%8F%98%E9%87%8F-locale"><span class="toc-number">5.</span> <span class="toc-text">影响显示结果的语系变量 (locale)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%89%E6%95%88%E8%8C%83%E5%9B%B4"><span class="toc-number">6.</span> <span class="toc-text">变量的有效范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E9%94%AE%E7%9B%98%E8%AF%BB%E5%8F%96%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AE%A3%E5%91%8A%EF%BC%9A-read-array-declare"><span class="toc-number">7.</span> <span class="toc-text">变量键盘读取、数组与宣告： read, array, declare</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#read"><span class="toc-number">7.1.</span> <span class="toc-text">read</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#declare-typeset"><span class="toc-number">7.2.</span> <span class="toc-text">declare &#x2F; typeset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-array-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.3.</span> <span class="toc-text">数组 (array) 变量类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%8A%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%99%90%E5%88%B6%E5%85%B3%E7%B3%BB%EF%BC%9A-ulimit"><span class="toc-number">8.</span> <span class="toc-text">与文件系统及程序的限制关系： ulimit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%86%85%E5%AE%B9%E7%9A%84%E5%88%A0%E9%99%A4%E3%80%81%E5%8F%96%E4%BB%A3%E4%B8%8E%E6%9B%BF%E6%8D%A2"><span class="toc-number">9.</span> <span class="toc-text">变量内容的删除、取代与替换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%86%85%E5%AE%B9%E7%9A%84%E5%88%A0%E9%99%A4%E4%B8%8E%E5%8F%96%E4%BB%A3"><span class="toc-number">9.1.</span> <span class="toc-text">变量内容的删除与取代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%86%85%E5%AE%B9%E6%9B%BF%E6%8D%A2"><span class="toc-number">9.2.</span> <span class="toc-text">变量的测试与内容替换</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/25/slam_config/%E8%BD%A8%E8%BF%B9%E8%AF%84%E4%BC%B0%E4%BB%8B%E7%BB%8D%E4%B8%8Eevo%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" title="轨迹评估介绍与evo工具使用"><img src="/img/material-6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="轨迹评估介绍与evo工具使用"/></a><div class="content"><a class="title" href="/2023/08/25/slam_config/%E8%BD%A8%E8%BF%B9%E8%AF%84%E4%BC%B0%E4%BB%8B%E7%BB%8D%E4%B8%8Eevo%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" title="轨迹评估介绍与evo工具使用">轨迹评估介绍与evo工具使用</a><time datetime="2023-08-25T09:26:09.011Z" title="Created 2023-08-25 17:26:09">2023-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/25/slam_config/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E4%B8%8EIMU%E8%81%94%E5%90%88%E6%A0%87%E5%AE%9A(lidar_IMU_calib)/" title="激光雷达与IMU联合标定(lidar_IMU_calib）"><img src="/img/material-6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="激光雷达与IMU联合标定(lidar_IMU_calib）"/></a><div class="content"><a class="title" href="/2023/08/25/slam_config/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E4%B8%8EIMU%E8%81%94%E5%90%88%E6%A0%87%E5%AE%9A(lidar_IMU_calib)/" title="激光雷达与IMU联合标定(lidar_IMU_calib）">激光雷达与IMU联合标定(lidar_IMU_calib）</a><time datetime="2023-08-25T09:26:09.009Z" title="Created 2023-08-25 17:26:09">2023-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/25/slam_config/%E5%AE%89%E8%A3%85ZED%E4%BB%A5%E5%8F%8Aros%E9%A9%B1%E5%8A%A8/" title="安装ZED以及ros驱动"><img src="/img/material-9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="安装ZED以及ros驱动"/></a><div class="content"><a class="title" href="/2023/08/25/slam_config/%E5%AE%89%E8%A3%85ZED%E4%BB%A5%E5%8F%8Aros%E9%A9%B1%E5%8A%A8/" title="安装ZED以及ros驱动">安装ZED以及ros驱动</a><time datetime="2023-08-25T09:26:09.005Z" title="Created 2023-08-25 17:26:09">2023-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/25/slam_config/%E5%AE%89%E8%A3%85VINS-Fusion/" title="安装VINS-Fusion"><img src="/img/material-4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="安装VINS-Fusion"/></a><div class="content"><a class="title" href="/2023/08/25/slam_config/%E5%AE%89%E8%A3%85VINS-Fusion/" title="安装VINS-Fusion">安装VINS-Fusion</a><time datetime="2023-08-25T09:26:09.003Z" title="Created 2023-08-25 17:26:09">2023-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/25/slam_config/%E5%AE%89%E8%A3%85Rtabmap/" title="安装Rtabmap"><img src="/img/material-2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="安装Rtabmap"/></a><div class="content"><a class="title" href="/2023/08/25/slam_config/%E5%AE%89%E8%A3%85Rtabmap/" title="安装Rtabmap">安装Rtabmap</a><time datetime="2023-08-25T09:26:09.002Z" title="Created 2023-08-25 17:26:09">2023-08-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Hanlin</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>